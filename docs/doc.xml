<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<abstract path="Any" params="" file="E:\HaxeToolkit\haxe\std\Any.hx">
		<from><icast field="__cast"><c path="__cast.T"/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<impl><class path="_Any.Any_Impl_" params="" file="E:\HaxeToolkit\haxe\std\Any.hx" private="1" module="Any"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="Array" params="T" file="E:\HaxeToolkit\haxe\std\Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is 
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed accordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurrence of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<map public="1" params="S" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<resize public="1" set="method">
			<f a="len">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the length of the Array.

		If `len` is shorter than the array's current size, the last
		`length - len` elements will be removed. If `len` is longer, the Array
		will be extended, with new elements set to a target-specific default
		value:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets</haxe_doc>
		</resize>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.

	@see https://haxe.org/manual/std-Array.html
	@see https://haxe.org/manual/lf-array-comprehension.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Class" params="T" file="E:\HaxeToolkit\haxe\std\Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="E:\HaxeToolkit\haxe\std\Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from timestamp (in milliseconds) `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formatted string `s`, with the following accepted
		formats:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats are expressed in local time, the third in UTC
		Epoch.</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp (in milliseconds) of the date. It might
		only have a per-second precision depending on the platforms.

		For measuring time differences with millisecond accuracy on
		all platforms, see `haxe.Timer.stamp`.</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range).</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range).</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range).</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4-digits).</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range).</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range).</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range) where `0` is Sunday.</haxe_doc>
		</getDay>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See `DateTools.format` for
		other formating rules.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There are some extra functions available in the `DateTools` class.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="EReg" params="" file="E:\HaxeToolkit\haxe\std\EReg.hx">
		<match public="1" set="method" line="59">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="74">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, the result is unspecified.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<matchedPos public="1" set="method" line="119">
			<f a=""><a>
	<pos><x path="Int"/></pos>
	<len><x path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position and length of the last matched substring, within
		the String which was last used as argument to `this.match` or
		`this.matchSub`.

		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.

		If the global g modifier was in place for the matching, the position and
		length of the leftmost substring is returned.</haxe_doc>
		</matchedPos>
		<matchSub public="1" set="method" line="134">
			<f a="s:pos:?len" v="::-1">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ len : -1 }</e></m></meta>
			<haxe_doc>Tells if `this` regular expression matches a substring of String `s`.

		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.match(s.substr(pos,len))` can be used instead.

		This method modifies the internal state.

		If `s` is null, the result is unspecified.</haxe_doc>
		</matchSub>
		<replace public="1" set="method" line="174">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces the first substring of `s` which `this` EReg matches with `by`.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `by` contains `$1` to `$9`, the digit corresponds to number of a
		matched sub-group and its value is used instead. If no such sub-group
		exists, the replacement is unspecified. The string `$$` becomes `$`.

		If `s` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<map public="1" set="method" line="192">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>Calls the function `f` for the substring of `s` which `this` EReg matches
		and replaces that substring with the result of `f` call.

		The `f` function takes `this` EReg object as its first argument and should
		return a replacement string for the substring matched.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `s` or `f` are null, the result is unspecified.</haxe_doc>
		</map>
		<new public="1" set="method" line="48">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax `~/pattern/modifier`

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	<https://haxe.org/manual/std-regex.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="E:\HaxeToolkit\haxe\std\Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="E:\HaxeToolkit\haxe\std\EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="E:\HaxeToolkit\haxe\std\EnumValue.hx" private="1" module="EnumValue"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="Lambda" params="" file="E:\HaxeToolkit\haxe\std\Lambda.hx">
		<array public="1" params="A" set="method" line="47" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an Array from Iterable `it`.

		If `it` is an Array, this function returns a copy of it.</haxe_doc>
		</array>
		<count public="1" params="A" set="method" line="197" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="">
					<c path="count.A"/>
					<x path="Bool"/>
				</f>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the number of elements in `it` for which `pred` is true, or the
		total number of elements in `it` if `pred` is null.

		This function traverses all elements.</haxe_doc>
		</count>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with `using Lambda` and then acts as an
	extension to Iterable types.

	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.

	If the first argument to any of the methods is null, the result is
	unspecified.

	@see https://haxe.org/manual/std-Lambda.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="List" params="T" file="E:\HaxeToolkit\haxe\std\List.hx"><c path="haxe.ds.List"><c path="List.T"/></c></typedef>
	<typedef path="Map" params="K:V" file="E:\HaxeToolkit\haxe\std\Map.hx"><x path="haxe.ds.Map">
	<c path="Map.K"/>
	<c path="Map.V"/>
</x></typedef>
	<typedef path="IMap" params="K:V" file="E:\HaxeToolkit\haxe\std\Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="Math" params="" file="E:\HaxeToolkit\haxe\std\Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter,
		specified by the constant, π. `PI` is approximately 3.141592653589793.</haxe_doc>
		</PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of -1.0 / 0.0.

		Operations with `NEGATIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes positive infinity.

		For example, this is the result of 1.0 / 0.0.

		Operations with `POSITIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes an invalid number.

		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).

		All further operations with `NaN` as an operand will result in `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.

		In order to test if a value is `NaN`, you should use `Math.isNaN()` function.</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		If `v` is positive or 0, the result is unchanged. Otherwise the result
		is -`v`.

		If `v` is `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is
		`POSITIVE_INFINITY`.

		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.
		If `a` and `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `a` and `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</tan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</acos>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of
		two specified numbers, in radians.

		If parameter `x` or `y`  is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is `NaN`.</haxe_doc>
		</atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		exp(1.0) is approximately 2.718281828459.

		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `NEGATIVE_INFINITY`, the result is `0.0`.
		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.

		This is the mathematical inverse operation of exp,
		i.e. `log(exp(v)) == v` always holds.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `0.0`.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0,
		and less than 1.0.</haxe_doc>
		</random>
		<ffloor public="1" get="inline" set="null" line="263" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" get="inline" set="null" line="267" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<fround public="1" get="inline" set="null" line="271" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` or `NaN`, the result
		is `false`, otherwise the result is `true`.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is `NaN`, the result is `true`, otherwise the result is `false`.
		In particular, both `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` are
		not considered `NaN`.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.

	@see https://haxe.org/manual/std-math.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Reflect" params="" file="E:\HaxeToolkit\haxe\std\Reflect.hx" extern="1">
		<hasField public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if structure `o` has a field named `field`.

		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.

		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<setField public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`.

		If `o` has no field named `field`, this function is only guaranteed to
		work for anonymous structures.

		If `o` or `field` are null, the result is unspecified.

		(As3) If used on a property field, the setter will be invoked. It is
		not possible to set the value directly.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`, taking
		property setter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.setField`, but might be slower.

		If `field` is null, the result is unspecified.</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" static="1">
			<f a="o:func:args">
				<d/>
				<x path="haxe.Function"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method `func` with the given arguments `args`.

		The object `o` is ignored in most cases. It serves as the `this`-context in the following
		situations:

		* (neko) Allows switching the context to `o` in all cases.
		* (macro) Same as neko for Haxe 3. No context switching in Haxe 4.
		* (js, lua) Require the `o` argument if `func` does not, but should have a context.
		    This can occur by accessing a function field natively, e.g. through `Reflect.field`
			or by using `(object : Dynamic).field`. However, if `func` has a context, `o` is
			ignored like on other targets.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `f` is a function, false otherwise.

		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares `a` and `b`.

		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.

		This function is only defined if `a` and `b` are of the same type.

		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.

		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:

		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified

		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Compares the functions `f1` and `f2`.

		If `f1` or `f2` are null, the result is false.
		If `f1` or `f2` are not functions, the result is unspecified.

		Otherwise the result is true if `f1` and the `f2` are physically equal,
		false otherwise.

		If `f1` or `f2` are member method closures, the result is true if they
		are closures of the same method on the same object value, false otherwise.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[Tells if `v` is an object.

		The result is true if `v` is one of the following:

		- class instance
		- structure
		- `Class<T>`
		- `Enum<T>`

		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `v` is an enum value.

		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.

		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<deleteField public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the field named `field` from structure `o`.

		This method is only guaranteed to work on anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Copies the fields of structure `o`.

		This is only guaranteed to work on anonymous structures.

		If `o` is null, the result is unspecified.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method">
	<f a="f">
		<f a="">
			<c path="Array"><d/></c>
			<x path="Void"/>
		</f>
		<d/>
	</f>
	<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
</makeVarArgs></overloads>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.

	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Std" params="" file="E:\HaxeToolkit\haxe\std\Std.hx" extern="1">
		<is public="1" set="method" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.</haxe_doc>
		</is>
		<instance public="1" params="T:S" set="method" static="1">
			<f a="value:c">
				<c path="instance.T"/>
				<x path="Class"><c path="instance.S"/></x>
				<c path="instance.S"/>
			</f>
			<haxe_doc>Checks if object `value` is an instance of class `c`.

		Compiles only if the class specified by `c` can be assigned to the type
		of `value`.

		This method checks if a downcast is possible. That is, if the runtime
		type of `value` is assignable to the class specified by `c`, `value` is
		returned. Otherwise null is returned.

		This method is not guaranteed to work with interfaces or core types such
		as `String`, `Array` and `Date`.

		If `value` is null, the result is null. If `c` is null, the result is
		unspecified.</haxe_doc>
		</instance>
		<string public="1" set="method" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If `x` is null, the result is unspecified.
		If `x` cannot be parsed as integer, the result is `null`.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[Return a random integer between 0 included and `x` excluded.

		If `x <= 1`, the result is always 0.]]></haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Void" params="" file="E:\HaxeToolkit\haxe\std\StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="E:\HaxeToolkit\haxe\std\StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="E:\HaxeToolkit\haxe\std\StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Null" params="T" file="E:\HaxeToolkit\haxe\std\StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accept or can return a `null` value, or for the Flash compiler and AS3
	generator to distinguish between base values that can be `null` and others that
	can't.

	@see https://haxe.org/manual/types-nullability.html</haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="E:\HaxeToolkit\haxe\std\StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="E:\HaxeToolkit\haxe\std\StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="E:\HaxeToolkit\haxe\std\StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="E:\HaxeToolkit\haxe\std\StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="E:\HaxeToolkit\haxe\std\StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="E:\HaxeToolkit\haxe\std\StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has an `iterator()` method
	to iterate over key-value-pairs.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="E:\HaxeToolkit\haxe\std\StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="String" params="" file="E:\HaxeToolkit\haxe\std\String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.
	
	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="StringBuf" params="" file="E:\HaxeToolkit\haxe\std\StringBuf.hx">
		<b><c path="String"/></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` StringBuf in characters.</haxe_doc>
		</length>
		<new public="1" get="inline" set="null" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="E:\HaxeToolkit\haxe\std\StringTools.hx">
		<htmlEscape public="1" set="method" line="153" static="1">
			<f a="s:?quotes">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Escapes HTML special characters of the string `s`.

		The following replacements are made:

		- `&` becomes `&amp`;
		- `<` becomes `&lt`;
		- `>` becomes `&gt`;

		If `quotes` is true, the following characters are also replaced:

		- `"` becomes `&quot`;
		- `'` becomes `&#039`;]]></haxe_doc>
		</htmlEscape>
		<startsWith public="1" set="method" line="193" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` starts with the string `start`.

		If `start` is `null`, the result is unspecified.

		If `start` is the empty String `""`, the result is true.</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="223" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` ends with the string `end`.

		If `end` is `null`, the result is unspecified.

		If `end` is the empty String `""`, the result is true.</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="259" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String `""`, or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="276" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="301" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="323" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading and trailing space characters of `s`.

		This is a convenience function for `ltrim(rtrim(s))`.</haxe_doc>
		</trim>
		<lpad public="1" set="method" line="345" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Concatenates `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String `""` or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</lpad>
		<hex public="1" set="method" line="414" static="1">
			<f a="n:?digits">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its `length` equals `digits`.</haxe_doc>
		</hex>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)
	to the `String` class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Sys" params="" file="E:\HaxeToolkit\haxe\std\Sys.hx" extern="1">
		<print public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output.</haxe_doc>
		</print>
		<println public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output, followed by a newline.</haxe_doc>
		</println>
		<args public="1" set="method" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns all the arguments that were passed by the command line.</haxe_doc>
		</args>
		<getEnv public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the given environment variable.</haxe_doc>
		</getEnv>
		<putEnv public="1" set="method" static="1">
			<f a="s:v">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the value of the given environment variable.</haxe_doc>
		</putEnv>
		<environment public="1" set="method" static="1">
			<f a=""><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></f>
			<haxe_doc>Returns all environment variables.</haxe_doc>
		</environment>
		<sleep public="1" set="method" static="1">
			<f a="seconds">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Suspend the current execution for the given time (in seconds).</haxe_doc>
		</sleep>
		<setTimeLocale public="1" set="method" static="1">
			<f a="loc">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Change the current time locale, which will affect `DateTools.format` date formating.
		Returns true if the locale was successfully changed</haxe_doc>
		</setTimeLocale>
		<getCwd public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Get the current working directory (usually the one in which the program was started)</haxe_doc>
		</getCwd>
		<setCwd public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change the current working directory.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the name of the system you are running on. For instance :
			"Windows", "Linux", "BSD" and "Mac" depending on your desktop OS.</haxe_doc>
		</systemName>
		<command public="1" set="method" static="1">
			<f a="cmd:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
			</f>
			<haxe_doc>Run the given command. The command output will be printed on the same output as the current process.
		The current process will block until the command terminates and it will return the command result (0 if there was no error).

		Command arguments can be passed in two ways: 1. using `args`, 2. appending to `cmd` and leaving `args` as `null`.

		 1. When using `args` to pass command arguments, each argument will be automatically quoted, and shell meta-characters will be escaped if needed.
		`cmd` should be an executable name that can be located in the `PATH` environment variable, or a path to an executable.

		 2. When `args` is not given or is `null`, command arguments can be appended to `cmd`. No automatic quoting/escaping will be performed. `cmd` should be formatted exactly as it would be when typed at the command line.
		It can run executables, as well as shell commands that are not executables (e.g. on Windows: `dir`, `cd`, `echo` etc).

		Read the `sys.io.Process` api for a more complete way to start background processes.</haxe_doc>
		</command>
		<exit public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Exit the current process with the given error code.</haxe_doc>
		</exit>
		<time public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds).</haxe_doc>
		</time>
		<cpuTime public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds) but only account for the actual time spent running on the CPU for the current thread/process.</haxe_doc>
		</cpuTime>
		<executablePath public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":deprecated"><e>"Use programPath instead"</e></m></meta>
			<haxe_doc>Returns the path to the current executable that we are running.</haxe_doc>
		</executablePath>
		<programPath public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the absolute path to the current program file that we are running.
		Concretely, for an executable binary, it returns the path to the binary.
		For a script (e.g. a PHP file), it returns the path to the script.</haxe_doc>
		</programPath>
		<getChar public="1" set="method" static="1">
			<f a="echo">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read a single input character from the standard input and returns it. Setting `echo` to true will also display it on the output.</haxe_doc>
		</getChar>
		<stdin public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Input"/></f>
			<haxe_doc>Returns the process standard input, from which you can read what user enters. Usually it will block until the user send a full input line. See `getChar` for an alternative.</haxe_doc>
		</stdin>
		<stdout public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard output on which you can write.</haxe_doc>
		</stdout>
		<stderr public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard error on which you can write.</haxe_doc>
		</stderr>
		<haxe_doc>This class gives you access to many base functionalities of system platforms. Looks in `sys` sub packages for more system APIs.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":require"><e>sys</e></m>
		</meta>
	</class>
	<class path="Type" params="" file="E:\HaxeToolkit\haxe\std\Type.hx" extern="1">
		<getClass public="1" params="T" set="method" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" static="1">
			<f a="o">
				<x path="EnumValue"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc><![CDATA[Returns the enum of enum instance `o`.

		An enum instance is the result of using an enum constructor. Given an
		`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.

		If `o` is null, null is returned.

		In general, type parameter information cannot be obtained at runtime.]]></haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Returns the super-class of class `c`.

		If `c` has no super class, null is returned.

		If `c` is null, the result is unspecified.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc>Resolves an enum by name.

		If `name` is the path of an existing enum, that enum is returned.

		Otherwise null is returned.

		If `name` is null the result is unspecified.

		If `name` is the path to a different type, null is returned.

		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createEnumIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the instance fields of class `c`.

		This only includes fields which are known at compile-time. In
		particular, using getInstanceFields(getClass(obj)) will not include
		any fields which were added to obj at runtime.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.

		(As3) This method only returns instance fields that are public.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of static fields of class `c`.

		This does not include static fields of parent classes.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.

		(As3) This method only returns class fields that are public.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of value `v`.

		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<enumIndex public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" static="1">
			<f a="e">
				<x path="Enum"><c path="allEnums.T"/></x>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</allEnums>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="ValueType" params="" file="E:\HaxeToolkit\haxe\std\Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
		<haxe_doc>The different possible runtime types of a value.</haxe_doc>
	</enum>
	<abstract path="UInt" params="" file="E:\HaxeToolkit\haxe\std\UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>The unsigned `Int` type is only defined for Flash and C#.
	Simulate it for other platforms.

	@see https://haxe.org/manual/types-basic-types.html</haxe_doc>
		<impl><class path="_UInt.UInt_Impl_" params="" file="E:\HaxeToolkit\haxe\std\UInt.hx" private="1" module="UInt"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="XmlType" params="" file="E:\HaxeToolkit\haxe\std\Xml.hx" module="Xml">
		<this><x path="Int"/></this>
		<haxe_doc>Xml node types.

	@see https://haxe.org/manual/std-Xml.html</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="_Xml.XmlType_Impl_" params="" file="E:\HaxeToolkit\haxe\std\Xml.hx" private="1" module="Xml"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="Xml" params="" file="E:\HaxeToolkit\haxe\std\Xml.hx">
		<Element public="1" set="null" expr="XmlType.Element" line="68" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Element</e></m></meta>
			<haxe_doc>XML element type.</haxe_doc>
		</Element>
		<PCData public="1" set="null" expr="XmlType.PCData" line="72" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.PCData</e></m></meta>
			<haxe_doc>XML parsed character data type.</haxe_doc>
		</PCData>
		<CData public="1" set="null" expr="XmlType.CData" line="76" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.CData</e></m></meta>
			<haxe_doc>XML character data type.</haxe_doc>
		</CData>
		<Comment public="1" set="null" expr="XmlType.Comment" line="80" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Comment</e></m></meta>
			<haxe_doc>XML comment type.</haxe_doc>
		</Comment>
		<DocType public="1" set="null" expr="XmlType.DocType" line="84" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.DocType</e></m></meta>
			<haxe_doc>XML doctype element type.</haxe_doc>
		</DocType>
		<ProcessingInstruction public="1" set="null" expr="XmlType.ProcessingInstruction" line="88" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.ProcessingInstruction</e></m></meta>
			<haxe_doc>XML processing instruction type.</haxe_doc>
		</ProcessingInstruction>
		<Document public="1" set="null" expr="XmlType.Document" line="92" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Document</e></m></meta>
			<haxe_doc>XML document type.</haxe_doc>
		</Document>
		<parse public="1" set="method" line="97" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Parses the String into an Xml document.</haxe_doc>
		</parse>
		<createElement public="1" set="method" line="158" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="167" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="176" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="185" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="194" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocType>
		<createProcessingInstruction public="1" set="method" line="203" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createProcessingInstruction>
		<createDocument public="1" set="method" line="212" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocument>
		<nodeType public="1" set="null">
			<x path="XmlType"/>
			<haxe_doc>Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.</haxe_doc>
		</nodeType>
		<nodeName public="1" get="null" set="null">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>Returns the node name of an Element.</haxe_doc>
		</nodeName>
		<nodeValue public="1" get="null" set="null">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>Returns the node value. Only works if the Xml node is not an Element or a Document.</haxe_doc>
		</nodeValue>
		<parent public="1" set="null">
			<c path="Xml"/>
			<haxe_doc>Returns the parent object in the Xml hierarchy.
		The parent can be `null`, an Element or a Document.</haxe_doc>
		</parent>
		<children><c path="Array"><c path="Xml"/></c></children>
		<attributeMap><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></attributeMap>
		<get public="1" set="method" line="220">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get the given attribute of an Element node. Returns `null` if not found.
		Attributes are case-sensitive.</haxe_doc>
		</get>
		<set public="1" set="method" line="231">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the given attribute value for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</set>
		<exists public="1" set="method" line="253">
			<f a="att">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the Element node has a given attribute.
		Attributes are case-sensitive.</haxe_doc>
		</exists>
		<attributes public="1" set="method" line="263">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an `Iterator` on all the attribute names.</haxe_doc>
		</attributes>
		<elements public="1" set="method" line="283">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elements>
		<elementsNamed public="1" set="method" line="293">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elementsNamed>
		<firstElement public="1" set="method" line="310">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node which is an Element.</haxe_doc>
		</firstElement>
		<addChild public="1" set="method" line="326">
			<f a="x">
				<c path="Xml"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds a child node to the Document or Element.
		A child node can only be inside one given parent node, which is indicated by the `parent` property.
		If the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.
		If the child node was previously inside a different node, it will be moved to this Document or Element.</haxe_doc>
		</addChild>
		<removeChild public="1" set="method" line="339">
			<f a="x">
				<c path="Xml"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.</haxe_doc>
		</removeChild>
		<toString public="1" get="inline" set="null" line="366">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of the Xml node.</haxe_doc>
		</toString>
		<new set="method" line="370"><f a="nodeType">
	<x path="XmlType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Cross-platform Xml API.

	@see https://haxe.org/manual/std-Xml.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="format.gif.Data" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx">
		<a>
			<version>
				<e path="format.gif.Version"/>
				<haxe_doc>* Gif version. There is only 2 Gif version exists. 87a and 89a.
   * 87a have less features and does not support any extensions.
   * Unknown version is adviced to be interpreted as newest (89a) official version.</haxe_doc>
			</version>
			<logicalScreenDescriptor>
				<t path="format.gif.LogicalScreenDescriptor"/>
				<haxe_doc>* Information about logical screen of Gif that provides basic information about Gif.</haxe_doc>
			</logicalScreenDescriptor>
			<globalColorTable>
				<x path="Null"><t path="format.gif.ColorTable"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Global color table used for Gif. Present only if Logical Screen Descriptor contained global color table flag.
   * Note that this color table not always present since frames can contain local color tables that overrides global color table.</haxe_doc>
			</globalColorTable>
			<blocks>
				<t path="List"><e path="format.gif.Block"/></t>
				<haxe_doc>* List of Gif data blocks.</haxe_doc>
			</blocks>
		</a>
		<haxe_doc>* Gif data.</haxe_doc>
	</typedef>
	<enum path="format.gif.Block" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<BFrame a="frame">
			<t path="format.gif.Frame"/>
			<haxe_doc>* Gif frame block.
   * Note that this block does not contain link to graphic control extension of Frame even if it is present. GraphicControl extension Block commonly present right before frame Block.</haxe_doc>
		</BFrame>
		<BExtension a="extension">
			<e path="format.gif.Extension"/>
			<haxe_doc>* Additional extension block. This Block does not supported in 87a Gif specification version.</haxe_doc>
		</BExtension>
		<BEOF><haxe_doc>* End of File block. Represents end of Gif data.</haxe_doc></BEOF>
		<haxe_doc>* Gif data block. Custom blocks are not supported.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="format.gif.Extension" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<EGraphicControl a="gce">
			<t path="format.gif.GraphicControlExtension"/>
			<haxe_doc>* Graphic Control extension gives additional control over next frame, like frame delay, disposal method, alpha channel and other information.</haxe_doc>
		</EGraphicControl>
		<EComment a="text">
			<c path="String"/>
			<haxe_doc>* Commentary extension. Not show up as any visual, just a text in file.</haxe_doc>
		</EComment>
		<EText a="pte">
			<t path="format.gif.PlainTextExtension"/>
			<haxe_doc>* Text extension. Must work as text rendering on the image, but ignored by all major Gif decoders.</haxe_doc>
		</EText>
		<EApplicationExtension a="ext">
			<e path="format.gif.ApplicationExtension"/>
			<haxe_doc>* Application extension allow to insert additional application data into Gif. Mostly used app extension is NETSCAPE2.0 looping extension, used to set up amount of loops in frame.</haxe_doc>
		</EApplicationExtension>
		<EUnknown a="id:data">
			<x path="Int"/>
			<c path="haxe.io.Bytes"/>
			<haxe_doc>* Unknown extension.</haxe_doc>
		</EUnknown>
		<haxe_doc>* Extension block contains additional data about Gif image. This block does not supported by 87a version.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="format.gif.ApplicationExtension" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<AENetscapeLooping a="loops">
			<x path="Int"/>
			<haxe_doc>* NETSCAPE2.0 looping extension. Contains only amount of animation repeats.
   * Note that there is two NETSCAPE2.0 app extensions for Gif format and the type of extension is stored in first byte of data. Looping extension have ID 1.</haxe_doc>
		</AENetscapeLooping>
		<AEUnknown a="name:version:data">
			<c path="String"/>
			<c path="String"/>
			<c path="haxe.io.Bytes"/>
			<haxe_doc>* Unknown or unsupported app extension.</haxe_doc>
		</AEUnknown>
		<haxe_doc>* Application extension. Mostly used only for one reason - setting up loops count. There is exist other app extensions but they are really rare.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="format.gif.ColorTable" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<c path="haxe.io.Bytes"/>
		<haxe_doc>* Typical color table for Gif image.
 * Can contain 2, 4, 8, 16, 32, 64, 128 or 256 colors.
 * Data stored in RGB format. Information about alpha channel provided by Graohic Control Extension.</haxe_doc>
	</typedef>
	<typedef path="format.gif.Frame" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<a>
			<y>
				<x path="Int"/>
				<haxe_doc>* Y position of image on the Logical Screen</haxe_doc>
			</y>
			<x>
				<x path="Int"/>
				<haxe_doc>* X position of image on the Logical Screen</haxe_doc>
			</x>
			<width>
				<x path="Int"/>
				<haxe_doc>* Width of image in pixels</haxe_doc>
			</width>
			<sorted>
				<x path="Bool"/>
				<haxe_doc>* Is local color table sorted in order of decreasing priority?</haxe_doc>
			</sorted>
			<pixels>
				<c path="haxe.io.Bytes"/>
				<haxe_doc>* Pixel data of frame. Stored as Indexed colors, 1 byte per pixel.</haxe_doc>
			</pixels>
			<localColorTableSize>
				<x path="Int"/>
				<haxe_doc>* Size of local color table</haxe_doc>
			</localColorTableSize>
			<localColorTable>
				<x path="Bool"/>
				<haxe_doc>* Is this image uses local color table?</haxe_doc>
			</localColorTable>
			<interlaced>
				<x path="Bool"/>
				<haxe_doc>* Is this image written in interlace mode?
   * Note: The pixel data already deinterlaced and this flag presented only for information purpose (and for Writer when there is one).</haxe_doc>
			</interlaced>
			<height>
				<x path="Int"/>
				<haxe_doc>* Height of image in pixels</haxe_doc>
			</height>
			<colorTable>
				<t path="format.gif.ColorTable"/>
				<haxe_doc>* Local color table used by frame. Stored as 3-byte RGB colors. If value is null, must be used global color table.</haxe_doc>
			</colorTable>
		</a>
		<haxe_doc>* Single frame of the image.
 * Actually it's a merge of 3 consequent blocks:
 * 1. Image Descriptor.
 * Contains frame informations like position, size, existing of local color table and interlaced flag.
 * 2. [Local color table].
 * Only present if Image Descriptor contains local color table flag. Overrides global color table.
 * 3. Pixel data blocks.
 * LZW compressed pixel data.</haxe_doc>
	</typedef>
	<typedef path="format.gif.GraphicControlExtension" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<a>
			<userInput>
				<x path="Bool"/>
				<haxe_doc>* Is image must wait for user input, before dispose?
   * This flag may be used by user-defined program but absolutely ignored by any Gif players.</haxe_doc>
			</userInput>
			<transparentIndex>
				<x path="Int"/>
				<haxe_doc>* Index in color table that used as transparent.</haxe_doc>
			</transparentIndex>
			<hasTransparentColor>
				<x path="Bool"/>
				<haxe_doc>* Is image have transparency?</haxe_doc>
			</hasTransparentColor>
			<disposalMethod>
				<e path="format.gif.DisposalMethod"/>
				<haxe_doc>* Disposal method of frame.</haxe_doc>
			</disposalMethod>
			<delay>
				<x path="Int"/>
				<haxe_doc>* Delay, before next image appears. Delay is in centiseconds (1 centisecond = 1/100 seconds).
   * Note: Some players (like FastStone) cut fraction of elapsed time when progressing to next frame which results in small timing error.
   * Recommended to use `time -= delay` instead of `time = 0`.</haxe_doc>
			</delay>
		</a>
		<haxe_doc>* Graphic Control Extension block, used for setting up disposal method, transparency, delay and user input.</haxe_doc>
	</typedef>
	<typedef path="format.gif.PlainTextExtension" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<a>
			<textGridY>
				<x path="Int"/>
				<haxe_doc>* Y position of text grid on Logical Screen.</haxe_doc>
			</textGridY>
			<textGridX>
				<x path="Int"/>
				<haxe_doc>* X position of text grid on Logical Screen.</haxe_doc>
			</textGridX>
			<textGridWidth>
				<x path="Int"/>
				<haxe_doc>* Width of text grid in pixels.</haxe_doc>
			</textGridWidth>
			<textGridHeight>
				<x path="Int"/>
				<haxe_doc>* Height of text grid in pixels.</haxe_doc>
			</textGridHeight>
			<textForegroundColorIndex>
				<x path="Int"/>
				<haxe_doc>* Foreground/character color index.</haxe_doc>
			</textForegroundColorIndex>
			<textBackgroundColorIndex>
				<x path="Int"/>
				<haxe_doc>* Background color index.</haxe_doc>
			</textBackgroundColorIndex>
			<text>
				<c path="String"/>
				<haxe_doc>* Text to render.</haxe_doc>
			</text>
			<charCellWidth>
				<x path="Int"/>
				<haxe_doc>* Width of character cell in text grid.</haxe_doc>
			</charCellWidth>
			<charCellHeight>
				<x path="Int"/>
				<haxe_doc>* Height of character cell in text grid.</haxe_doc>
			</charCellHeight>
		</a>
		<haxe_doc>* Extension for rendering text on Gif logical screen. It does not supported by major Gif decoders.
 * Font and text size decision is left to decoder. (recommended to decide based on grid/cell size)
 * Text must be rendered with one character at cell.
 * It's recommended to replace any characters less than 0x20 and greater than 0xf7 to be rendered as Space (0x20)</haxe_doc>
	</typedef>
	<typedef path="format.gif.LogicalScreenDescriptor" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<a>
			<width>
				<x path="Int"/>
				<haxe_doc>* Width of GIF image in pixels</haxe_doc>
			</width>
			<sorted>
				<x path="Bool"/>
				<haxe_doc>* Specification:
   * Indicates whether the Global Color Table is sorted.
     If the flag is set, the Global Color Table is sorted, in order of
     decreasing importance. Typically, the order would be decreasing
     frequency, with most frequent color first. This assists a decoder,
     with fewer available colors, in choosing the best subset of colors;
     the decoder may use an initial segment of the table to render the
     graphic.</haxe_doc>
			</sorted>
			<pixelAspectRatio>
				<x path="Float"/>
				<haxe_doc>* Factor used to compute an approximation of the aspect ratio of the pixel in the original image.</haxe_doc>
			</pixelAspectRatio>
			<height>
				<x path="Int"/>
				<haxe_doc>* Height of GIF image in pixels</haxe_doc>
			</height>
			<hasGlobalColorTable>
				<x path="Bool"/>
				<haxe_doc>* Is this file uses global color table?</haxe_doc>
			</hasGlobalColorTable>
			<globalColorTableSize>
				<x path="Int"/>
				<haxe_doc>* Size of global color table.</haxe_doc>
			</globalColorTableSize>
			<colorResolution>
				<x path="Int"/>
				<haxe_doc>* Specification:
   * Number of bits per primary color available
     to the original image, minus 1. This value represents the size of
     the entire palette from which the colors in the graphic were
     selected, not the number of colors actually used in the graphic.
     For example, if the value in this field is 3, then the palette of
     the original image had 4 bits per primary color available to create
     the image.  This value should be set to indicate the richness of
     the original palette, even if not every color from the whole
     palette is available on the source machine.</haxe_doc>
			</colorResolution>
			<backgroundColorIndex>
				<x path="Int"/>
				<haxe_doc>* Background color index in global color table</haxe_doc>
			</backgroundColorIndex>
		</a>
		<haxe_doc>* Logical screen descriptor of GIF file.
 * Contains very basic information about Gif.</haxe_doc>
	</typedef>
	<enum path="format.gif.Version" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<GIF87a><haxe_doc>* First version of Gif file format from May 1987.
   * 
   * Note: The checking of unsupported blocks disabled by default to save some time. To enable supported blocks check set `yagp_strict_version_check` debug variable.</haxe_doc></GIF87a>
		<GIF89a><haxe_doc>* Second and actual version of Gif file format from July 1989.</haxe_doc></GIF89a>
		<Unknown a="version">
			<c path="String"/>
			<haxe_doc>* Unknown version of Gif file.</haxe_doc>
		</Unknown>
		<haxe_doc>* Version of Gif file.  
 * The only 2 official versions is GIF87a and GIF89a.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="format.gif.DisposalMethod" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Data.hx" module="format.gif.Data">
		<UNSPECIFIED><haxe_doc>* The disposal method is unspecified. Action on demand of viewer.
   * 
   * Mostly interpreted as NO_ACTION.</haxe_doc></UNSPECIFIED>
		<NO_ACTION><haxe_doc>* No action required.</haxe_doc></NO_ACTION>
		<FILL_BACKGROUND><haxe_doc>* Fill frame rectangle with background color.
   * 
   * Usage note: 
   * Most renderers clears to transparency instead of filling background color, when frame's transparent color index not equals to background color index.</haxe_doc></FILL_BACKGROUND>
		<RENDER_PREVIOUS><haxe_doc>* Render previous state of gif as it before rendering disposing frame.</haxe_doc></RENDER_PREVIOUS>
		<UNDEFINED a="index">
			<x path="Int"/>
			<haxe_doc>* Reserved disposal methods.</haxe_doc>
		</UNDEFINED>
		<haxe_doc>* Disposal method of GIF frame.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="format.gif.Reader" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<read public="1" set="method" line="22"><f a=""><t path="format.gif.Data"/></f></read>
		<readBlock set="method" line="80"><f a=""><e path="format.gif.Block"/></f></readBlock>
		<readImage set="method" line="98"><f a=""><e path="format.gif.Block"/></f></readImage>
		<readPixels set="method" line="129"><f a="width:height:interlaced">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="haxe.io.Bytes"/>
</f></readPixels>
		<deinterlace set="method" line="236"><f a="input:output:step:y:offset:width:height">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></deinterlace>
		<readExtension set="method" line="247"><f a=""><e path="format.gif.Block"/></f></readExtension>
		<readApplicationExtension set="method" line="302"><f a=""><e path="format.gif.Block"/></f></readApplicationExtension>
		<readBlocks get="inline" set="null" line="315"><f a=""><c path="haxe.io.Bytes"/></f></readBlocks>
		<readColorTable set="method" line="332"><f a="size">
	<x path="Int"/>
	<t path="format.gif.ColorTable"/>
</f></readColorTable>
		<new public="1" set="method" line="16"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Yanrishatum</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.gif.Tools" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/gif/Tools.hx">
		<framesCount public="1" set="method" line="16" static="1">
			<f a="data">
				<t path="format.gif.Data"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns amount of frames in Gif data.</haxe_doc>
		</framesCount>
		<frame public="1" set="method" line="37" static="1">
			<f a="data:frameIndex">
				<t path="format.gif.Data"/>
				<x path="Int"/>
				<t path="format.gif.Frame"/>
			</f>
			<haxe_doc>* Returns frame at given index.
   * @param data Gif data.
   * @param frameIndex Index of frame.
   * @return Frame at given index or null, if there is no frame at that index.</haxe_doc>
		</frame>
		<graphicControl public="1" set="method" line="59" static="1">
			<f a="data:frameIndex">
				<t path="format.gif.Data"/>
				<x path="Int"/>
				<t path="format.gif.GraphicControlExtension"/>
			</f>
			<haxe_doc>* Returns Graphic Control extension for frame at given index.
   * @param data Gif data.
   * @param frameIndex Index of frame.
   * @return GCE extension if it is exists for given frame, null otherwise.</haxe_doc>
		</graphicControl>
		<extractBGRA public="1" set="method" line="90" static="1">
			<f a="data:frameIndex">
				<t path="format.gif.Data"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Extracts frame pixel data in Blue-Green-Red-Alpha pixel format.
   * This function extracts only exact frame and does put previous frame pixel data into resulting Bytes. Note that frame size may not equal to Gif logical screen size.
   * @param data Gif data.
   * @param frameIndex Frame index.
   * @return BGRA pixel data with dimensions equals to specified Frame size. If frame does not present in Gif data returns null.</haxe_doc>
		</extractBGRA>
		<extractRGBA public="1" set="method" line="141" static="1">
			<f a="data:frameIndex">
				<t path="format.gif.Data"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Extracts frame pixel data in Red-Green-Blue-Alpha pixel format.
   * This function extracts only exact frame and does put previous frame pixel data into resulting Bytes. Note that frame size may not equal to Gif logical screen size.
   * @param data Gif data.
   * @param frameIndex Frame index.
   * @return RGBA pixel data with dimensions equals to specified Frame size. If frame does not present in Gif data returns null.</haxe_doc>
		</extractRGBA>
		<extractFullBGRA public="1" set="method" line="192" static="1">
			<f a="data:frameIndex">
				<t path="format.gif.Data"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Extracts full Gif pixel data to specified frame in Blue-Green-Red-Alpha pixel format.
   * This functions returns full representation of frame including rendering of all other frames before.
   * @param data Gif data.
   * @param frameIndex Frame index.
   * @return BGRA pixel data with dimensions equals to Gif logical screen with full pixel data of Gif image at specified frame.</haxe_doc>
		</extractFullBGRA>
		<extractFullRGBA public="1" set="method" line="278" static="1">
			<f a="data:frameIndex">
				<t path="format.gif.Data"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>* Extracts full Gif pixel data to specified frame in Red-Green-Blue-Alpha pixel format.
   * This functions returns full representation of frame including rendering of all other frames before.
   * @param data Gif data.
   * @param frameIndex Frame index.
   * @return RGBA pixel data with dimensions equals to Gif logical screen with full pixel data of Gif image at specified frame.</haxe_doc>
		</extractFullRGBA>
		<loopCount public="1" set="method" line="363" static="1">
			<f a="data">
				<t path="format.gif.Data"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns amount of animation repeats stored in Gif data.
   * This is link to Netscape Looping application extension. If this extension does not present amount of loops equals to 1.
   * @param data Gif data.
   * @return Amount of animation repeats. Zero equals to infinite amount of repeats.</haxe_doc>
		</loopCount>
		<LN2 expr="Math.log(2)" line="385" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>Math.log(2)</e></m></meta>
		</LN2>
		<log2 public="1" get="inline" set="null" line="386" static="1">
			<f a="val">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</log2>
		<haxe_doc>* Tools for gif data.
 * @author Yanrishatum</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="format.mp3.SamplingRate" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data">
		<SR_8000/>
		<SR_11025/>
		<SR_12000/>
		<SR_22050/>
		<SR_24000/>
		<SR_32000/>
		<SR_44100/>
		<SR_48000/>
		<SR_Bad/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="format.mp3.Bitrate" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data">
		<BR_8/>
		<BR_16/>
		<BR_24/>
		<BR_32/>
		<BR_40/>
		<BR_48/>
		<BR_56/>
		<BR_64/>
		<BR_80/>
		<BR_96/>
		<BR_112/>
		<BR_128/>
		<BR_144/>
		<BR_160/>
		<BR_176/>
		<BR_192/>
		<BR_224/>
		<BR_256/>
		<BR_288/>
		<BR_320/>
		<BR_352/>
		<BR_384/>
		<BR_416/>
		<BR_448/>
		<BR_Free/>
		<BR_Bad/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="format.mp3.MPEG" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Constants.hx" module="format.mp3.Constants">
		<V1 public="1" get="inline" set="null" expr="3" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</V1>
		<V2 public="1" get="inline" set="null" expr="2" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</V2>
		<V25 public="1" get="inline" set="null" expr="0" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</V25>
		<Reserved public="1" expr="1" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</Reserved>
		<enum2Num public="1" set="method" line="16" static="1"><f a="m">
	<e path="format.mp3.MPEGVersion"/>
	<x path="Int"/>
</f></enum2Num>
		<num2Enum public="1" set="method" line="25" static="1"><f a="m">
	<x path="Int"/>
	<e path="format.mp3.MPEGVersion"/>
</f></num2Enum>
		<V1_Bitrates public="1" expr="[[BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad], [BR_Free, BR_32, BR_40, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_160, BR_192, BR_224, BR_256, BR_320, BR_Bad], [BR_Free, BR_32, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_160, BR_192, BR_224, BR_256, BR_320, BR_384, BR_Bad], [BR_Free, BR_32, BR_64, BR_96, BR_128, BR_160, BR_192, BR_224, BR_256, BR_288, BR_320, BR_352, BR_384, BR_416, BR_448, BR_Bad]]" line="35" static="1">
			<c path="Array"><c path="Array"><e path="format.mp3.Bitrate"/></c></c>
			<meta><m n=":value"><e>[[BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad], [BR_Free, BR_32, BR_40, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_160, BR_192, BR_224, BR_256, BR_320, BR_Bad], [BR_Free, BR_32, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_160, BR_192, BR_224, BR_256, BR_320, BR_384, BR_Bad], [BR_Free, BR_32, BR_64, BR_96, BR_128, BR_160, BR_192, BR_224, BR_256, BR_288, BR_320, BR_352, BR_384, BR_416, BR_448, BR_Bad]]</e></m></meta>
		</V1_Bitrates>
		<V2_Bitrates public="1" expr="[[BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad], [BR_Free, BR_8, BR_16, BR_24, BR_32, BR_40, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_144, BR_160, BR_Bad], [BR_Free, BR_8, BR_16, BR_24, BR_32, BR_40, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_144, BR_160, BR_Bad], [BR_Free, BR_32, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_144, BR_160, BR_176, BR_192, BR_224, BR_256, BR_Bad]]" line="43" static="1">
			<c path="Array"><c path="Array"><e path="format.mp3.Bitrate"/></c></c>
			<meta><m n=":value"><e>[[BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad, BR_Bad], [BR_Free, BR_8, BR_16, BR_24, BR_32, BR_40, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_144, BR_160, BR_Bad], [BR_Free, BR_8, BR_16, BR_24, BR_32, BR_40, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_144, BR_160, BR_Bad], [BR_Free, BR_32, BR_48, BR_56, BR_64, BR_80, BR_96, BR_112, BR_128, BR_144, BR_160, BR_176, BR_192, BR_224, BR_256, BR_Bad]]</e></m></meta>
		</V2_Bitrates>
		<SamplingRates public="1" expr="[[SR_11025, SR_12000, SR_8000, SR_Bad], [SR_Bad, SR_Bad, SR_Bad, SR_Bad], [SR_22050, SR_24000, SR_12000, SR_Bad], [SR_44100, SR_48000, SR_32000, SR_Bad]]" line="51" static="1">
			<c path="Array"><c path="Array"><e path="format.mp3.SamplingRate"/></c></c>
			<meta><m n=":value"><e>[[SR_11025, SR_12000, SR_8000, SR_Bad], [SR_Bad, SR_Bad, SR_Bad, SR_Bad], [SR_22050, SR_24000, SR_12000, SR_Bad], [SR_44100, SR_48000, SR_32000, SR_Bad]]</e></m></meta>
		</SamplingRates>
		<srNum2Enum public="1" set="method" line="58" static="1"><f a="sr">
	<x path="Int"/>
	<e path="format.mp3.SamplingRate"/>
</f></srNum2Enum>
		<srEnum2Num public="1" set="method" line="72" static="1"><f a="sr">
	<e path="format.mp3.SamplingRate"/>
	<x path="Int"/>
</f></srEnum2Num>
		<getBitrateIdx public="1" set="method" line="87" static="1"><f a="br:mpeg:layer">
	<e path="format.mp3.Bitrate"/>
	<e path="format.mp3.MPEGVersion"/>
	<e path="format.mp3.Layer"/>
	<x path="Int"/>
</f></getBitrateIdx>
		<getSamplingRateIdx public="1" set="method" line="96" static="1"><f a="sr:mpeg">
	<e path="format.mp3.SamplingRate"/>
	<e path="format.mp3.MPEGVersion"/>
	<x path="Int"/>
</f></getSamplingRateIdx>
		<bitrateEnum2Num public="1" set="method" line="105" static="1"><f a="br">
	<e path="format.mp3.Bitrate"/>
	<x path="Int"/>
</f></bitrateEnum2Num>
		<bitrateNum2Enum public="1" set="method" line="136" static="1"><f a="br">
	<x path="Int"/>
	<e path="format.mp3.Bitrate"/>
</f></bitrateNum2Enum>
		<haxe_doc>* MPEG Version
 *
 * sored on 2 bits in the file,
 * values represent bit values</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.mp3.CLayer" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Constants.hx" module="format.mp3.Constants">
		<LReserved public="1" expr="0" line="177" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</LReserved>
		<LLayer3 public="1" expr="1" line="178" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</LLayer3>
		<LLayer2 public="1" expr="2" line="179" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</LLayer2>
		<LLayer1 public="1" expr="3" line="180" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</LLayer1>
		<enum2Num public="1" set="method" line="182" static="1"><f a="l">
	<e path="format.mp3.Layer"/>
	<x path="Int"/>
</f></enum2Num>
		<num2Enum public="1" set="method" line="191" static="1"><f a="l">
	<x path="Int"/>
	<e path="format.mp3.Layer"/>
</f></num2Enum>
		<haxe_doc>* Layer
 *
 * stored on 2 bits in the file,
 * values represent bit values</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.mp3.CChannelMode" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Constants.hx" module="format.mp3.Constants">
		<CStereo public="1" get="inline" set="null" expr="0" line="209" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</CStereo>
		<CJointStereo public="1" get="inline" set="null" expr="1" line="210" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</CJointStereo>
		<CDualChannel public="1" get="inline" set="null" expr="2" line="211" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</CDualChannel>
		<CMono public="1" get="inline" set="null" expr="3" line="212" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</CMono>
		<enum2Num public="1" set="method" line="214" static="1"><f a="c">
	<e path="format.mp3.ChannelMode"/>
	<x path="Int"/>
</f></enum2Num>
		<num2Enum public="1" set="method" line="223" static="1"><f a="c">
	<x path="Int"/>
	<e path="format.mp3.ChannelMode"/>
</f></num2Enum>
		<haxe_doc>* Sound channel mode
 *
 * stored on 2 bits in the file,
 * values represent bit values</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.mp3.CEmphasis" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Constants.hx" module="format.mp3.Constants">
		<ENone public="1" get="inline" set="null" expr="0" line="240" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ENone>
		<EMs50_15 public="1" get="inline" set="null" expr="1" line="241" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</EMs50_15>
		<EReserved public="1" get="inline" set="null" expr="2" line="242" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</EReserved>
		<ECCIT_J17 public="1" get="inline" set="null" expr="3" line="243" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</ECCIT_J17>
		<enum2Num public="1" set="method" line="245" static="1"><f a="c">
	<e path="format.mp3.Emphasis"/>
	<x path="Int"/>
</f></enum2Num>
		<num2Enum public="1" set="method" line="254" static="1"><f a="c">
	<x path="Int"/>
	<e path="format.mp3.Emphasis"/>
</f></num2Enum>
		<haxe_doc>* Emphasis
 *
 * 2 bits</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="format.mp3.MP3" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data"><a>
	<sampleSize><x path="Int"/></sampleSize>
	<sampleCount><x path="Int"/></sampleCount>
	<id3v2><t path="format.mp3.ID3v2Info"/></id3v2>
	<frames><c path="Array"><t path="format.mp3.MP3Frame"/></c></frames>
</a></typedef>
	<typedef path="format.mp3.ID3v2Info" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data"><a>
	<versionBytes><x path="Int"/></versionBytes>
	<flagByte><x path="Int"/></flagByte>
	<data><c path="haxe.io.Bytes"/></data>
</a></typedef>
	<typedef path="format.mp3.MP3Frame" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data"><a>
	<header><t path="format.mp3.MP3Header"/></header>
	<data><c path="haxe.io.Bytes"/></data>
</a></typedef>
	<typedef path="format.mp3.MP3Header" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data"><a>
	<version><e path="format.mp3.MPEGVersion"/></version>
	<samplingRate><e path="format.mp3.SamplingRate"/></samplingRate>
	<privateBit><x path="Bool"/></privateBit>
	<layer><e path="format.mp3.Layer"/></layer>
	<isPadded><x path="Bool"/></isPadded>
	<isOriginal><x path="Bool"/></isOriginal>
	<isMSStereo><x path="Bool"/></isMSStereo>
	<isIntensityStereo><x path="Bool"/></isIntensityStereo>
	<isCopyrighted><x path="Bool"/></isCopyrighted>
	<hasCrc><x path="Bool"/></hasCrc>
	<emphasis><e path="format.mp3.Emphasis"/></emphasis>
	<crc16><x path="Int"/></crc16>
	<channelMode><e path="format.mp3.ChannelMode"/></channelMode>
	<bitrate><e path="format.mp3.Bitrate"/></bitrate>
</a></typedef>
	<enum path="format.mp3.MPEGVersion" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data">
		<MPEG_V1/>
		<MPEG_V2/>
		<MPEG_V25/>
		<MPEG_Reserved/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="format.mp3.Layer" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data">
		<LayerReserved/>
		<Layer3/>
		<Layer2/>
		<Layer1/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="format.mp3.ChannelMode" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data">
		<Stereo/>
		<JointStereo/>
		<DualChannel/>
		<Mono/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="format.mp3.Emphasis" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Data.hx" module="format.mp3.Data">
		<NoEmphasis/>
		<Ms50_15/>
		<CCIT_J17/>
		<InvalidEmphasis/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="format.mp3.FrameType" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Reader.hx" module="format.mp3.Reader">
		<FT_MP3/>
		<FT_NONE/>
		<haxe_doc>* Used by seekFrame to retrun the type
 * of frame (possibly) found.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="format.mp3.Reader" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<bits><c path="format.tools.BitsInput"/></bits>
		<version><x path="Int"/></version>
		<samples><x path="Int"/></samples>
		<sampleSize><x path="Int"/></sampleSize>
		<any_read><x path="Bool"/></any_read>
		<id3v2_data><c path="haxe.io.Bytes"/></id3v2_data>
		<id3v2_version><x path="Int"/></id3v2_version>
		<id3v2_flags><x path="Int"/></id3v2_flags>
		<skipID3v2 public="1" set="method" line="78">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called after found 'ID3' signature
    * at the beginning of the file.
    *
    * Records the raw tag data.</haxe_doc>
		</skipID3v2>
		<seekFrame public="1" set="method" line="101">
			<f a=""><e path="format.mp3.FrameType"/></f>
			<haxe_doc>* Winds the input stream until the 11-bit
    * syncword is found.
    *
    * @returns Bool false if not found (this should happen at eof).</haxe_doc>
		</seekFrame>
		<readFrames public="1" set="method" line="150">
			<f a=""><c path="Array"><t path="format.mp3.MP3Frame"/></c></f>
			<haxe_doc>* Returns all valid frames. Invalid frames
    * are discarded.</haxe_doc>
		</readFrames>
		<readFrameHeader public="1" set="method" line="170">
			<f a=""><t path="format.mp3.MP3Header"/></f>
			<haxe_doc>* Returns null if header proves to be invalid.</haxe_doc>
		</readFrameHeader>
		<readFrame public="1" set="method" line="250">
			<f a=""><t path="format.mp3.MP3Frame"/></f>
			<haxe_doc>* Reads a frame from the input.
    *
    * The input position should already be just past the
    * 11 bit syncword.
    *
    * Returns null if the header is invalid or the frame was incomplete.</haxe_doc>
		</readFrame>
		<read public="1" set="method" line="280">
			<f a=""><t path="format.mp3.MP3"/></f>
			<haxe_doc>* Reads the MP3 data.
    *
    * Currently returns all valid frames.</haxe_doc>
		</read>
		<new public="1" set="method" line="62"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.mp3.Tools" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/mp3/Tools.hx">
		<getBitrate public="1" set="method" line="40" static="1">
			<f a="mpegVersion:layerIdx:bitrateIdx">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<e path="format.mp3.Bitrate"/>
			</f>
			<haxe_doc>* Returns kbps</haxe_doc>
		</getBitrate>
		<getSamplingRate public="1" set="method" line="50" static="1">
			<f a="mpegVersion:samplingRateIdx">
				<x path="Int"/>
				<x path="Int"/>
				<e path="format.mp3.SamplingRate"/>
			</f>
			<haxe_doc>* Returns Hz</haxe_doc>
		</getSamplingRate>
		<isInvalidFrameHeader public="1" set="method" line="57" static="1">
			<f a="hdr">
				<t path="format.mp3.MP3Header"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Tells whether the header is invalid.</haxe_doc>
		</isInvalidFrameHeader>
		<getSampleDataSize public="1" set="method" line="74" static="1">
			<f a="mpegVersion:bitrate:samplingRate:isPadded:hasCrc">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Return sample data size. Note that
    * the 4 bytes subtracted is the size of the header,
    * so this 4 bytes less the frame size.
    *
    * Also, 2 bytes are subtracted for CRC too, if present</haxe_doc>
		</getSampleDataSize>
		<getSampleDataSizeHdr public="1" set="method" line="78" static="1"><f a="hdr">
	<t path="format.mp3.MP3Header"/>
	<x path="Int"/>
</f></getSampleDataSizeHdr>
		<getSampleCount public="1" set="method" line="89" static="1">
			<f a="mpegVersion">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the number of samples in the frame.</haxe_doc>
		</getSampleCount>
		<getSampleCountHdr public="1" set="method" line="94" static="1"><f a="hdr">
	<t path="format.mp3.MP3Header"/>
	<x path="Int"/>
</f></getSampleCountHdr>
		<getFrameInfo public="1" set="method" line="102" static="1">
			<f a="fr">
				<t path="format.mp3.MP3Frame"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Displays frame info in human-readable format.
    * Subject to change, do not use for programmatical parsing!</haxe_doc>
		</getFrameInfo>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="format.png.Color" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/png/Data.hx" module="format.png.Data">
		<ColGrey a="alpha"><x path="Bool"/></ColGrey>
		<ColTrue a="alpha"><x path="Bool"/></ColTrue>
		<ColIndexed/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="format.png.Header" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/png/Data.hx" module="format.png.Data"><a>
	<width><x path="Int"/></width>
	<interlaced><x path="Bool"/></interlaced>
	<height><x path="Int"/></height>
	<color><e path="format.png.Color"/></color>
	<colbits><x path="Int"/></colbits>
</a></typedef>
	<enum path="format.png.Chunk" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/png/Data.hx" module="format.png.Data">
		<CEnd/>
		<CHeader a="h"><t path="format.png.Header"/></CHeader>
		<CData a="b"><c path="haxe.io.Bytes"/></CData>
		<CPalette a="b"><c path="haxe.io.Bytes"/></CPalette>
		<CUnknown a="id:data">
			<c path="String"/>
			<c path="haxe.io.Bytes"/>
		</CUnknown>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="format.png.Data" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/png/Data.hx"><t path="List"><e path="format.png.Chunk"/></t></typedef>
	<class path="format.png.Reader" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/png/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<checkCRC public="1"><x path="Bool"/></checkCRC>
		<read public="1" set="method" line="41"><f a=""><t path="format.png.Data"/></f></read>
		<readHeader set="method" line="56"><f a="i">
	<c path="haxe.io.Input"/>
	<t path="format.png.Header"/>
</f></readHeader>
		<readChunk set="method" line="91"><f a=""><e path="format.png.Chunk"/></f></readChunk>
		<new public="1" set="method" line="35"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.png.Tools" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/png/Tools.hx">
		<getHeader public="1" set="method" line="35" static="1">
			<f a="d">
				<t path="format.png.Data"/>
				<t path="format.png.Header"/>
			</f>
			<haxe_doc>Returns the PNG header informations. Throws an exception if no header found.</haxe_doc>
		</getHeader>
		<getPalette public="1" set="method" line="47" static="1">
			<f a="d">
				<t path="format.png.Data"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Return the PNG palette colors, or null if no palette chunk was found</haxe_doc>
		</getPalette>
		<filter get="inline" set="null" line="56" static="1">
			<f a="data:x:y:stride:prev:p:?numChannels" v="::::::4">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ numChannels : 4 }</e></m></meta>
		</filter>
		<reverseBytes public="1" set="method" line="69" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Converts from BGRA to ARGB and the other way by reversing bytes.</haxe_doc>
		</reverseBytes>
		<extractGrey public="1" set="method" line="106" static="1">
			<f a="d">
				<t path="format.png.Data"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":noDebug"/></meta>
			<haxe_doc>Decode the greyscale PNG data and apply filters, extracting only the grey channel if alpha is present.</haxe_doc>
		</extractGrey>
		<extract32 public="1" set="method" line="205" static="1">
			<f a="d:?bytes:?flipY">
				<t path="format.png.Data"/>
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":noDebug"/></meta>
			<haxe_doc>Decode the PNG data and apply filters. By default this will output BGRA low-endian format. You can use the [reverseBytes] function to inverse the bytes to ARGB big-endian format.</haxe_doc>
		</extract32>
		<buildGrey public="1" set="method" line="652" static="1">
			<f a="width:height:data:?level" v=":::9">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<t path="format.png.Data"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
			<haxe_doc>Creates PNG data from bytes that contains one bytes (grey values) for each pixel.</haxe_doc>
		</buildGrey>
		<buildRGB public="1" set="method" line="671" static="1">
			<f a="width:height:data:?level" v=":::9">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<t path="format.png.Data"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
			<haxe_doc>Creates PNG data from bytes that contains three bytes (R,G and B values) for each pixel.</haxe_doc>
		</buildRGB>
		<build32ARGB public="1" set="method" line="694" static="1">
			<f a="width:height:data:?level" v=":::9">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<t path="format.png.Data"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
			<haxe_doc>Creates PNG data from bytes that contains four bytes in ARGB format for each pixel.</haxe_doc>
		</build32ARGB>
		<build32BGRA public="1" set="method" line="718" static="1">
			<f a="width:height:data:?level" v=":::9">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<t path="format.png.Data"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
			<haxe_doc>Creates PNG data from bytes that contains four bytes in BGRA format for each pixel.</haxe_doc>
		</build32BGRA>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.png.Writer" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/png/Writer.hx">
		<o><c path="haxe.io.Output"/></o>
		<write public="1" set="method" line="39"><f a="png">
	<t path="format.png.Data"/>
	<x path="Void"/>
</f></write>
		<writeChunk set="method" line="75"><f a="id:data">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></writeChunk>
		<new public="1" set="method" line="34"><f a="o">
	<c path="haxe.io.Output"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="format.tga.Header" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/tga/Data.hx" module="format.tga.Data"><a>
	<yOrigin>
		<x path="Int"/>
		<haxe_doc>* These bytes specify the absolute vertical coordinate for the lower left
   * corner of the image as it is positioned on a display device having an
   * origin at the lower left of the screen (e.g., the TARGA series).</haxe_doc>
	</yOrigin>
	<xOrigin>
		<x path="Int"/>
		<haxe_doc>* These bytes specify the absolute horizontal coordinate for the lower left
   * corner of the image as it is positioned on a display device having an
   * origin at the lower left of the screen (e.g., the TARGA series).</haxe_doc>
	</xOrigin>
	<width>
		<x path="Int"/>
		<haxe_doc>This field specifies the width of the image in pixels.</haxe_doc>
	</width>
	<imageType>
		<e path="format.tga.ImageType"/>
		<haxe_doc>Image data type.</haxe_doc>
	</imageType>
	<imageOrigin><e path="format.tga.ImageOrigin"/></imageOrigin>
	<height>
		<x path="Int"/>
		<haxe_doc>This field specifies the height of the image in pixels.</haxe_doc>
	</height>
	<colorMapType>
		<x path="Int"/>
		<haxe_doc>* Indicated type of color map.
   * 0 = no color map present.
   * 1 = color map included.
   * 2-127 is reserved by Truevision
   * 128-255 may be used by app developers.</haxe_doc>
	</colorMapType>
	<colorMapLength>
		<x path="Int"/>
		<haxe_doc>Total number of color map entries included.</haxe_doc>
	</colorMapLength>
	<colorMapFirstIndex>
		<x path="Int"/>
		<haxe_doc>* Index of the first color map entry. Index refers to the starting entry in
   * loading the color map.</haxe_doc>
	</colorMapFirstIndex>
	<colorMapEntrySize>
		<x path="Int"/>
		<haxe_doc>* Establishes the number of bits per entry. Typically 15, 16, 24 or 32-bit
   * values are used.</haxe_doc>
	</colorMapEntrySize>
	<bitsPerPixel>
		<x path="Int"/>
		<haxe_doc>* This field indicates the number of bits per pixel. This number includes
   * the Attribute or Alpha channel bits. Common values are 8, 16, 24 and
   * 32 but other pixel depths could be used.</haxe_doc>
	</bitsPerPixel>
	<alphaChannelBits>
		<x path="Int"/>
		<haxe_doc>* the number of attribute bits per
   * pixel. In the case of the TrueVista, these bits
   * indicate the number of bits per pixel which are
   * designated as Alpha Channel bits. For the ICB
   * and TARGA products, these bits indicate the
   * number of overlay bits available per pixel.</haxe_doc>
	</alphaChannelBits>
</a></typedef>
	<enum path="format.tga.ImageOrigin" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/tga/Data.hx" module="format.tga.Data">
		<BottomLeft/>
		<BottomRight/>
		<TopLeft/>
		<TopRight/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="format.tga.ImageType" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/tga/Data.hx" module="format.tga.Data">
		<NoImage><haxe_doc>There is no image data present</haxe_doc></NoImage>
		<UncompressedColorMapped><haxe_doc>Uncompressed image with color-map usage</haxe_doc></UncompressedColorMapped>
		<UncompressedTrueColor><haxe_doc>True-color uncompressed image</haxe_doc></UncompressedTrueColor>
		<UncompressedBlackAndWhite><haxe_doc>Black-and-White uncompresed image</haxe_doc></UncompressedBlackAndWhite>
		<RunLengthColorMapped><haxe_doc>Run-length encoded image with color-map usage</haxe_doc></RunLengthColorMapped>
		<RunLengthTrueColor><haxe_doc>Run-length encoded true-color image</haxe_doc></RunLengthTrueColor>
		<RunLengthBlackAndWhite><haxe_doc>Run-length encoded black-and-white image</haxe_doc></RunLengthBlackAndWhite>
		<Unknown a="type">
			<x path="Int"/>
			<haxe_doc>Unknown type</haxe_doc>
		</Unknown>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="format.tga.Data" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/tga/Data.hx"><a>
	<imageId><c path="String"/></imageId>
	<imageData><x path="haxe.ds.Vector"><x path="Int"/></x></imageData>
	<header><t path="format.tga.Header"/></header>
	<developerData><d/></developerData>
	<colorMapData><x path="haxe.ds.Vector"><x path="Int"/></x></colorMapData>
</a></typedef>
	<class path="format.tga.Reader" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/tga/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<read public="1" set="method" line="21"><f a=""><t path="format.tga.Data"/></f></read>
		<readHeader set="method" line="37"><f a=""><t path="format.tga.Header"/></f></readHeader>
		<readColorMapData set="method" line="103"><f a="header">
	<t path="format.tga.Header"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
</f></readColorMapData>
		<readImageData set="method" line="109"><f a="header:colorMap">
	<t path="format.tga.Header"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
</f></readImageData>
		<readPixels set="method" line="136"><f a="bitsPerPixel:amount:alphaChannelBits:rle">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
</f></readPixels>
		<readMono set="method" line="206"><f a="bitsPerPixel:amount:alphaChannelBits:rle">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
</f></readMono>
		<readIndexes set="method" line="266"><f a="bitsPerPixel:amount:colorMap:offset:rle">
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
</f></readIndexes>
		<parsePixel1 set="method" line="324"><f a="value:alpha">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></parsePixel1>
		<parsePixelGreyAlpha set="method" line="329"><f a="value:alpha">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></parsePixelGreyAlpha>
		<parsePixel2 set="method" line="334"><f a="value:alpha">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></parsePixel2>
		<parsePixel3 set="method" line="342"><f a="value:alpha">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></parsePixel3>
		<parsePixel4 set="method" line="347"><f a="value:alpha">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></parsePixel4>
		<new public="1" set="method" line="15"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Yanrishatum</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.tools.BitsInput" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/tools/BitsInput.hx">
		<i><c path="haxe.io.Input"/></i>
		<nbits><x path="Int"/></nbits>
		<bits><x path="Int"/></bits>
		<readBits public="1" set="method" line="41"><f a="n">
	<x path="Int"/>
	<x path="Int"/>
</f></readBits>
		<readBit public="1" set="method" line="63"><f a=""><x path="Bool"/></f></readBit>
		<reset public="1" get="inline" set="null" line="72"><f a=""><x path="Void"/></f></reset>
		<new public="1" set="method" line="35"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.tools.Deflate" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/tools/Deflate.hx">
		<run public="1" set="method" line="31" static="1">
			<f a="b:?level" v=":9">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
		</run>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="format.tools.Inflate" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/tools/Inflate.hx">
		<run public="1" set="method" line="31" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="format.wav.WAVE" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/wav/Data.hx" module="format.wav.Data"><a>
	<header><t path="format.wav.WAVEHeader"/></header>
	<data><c path="haxe.io.Bytes"/></data>
</a></typedef>
	<typedef path="format.wav.WAVEHeader" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/wav/Data.hx" module="format.wav.Data"><a>
	<samplingRate><x path="Int"/></samplingRate>
	<format><e path="format.wav.WAVEFormat"/></format>
	<channels><x path="Int"/></channels>
	<byteRate><x path="Int"/></byteRate>
	<blockAlign><x path="Int"/></blockAlign>
	<bitsPerSample><x path="Int"/></bitsPerSample>
</a></typedef>
	<enum path="format.wav.WAVEFormat" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/wav/Data.hx" module="format.wav.Data">
		<WF_PCM/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="format.wav.Reader" params="" file="E:\HaxeToolkit\lib_haxe4\format/git/format/wav/Reader.hx">
		<i><c path="haxe.io.Input"/></i>
		<version><x path="Int"/></version>
		<readInt get="inline" set="null" line="43"><f a=""><x path="Int"/></f></readInt>
		<read public="1" set="method" line="51"><f a=""><t path="format.wav.WAVE"/></f></read>
		<new public="1" set="method" line="38"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.AnimationFrame" params="" file="./h2d/Animation.hx" module="h2d.Animation">
		<tile public="1">
			<x path="Null"><c path="h2d.Tile"/></x>
			<haxe_doc>An `h2d.Tile` this frame should display. Can be null to show nothing.</haxe_doc>
		</tile>
		<duration public="1">
			<x path="Float"/>
			<haxe_doc>Frame display duration in seconds.</haxe_doc>
		</duration>
		<isKey public="1">
			<x path="Bool"/>
			<haxe_doc>Is this frame a keyframe? (default: true)
		Keyframes are not skipped when Animation accumulated more than one frame between updates.</haxe_doc>
		</isKey>
		<color public="1">
			<x path="Null"><c path="h3d.Vector"/></x>
			<haxe_doc>Override color multiplier for this frame.</haxe_doc>
		</color>
		<alpha public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>Alpha value for this frame. Shortcut to `color.a`, and will create it as [1, 1, 1, alpha] if it's null.</haxe_doc>
		</alpha>
		<eventEnter public="1">
			<c path="String"/>
			<haxe_doc>Specifies event, triggered when this frame is activated.</haxe_doc>
		</eventEnter>
		<eventExit public="1">
			<c path="String"/>
			<haxe_doc>Specifies event, triggered when this frame is deactivated.
		If animation is paused during exit trigger, this frame will remain active.</haxe_doc>
		</eventExit>
		<get_alpha get="inline" set="null" line="55"><f a=""><x path="Float"/></f></get_alpha>
		<set_alpha get="inline" set="null" line="59"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<new public="1" set="method" line="49">
			<f a="tile:duration:?isKey" v="::true">
				<x path="Null"><c path="h2d.Tile"/></x>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ isKey : true }</e></m></meta>
			<haxe_doc>Create a new Animation Frame with specified tile (or null), duration and keyframe flag.</haxe_doc>
		</new>
		<haxe_doc>Single Animation Frame. Can be reused multiple times in Animation.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.Object" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Object.hx">
		<nullDrawable static="1"><c path="h2d.Drawable"/></nullDrawable>
		<children><c path="Array"><c path="h2d.Object"/></c></children>
		<parentContainer><c path="h2d.Object"/></parentContainer>
		<parent public="1" set="null">
			<c path="h2d.Object"/>
			<haxe_doc>The parent object in the scene tree.</haxe_doc>
		</parent>
		<numChildren public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>How many immediate children this object has.</haxe_doc>
		</numChildren>
		<name public="1">
			<c path="String"/>
			<haxe_doc>The name of the object, can be used to retrieve an object within a tree by using `getObjectByName` (default null)</haxe_doc>
		</name>
		<x public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The x position (in pixels) of the object relative to its parent.</haxe_doc>
		</x>
		<y public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The y position (in pixels) of the object relative to its parent.</haxe_doc>
		</y>
		<scaleX public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The amount of horizontal scaling of this object (default 1.0)</haxe_doc>
		</scaleX>
		<scaleY public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The amount of vertical scaling of this object (default 1.0)</haxe_doc>
		</scaleY>
		<rotation public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>The rotation angle of this object, in radians.</haxe_doc>
		</rotation>
		<visible public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Is the object and its children are displayed on screen (default true).</haxe_doc>
		</visible>
		<alpha public="1" expr="1.">
			<x path="Float"/>
			<meta><m n=":value"><e>1.</e></m></meta>
			<haxe_doc>The amount of transparency of the Object (default 1.0)</haxe_doc>
		</alpha>
		<filter public="1" set="accessor">
			<c path="h2d.filter.Filter"/>
			<haxe_doc>The post process filter for this object.</haxe_doc>
		</filter>
		<blendMode public="1">
			<e path="h2d.BlendMode"/>
			<haxe_doc>The blendMode of the object (default Alpha).
		If there is no filter active, only apply to the current object (not inherited by children)
		If there is a filter active, tells how the filter is blended with background.</haxe_doc>
		</blendMode>
		<matA><x path="Float"/></matA>
		<matB><x path="Float"/></matB>
		<matC><x path="Float"/></matC>
		<matD><x path="Float"/></matD>
		<absX><x path="Float"/></absX>
		<absY><x path="Float"/></absY>
		<posChanged><x path="Bool"/></posChanged>
		<allocated><x path="Bool"/></allocated>
		<lastFrame><x path="Int"/></lastFrame>
		<getBounds public="1" set="method" line="110">
			<f a="?relativeTo:?out">
				<c path="h2d.Object"/>
				<c path="h2d.col.Bounds"/>
				<c path="h2d.col.Bounds"/>
			</f>
			<haxe_doc>Return the bounds of the object for its whole content, recursively.
		If relativeTo is null, it will return the bounds in the absolute coordinates.
		If not, it will return the bounds relative to the specified object coordinates.
		You can pass an already allocated bounds or getBounds will allocate one for you and return it.</haxe_doc>
		</getBounds>
		<getSize public="1" set="method" line="130">
			<f a="?out">
				<c path="h2d.col.Bounds"/>
				<c path="h2d.col.Bounds"/>
			</f>
			<haxe_doc>Similar to getBounds(parent), but instead of the full content, it will return
		the size based on the alignement of the object. For instance for a text, getBounds will return
		the full glyphs size whereas getSize() will ignore the pixels under the baseline.</haxe_doc>
		</getSize>
		<find public="1" params="T" set="method" line="146">
			<f a="f">
				<f a="">
					<c path="h2d.Object"/>
					<x path="Null"><c path="find.T"/></x>
				</f>
				<x path="Null"><c path="find.T"/></x>
			</f>
			<haxe_doc>Find a single object in the tree by calling `f` on each and returning the first not-null value returned, or null if not found.</haxe_doc>
		</find>
		<findAll public="1" params="T" set="method" line="160">
			<f a="f:?arr">
				<f a="">
					<c path="h2d.Object"/>
					<x path="Null"><c path="findAll.T"/></x>
				</f>
				<c path="Array"><c path="findAll.T"/></c>
				<c path="Array"><c path="findAll.T"/></c>
			</f>
			<haxe_doc>Find several objects in the tree by calling `f` on each and returning all the not-null values returned.</haxe_doc>
		</findAll>
		<set_filter set="method" line="170"><f a="f">
	<c path="h2d.filter.Filter"/>
	<c path="h2d.filter.Filter"/>
</f></set_filter>
		<getBoundsRec set="method" line="177"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<addBounds set="method" line="210"><f a="relativeTo:out:dx:dy:width:height">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addBounds>
		<getObjectsCount public="1" set="method" line="265">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Return the total number of children, recursively.</haxe_doc>
		</getObjectsCount>
		<localToGlobal public="1" set="method" line="275">
			<f a="?pt">
				<c path="h2d.col.Point"/>
				<c path="h2d.col.Point"/>
			</f>
			<haxe_doc>Convert a local position (or [0,0] if pt is null) relative to the object origin into an absolute screen position, applying all the inherited transforms.</haxe_doc>
		</localToGlobal>
		<globalToLocal public="1" set="method" line="288">
			<f a="pt">
				<c path="h2d.col.Point"/>
				<c path="h2d.col.Point"/>
			</f>
			<haxe_doc>Convert an absolute screen position into a local position relative to the object origin, applying all the inherited transforms.</haxe_doc>
		</globalToLocal>
		<getScene public="1" set="method" line="300"><f a=""><c path="h2d.Scene"/></f></getScene>
		<set_visible set="method" line="306"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<addChild public="1" set="method" line="317">
			<f a="s">
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Add a child object at the end of the children list.</haxe_doc>
		</addChild>
		<addChildAt public="1" set="method" line="324">
			<f a="s:pos">
				<c path="h2d.Object"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Insert a child object at the specified position of the children list.</haxe_doc>
		</addChildAt>
		<onContentChanged get="inline" set="null" line="355"><f a=""><x path="Void"/></f></onContentChanged>
		<onParentChanged set="method" line="360"><f a=""><x path="Void"/></f></onParentChanged>
		<onAdd set="method" line="366"><f a=""><x path="Void"/></f></onAdd>
		<onRemove set="method" line="375"><f a=""><x path="Void"/></f></onRemove>
		<getMatrix set="method" line="383"><f a="m">
	<c path="h2d.col.Matrix"/>
	<x path="Void"/>
</f></getMatrix>
		<removeChild public="1" set="method" line="395">
			<f a="s">
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Remove the given object from our immediate children list if it's part of it.</haxe_doc>
		</removeChild>
		<setParentContainer set="method" line="405"><f a="c">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></setParentContainer>
		<removeChildren public="1" set="method" line="414">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Remove all children from our immediate children list</haxe_doc>
		</removeChildren>
		<remove public="1" get="inline" set="null" line="423">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Same as parent.removeChild(this), but does nothing if parent is null.
		In order to capture add/removal from scene, you can override onAdd/onRemove/onParentChanged</haxe_doc>
		</remove>
		<drawTo public="1" set="method" line="430">
			<f a="t">
				<c path="h3d.mat.Texture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Draw the object and all its children into the given Texture</haxe_doc>
		</drawTo>
		<draw set="method" line="438"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<sync set="method" line="441"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<syncPos set="method" line="468"><f a=""><x path="Void"/></f></syncPos>
		<calcAbsPos set="method" line="478"><f a=""><x path="Void"/></f></calcAbsPos>
		<emitTile set="method" line="522"><f a="ctx:tile">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></emitTile>
		<clipBounds set="method" line="595">
			<f a="ctx:bounds">
				<c path="h2d.RenderContext"/>
				<c path="h2d.col.Bounds"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Clip a local bounds with our global viewport</haxe_doc>
		</clipBounds>
		<drawFilters set="method" line="657"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></drawFilters>
		<drawFiltered set="method" line="740"><f a="ctx:tile">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></drawFiltered>
		<drawRec set="method" line="754"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></drawRec>
		<set_x get="inline" set="null" line="782"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y get="inline" set="null" line="787"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_scaleX get="inline" set="null" line="792"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
		<set_scaleY get="inline" set="null" line="797"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
		<set_rotation get="inline" set="null" line="802"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
		<move public="1" set="method" line="810">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Move the object by the specied amount along its current direction (rotation angle).</haxe_doc>
		</move>
		<setPosition public="1" get="inline" set="null" line="818">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the position of the object relative to its parent.</haxe_doc>
		</setPosition>
		<rotate public="1" get="inline" set="null" line="826">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Rotate the object by the given angle (in radians)</haxe_doc>
		</rotate>
		<scale public="1" get="inline" set="null" line="833">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scale uniformly the object by the given factor.</haxe_doc>
		</scale>
		<setScale public="1" get="inline" set="null" line="841">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the uniform scale for the object.</haxe_doc>
		</setScale>
		<getChildAt public="1" get="inline" set="null" line="849">
			<f a="n">
				<x path="Int"/>
				<c path="h2d.Object"/>
			</f>
			<haxe_doc>Return the `n`th element among our immediate children list, or null if there is no.</haxe_doc>
		</getChildAt>
		<getChildIndex public="1" set="method" line="856">
			<f a="o">
				<c path="h2d.Object"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Return the index of the object `o` within our immediate children list, or `-1` if it is not part of our children list.</haxe_doc>
		</getChildIndex>
		<getObjectByName public="1" set="method" line="866">
			<f a="name">
				<c path="String"/>
				<c path="h2d.Object"/>
			</f>
			<haxe_doc>Search for an object recursively by name, return null if not found.</haxe_doc>
		</getObjectByName>
		<get_numChildren get="inline" set="null" line="876"><f a=""><x path="Int"/></f></get_numChildren>
		<iterator public="1" get="inline" set="null" line="883">
			<f a=""><c path="hxd.impl.ArrayIterator_h2d_Object"/></f>
			<haxe_doc>Return an iterator over this object immediate children</haxe_doc>
		</iterator>
		<toString set="method" line="887"><f a=""><c path="String"/></f></toString>
		<contentChanged set="method" line="897">
			<f a="s">
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This is called by our children if we have defined their parentContainer when they get resized</haxe_doc>
		</contentChanged>
		<constraintSize set="method" line="904">
			<f a="maxWidth:maxHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This can be called by a parent container to constraint the size of its children.
		Negative value mean that constraint is to be disable.</haxe_doc>
		</constraintSize>
		<new public="1" set="method" line="93">
			<f a="?parent">
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new empty object, and adds it to the parent object if not null.</haxe_doc>
		</new>
		<haxe_doc>h2d.Object is the base 2D class that all scene tree elements inherit from.
	It can be used to create a virtual container that does not display anything but can contain other objects
	so the various transforms are inherited to its children.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h2d.Tools</e></m>
		</meta>
	</class>
	<class path="h2d.Drawable" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Drawable.hx">
		<extends path="h2d.Object"/>
		<color public="1">
			<c path="h3d.Vector"/>
			<haxe_doc>The color multiplier for the object. Can be used to adjust individually each of the four channels R,G,B,A (default [1,1,1,1])</haxe_doc>
		</color>
		<smooth public="1">
			<x path="Null"><x path="Bool"/></x>
			<haxe_doc>By enabling smoothing, scaling the object up or down will use hardware bilinear filtering resulting in less crisp aspect.
		By default smooth is null and then Scene.defaultSmooth value is used.</haxe_doc>
		</smooth>
		<tileWrap public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>By enabling tile wrapping, you can have tiles which size exceed the texture size and will repeat instead of displaying clamped pixels.</haxe_doc>
		</tileWrap>
		<colorKey public="1" set="accessor">
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>Setting a colorKey color value will discard all pixels that have this exact color in the tile.</haxe_doc>
		</colorKey>
		<colorMatrix public="1" get="accessor" set="accessor">
			<x path="Null"><c path="h3d.Matrix"/></x>
			<haxe_doc>Setting a colorMatrix will apply a color transformation. See also `adjustColor`.</haxe_doc>
		</colorMatrix>
		<colorAdd public="1" get="accessor" set="accessor">
			<x path="Null"><c path="h3d.Vector"/></x>
			<haxe_doc>Setting colorAdd will add the amount of color of each channel R,G,B,A to the object pixels.</haxe_doc>
		</colorAdd>
		<shaders><c path="hxsl.ShaderList"/></shaders>
		<set_tileWrap set="method" line="47"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_tileWrap>
		<get_colorAdd set="method" line="51"><f a=""><x path="Null"><c path="h3d.Vector"/></x></f></get_colorAdd>
		<set_colorAdd set="method" line="56"><f a="c">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></set_colorAdd>
		<drawFiltered set="method" line="72" override="1"><f a="ctx:tile">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></drawFiltered>
		<set_colorKey set="method" line="79"><f a="v">
	<x path="Null"><x path="Int"/></x>
	<x path="Null"><x path="Int"/></x>
</f></set_colorKey>
		<adjustColor public="1" set="method" line="96">
			<f a="?col">
				<t path="h3d.ColorAdjust"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the `colorMatrix` value by specifying which effects to apply. Calling adjustColor() reset the colorMatrix to `null`</haxe_doc>
		</adjustColor>
		<get_colorMatrix set="method" line="110"><f a=""><x path="Null"><c path="h3d.Matrix"/></x></f></get_colorMatrix>
		<set_colorMatrix set="method" line="115"><f a="m">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_colorMatrix>
		<getDebugShaderCode public="1" set="method" line="134">
			<f a="?toHxsl" v="true">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ toHxsl : true }</e></m></meta>
			<haxe_doc>Return the built shader code, can be used for debugging shader assembly</haxe_doc>
		</getDebugShaderCode>
		<getShader public="1" params="T" set="method" line="150">
			<f a="stype">
				<x path="Class"><c path="getShader.T"/></x>
				<c path="getShader.T"/>
			</f>
			<haxe_doc>Return the first shader of the given shader class among the object shaders</haxe_doc>
		</getShader>
		<getShaders public="1" get="inline" set="null" line="162">
			<f a=""><c path="hxsl._ShaderList.ShaderIterator"/></f>
			<haxe_doc>Return all object shaders</haxe_doc>
		</getShaders>
		<addShader public="1" params="T" set="method" line="169">
			<f a="s">
				<c path="addShader.T"/>
				<c path="addShader.T"/>
			</f>
			<haxe_doc>Add a shader to the object shaders</haxe_doc>
		</addShader>
		<removeShader public="1" set="method" line="178">
			<f a="s">
				<c path="hxsl.Shader"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Remove a shader from the object shaders, returns true if found or false if it was not part of our shaders.</haxe_doc>
		</removeShader>
		<emitTile set="method" line="194" override="1"><f a="ctx:tile">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></emitTile>
		<new set="method" line="42"><f a="parent">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>h2d.Drawable is the base class for all 2D objects that will draw something on screen.
	Unlike Object base class, all properties of Drawable only apply to the current object and are not inherited by its children.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.Animation" params="" file="./h2d/Animation.hx">
		<extends path="h2d.Drawable"/>
		<fromFixedFramerate public="1" set="method" line="78" static="1">
			<f a="tiles:fps">
				<c path="Array"><c path="h2d.Tile"/></c>
				<x path="Float"/>
				<c path="Array"><c path="h2d.AnimationFrame"/></c>
			</f>
			<haxe_doc>Create an array of frames with fixed framerate. Will produce same playback result as h2d.Anim.</haxe_doc>
		</fromFixedFramerate>
		<fromDurationList public="1" set="method" line="90" static="1">
			<f a="tiles:durations">
				<c path="Array"><c path="h2d.Tile"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><c path="h2d.AnimationFrame"/></c>
			</f>
			<haxe_doc>Create an array from list of tiles and their durations. Both arrays should be the same length.</haxe_doc>
		</fromDurationList>
		<getDuration public="1" set="method" line="102" static="1">
			<f a="frames">
				<c path="Array"><c path="h2d.AnimationFrame"/></c>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns total duration of animation frames.</haxe_doc>
		</getDuration>
		<frames public="1" set="null">
			<c path="Array"><c path="h2d.AnimationFrame"/></c>
			<haxe_doc>The current animation, as a list of AnimationFrame instances to display.</haxe_doc>
		</frames>
		<currentFrame public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>The current frame the animation is currently playing. Always in `[0,frames.length]` range</haxe_doc>
		</currentFrame>
		<pause public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Setting pause will pause the animation, preventing any automatic change to currentFrame.</haxe_doc>
		</pause>
		<loop public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>Disabling loop will stop the animation at the last frame (default : true)</haxe_doc>
		</loop>
		<speed public="1" expr="1.">
			<x path="Float"/>
			<meta><m n=":value"><e>1.</e></m></meta>
			<haxe_doc>Playback speed multiplier for animation (default : 1)</haxe_doc>
		</speed>
		<curFrame><x path="Int"/></curFrame>
		<elapsedTime><x path="Float"/></elapsedTime>
		<playWhenHidden public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Enables playback of animation even when `visible = false`. (default: false)
		Does not check for nested visibility.</haxe_doc>
		</playWhenHidden>
		<width public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>Total width of the animation. Accounts for all frames.</haxe_doc>
		</width>
		<height public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>Total height of the animation. Accounts for all frames.</haxe_doc>
		</height>
		<duration public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>Duration of current animation. Affected by `speed` variable, for duration of frame use static `getDuration` function.</haxe_doc>
		</duration>
		<play public="1" set="method" line="171">
			<f a="frames:?atFrame" v=":0">
				<c path="Array"><c path="h2d.AnimationFrame"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ atFrame : 0 }</e></m></meta>
			<haxe_doc>Change the currently playing animation and unset the pause if it was set.</haxe_doc>
		</play>
		<palyAt public="1" set="method" line="180">
			<f a="?frame" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ frame : 0 }</e></m></meta>
			<haxe_doc>Starts animation playback at specified frame.</haxe_doc>
		</palyAt>
		<onAnimEnd public="1" set="dynamic" line="190">
			<f a=""><x path="Void"/></f>
			<haxe_doc>onAnimEnd is automatically called each time the animation will reach past the last frame.
		If loop is true, it is called everytime the animation loops.
		If loop is false, it is called once when the animation reachs `currentFrame == frames.length`</haxe_doc>
		</onAnimEnd>
		<onEvent public="1" set="dynamic" line="197">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Triggers when frame contains `event` string</haxe_doc>
		</onEvent>
		<getFrame public="1" get="inline" set="null" line="204">
			<f a=""><c path="h2d.AnimationFrame"/></f>
			<haxe_doc>Returns current AnimationFrame being played.</haxe_doc>
		</getFrame>
		<getTile public="1" set="method" line="211">
			<f a=""><c path="h2d.Tile"/></f>
			<haxe_doc>Returns current h2d.Tile being played.</haxe_doc>
		</getTile>
		<get_currentFrame get="inline" set="null" line="216"><f a=""><x path="Int"/></f></get_currentFrame>
		<set_currentFrame set="method" line="220"><f a="frame">
	<x path="Int"/>
	<x path="Int"/>
</f></set_currentFrame>
		<get_width get="inline" set="null" line="227"><f a=""><x path="Int"/></f></get_width>
		<get_height get="inline" set="null" line="233"><f a=""><x path="Int"/></f></get_height>
		<get_duration get="inline" set="null" line="239"><f a=""><x path="Float"/></f></get_duration>
		<getBoundsRec set="method" line="243" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<sync set="method" line="249" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<_onAnimEnd set="method" line="318"><f a=""><x path="Void"/></f></_onAnimEnd>
		<draw set="method" line="323" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="161">
			<f a="?frames:?parent">
				<c path="Array"><c path="h2d.AnimationFrame"/></c>
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new animation with the specified frames and parent object</haxe_doc>
		</new>
		<haxe_doc>h2d.Animation is used to display a parametrized sequence of bitmap tiles on the screen.
	This is more powerful version than h2d.Anim, but requires more setup.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.AnimationExt" params="" file="./h2d/AnimationExt.hx">
		<extends path="h2d.Animation"/>
		<animations public="1" expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<c path="h2d.AnimationDescriptor"/>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
			<haxe_doc>List of named animation between which AnimationExt can switch.</haxe_doc>
		</animations>
		<current><c path="h2d.AnimationDescriptor"/></current>
		<currentAnimation public="1" set="null">
			<c path="String"/>
			<haxe_doc>Current animation name.</haxe_doc>
		</currentAnimation>
		<commands expr="new List()">
			<t path="List"><e path="h2d.AnimationCommand"/></t>
			<meta><m n=":value"><e>new List()</e></m></meta>
		</commands>
		<wait expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</wait>
		<addCommand public="1" set="method" line="29">
			<f a="cmd">
				<e path="h2d.AnimationCommand"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds new command to the end of command buffer.</haxe_doc>
		</addCommand>
		<resetCommands public="1" set="method" line="37">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Clears command buffer.</haxe_doc>
		</resetCommands>
		<playAnim public="1" set="method" line="46">
			<f a="name:?atFrame">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Plays animation with specified name, and optionally at specific frame.</haxe_doc>
		</playAnim>
		<durationOf public="1" set="method" line="63">
			<f a="anim">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns duration of specified animation. Uses either animation descriptor speed, or current Animation speed value.</haxe_doc>
		</durationOf>
		<sync set="method" line="73" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<_onAnimEnd set="method" line="85" override="1"><f a=""><x path="Void"/></f></_onAnimEnd>
		<nextCommand set="method" line="100"><f a=""><x path="Void"/></f></nextCommand>
		<executeCommand set="method" line="109"><f a="cmd">
	<e path="h2d.AnimationCommand"/>
	<x path="Bool"/>
</f></executeCommand>
		<new public="1" set="method" line="9"><f a="?frames:?parent">
	<c path="Array"><c path="h2d.AnimationFrame"/></c>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Extended version of Animation with named animation storage and primitive command buffer.
  Command buffer triggers next command either when delay timeout runs out or animation reaches it's end.</haxe_doc>
	</class>
	<class path="h2d.AnimationDescriptor" params="" file="./h2d/AnimationExt.hx" module="h2d.AnimationExt">
		<frames public="1">
			<c path="Array"><c path="h2d.AnimationFrame"/></c>
			<haxe_doc>List of frames used in animation.</haxe_doc>
		</frames>
		<loop public="1">
			<x path="Bool"/>
			<haxe_doc>Should this animation loop?</haxe_doc>
		</loop>
		<speed public="1">
			<x path="Null"><x path="Float"/></x>
			<haxe_doc>If not null, will set Animation.speed value to this value.
    Note: Does not reset to old value when switches to another animation.</haxe_doc>
		</speed>
		<next public="1">
			<c path="String"/>
			<haxe_doc>If present, will switch to specified animation name when this animation end.
    In that case, it will not trigger next command from buffer.</haxe_doc>
		</next>
		<nextFrame public="1" expr="null">
			<x path="Null"><x path="Int"/></x>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>Optional frame at which next animation should start.</haxe_doc>
		</nextFrame>
		<new public="1" set="method" line="184">
			<f a="frames">
				<c path="Array"><c path="h2d.AnimationFrame"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates new animation descriptor with specified frames.</haxe_doc>
		</new>
		<haxe_doc>An animation descriptor used for AnimationExt.
  Describes general information about animation.</haxe_doc>
	</class>
	<enum path="h2d.AnimationCommand" params="" file="./h2d/AnimationExt.hx" module="h2d.AnimationExt">
		<Delay a="time">
			<x path="Float"/>
			<haxe_doc>Delays execution of next command by specified time in seconds.</haxe_doc>
		</Delay>
		<SwitchTo a="name:frame">
			<c path="String"/>
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>Switches to an animation with specified name and plays it at specified frame.
    If frame value is `null` - animation frame will not reset when switching to same animation.
    Executes next command immediately if animation not found.</haxe_doc>
		</SwitchTo>
		<Jump a="frame">
			<x path="Int"/>
			<haxe_doc>Jumps to specified frame in current animation.</haxe_doc>
		</Jump>
		<Pause><haxe_doc>Pauses playback.
    Executes next command immediately.</haxe_doc></Pause>
		<Reset><haxe_doc>Resets animation. Equivalent to Jump(0).</haxe_doc></Reset>
		<SetLoop a="loop">
			<x path="Bool"/>
			<haxe_doc>Sets animation looping flag.
    Executes next command immediately.</haxe_doc>
		</SetLoop>
		<SetSpeed a="speed">
			<x path="Float"/>
			<haxe_doc>Sets animation speed value.
    Executes next command immediately.</haxe_doc>
		</SetSpeed>
		<Event a="name">
			<c path="String"/>
			<haxe_doc>Calls `onEvent` with specified event name.
    Executes next command immediately.</haxe_doc>
		</Event>
		<Chain a="commands">
			<c path="Array"><e path="h2d.AnimationCommand"/></c>
			<haxe_doc>Executes a chain of command ignoring if it should trigger next command or delay it.
    Delay command does not have an effect on Chain execution, but sets the animation delay.
    Executes next command immediately if animation is paused.</haxe_doc>
		</Chain>
		<haxe_doc>Type of animation command for AnimationExt command buffer.</haxe_doc>
	</enum>
	<class path="h2d.Bitmap" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Bitmap.hx">
		<extends path="h2d.Drawable"/>
		<tile public="1">
			<c path="h2d.Tile"/>
			<haxe_doc>The tile to display see `h2d.Tile` documentation for details.
		If the tile is null, a pink 5x5 bitmap will be displayed instead. Use remove() or visible=false to hide a h2d.Bitmap</haxe_doc>
		</tile>
		<set_tileWrap set="method" line="22" override="1"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_tileWrap>
		<getBoundsRec set="method" line="28" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<draw set="method" line="33" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="17">
			<f a="?tile:?parent">
				<c path="h2d.Tile"/>
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a Bitmap with specified tile and parent object.</haxe_doc>
		</new>
		<haxe_doc>h2d.Bitmap is used to display a single bitmap Tile on the screen.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="h2d.BlendMode" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/BlendMode.hx">
		<None/>
		<Alpha/>
		<Add/>
		<AlphaAdd/>
		<SoftAdd/>
		<Multiply/>
		<Erase/>
		<Screen/>
		<Sub/>
		<Max/>
		<Min/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h2d.FPS" params="" file="./h2d/FPS.hx">
		<extends path="h2d.Object"/>
		<currentFPS public="1" set="null"><x path="Int"/></currentFPS>
		<previousFrameCount><x path="Int"/></previousFrameCount>
		<stats><c path="h2d.Text"/></stats>
		<deltas><t path="List"><x path="Float"/></t></deltas>
		<sync set="method" line="27" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<new public="1" set="method" line="18"><f a="?parent">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Primitive FPS counter.
  Adapted from openfl.display.FPS</haxe_doc>
	</class>
	<class path="h2d.Kerning" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Font.hx" module="h2d.Font">
		<prevChar public="1"><x path="Int"/></prevChar>
		<offset public="1"><x path="Float"/></offset>
		<next public="1"><x path="Null"><c path="h2d.Kerning"/></x></next>
		<new public="1" set="method" line="7"><f a="c:o">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.FontChar" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Font.hx" module="h2d.Font">
		<t public="1"><c path="h2d.Tile"/></t>
		<width public="1"><x path="Float"/></width>
		<kerning><x path="Null"><c path="h2d.Kerning"/></x></kerning>
		<addKerning public="1" set="method" line="24"><f a="prevChar:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addKerning>
		<getKerningOffset public="1" set="method" line="30"><f a="prevChar">
	<x path="Int"/>
	<x path="Float"/>
</f></getKerningOffset>
		<clone public="1" set="method" line="40"><f a=""><c path="h2d.FontChar"/></f></clone>
		<new public="1" set="method" line="19"><f a="t:w">
	<c path="h2d.Tile"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="h2d.SDFChannel" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Font.hx" module="h2d.Font">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<haxe_doc>Channel reading method for SDF.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="h2d._Font.SDFChannel_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Font.hx" private="1" module="h2d.Font" extern="1">
	<Red public="1" get="inline" set="null" expr="cast 0" line="62" static="1">
		<x path="h2d.SDFChannel"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Use red channel of a texture to determine distance.</haxe_doc>
	</Red>
	<Green public="1" get="inline" set="null" expr="cast 1" line="64" static="1">
		<x path="h2d.SDFChannel"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Use green channel of a texture to determine distance.</haxe_doc>
	</Green>
	<Blue public="1" get="inline" set="null" expr="cast 2" line="66" static="1">
		<x path="h2d.SDFChannel"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Use blue channel of a texture to determine distance.</haxe_doc>
	</Blue>
	<Alpha public="1" get="inline" set="null" expr="cast 3" line="68" static="1">
		<x path="h2d.SDFChannel"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Use alpha channel of a texture to determine distance.</haxe_doc>
	</Alpha>
	<MultiChannel public="1" get="inline" set="null" expr="cast 4" line="70" static="1">
		<x path="h2d.SDFChannel"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Use RGB channels of a texture to determine distance. See here for details: https://github.com/Chlumsky/msdfgen</haxe_doc>
	</MultiChannel>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="h2d._Font.SDFChannel_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Font.hx" private="1" module="h2d.Font" extern="1">
		<Red public="1" get="inline" set="null" expr="cast 0" line="62" static="1">
			<x path="h2d.SDFChannel"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Use red channel of a texture to determine distance.</haxe_doc>
		</Red>
		<Green public="1" get="inline" set="null" expr="cast 1" line="64" static="1">
			<x path="h2d.SDFChannel"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Use green channel of a texture to determine distance.</haxe_doc>
		</Green>
		<Blue public="1" get="inline" set="null" expr="cast 2" line="66" static="1">
			<x path="h2d.SDFChannel"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Use blue channel of a texture to determine distance.</haxe_doc>
		</Blue>
		<Alpha public="1" get="inline" set="null" expr="cast 3" line="68" static="1">
			<x path="h2d.SDFChannel"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Use alpha channel of a texture to determine distance.</haxe_doc>
		</Alpha>
		<MultiChannel public="1" get="inline" set="null" expr="cast 4" line="70" static="1">
			<x path="h2d.SDFChannel"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Use RGB channels of a texture to determine distance. See here for details: https://github.com/Chlumsky/msdfgen</haxe_doc>
		</MultiChannel>
		<meta><m n=":enum"/></meta>
	</class>
	<enum path="h2d.FontType" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Font.hx" module="h2d.Font">
		<BitmapFont/>
		<SignedDistanceField a="channel:alphaCutoff:smoothing">
			<x path="h2d.SDFChannel"/>
			<x path="Float"/>
			<x path="Float"/>
			<haxe_doc>Signed Distance Field font. Channel indexes are in RGBA order. See here for info: https://github.com/libgdx/libgdx/wiki/Distance-field-fonts</haxe_doc>
		</SignedDistanceField>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="h2d.Font" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Font.hx">
		<name public="1" set="null"><c path="String"/></name>
		<size public="1" set="null"><x path="Int"/></size>
		<baseLine public="1" set="null"><x path="Float"/></baseLine>
		<lineHeight public="1" set="null"><x path="Float"/></lineHeight>
		<tile public="1" set="null"><c path="h2d.Tile"/></tile>
		<tilePath public="1" set="null"><c path="String"/></tilePath>
		<type public="1"><e path="h2d.FontType"/></type>
		<charset public="1"><c path="hxd.Charset"/></charset>
		<glyphs><t path="Map">
	<x path="Int"/>
	<c path="h2d.FontChar"/>
</t></glyphs>
		<nullChar><c path="h2d.FontChar"/></nullChar>
		<defaultChar><c path="h2d.FontChar"/></defaultChar>
		<initSize><x path="Int"/></initSize>
		<offsetX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offsetX>
		<offsetY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offsetY>
		<getChar public="1" get="inline" set="null" line="111"><f a="code">
	<x path="Int"/>
	<x path="Null"><c path="h2d.FontChar"/></x>
</f></getChar>
		<setOffset public="1" set="method" line="121"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setOffset>
		<clone public="1" set="method" line="133"><f a=""><c path="h2d.Font"/></f></clone>
		<resizeTo public="1" set="method" line="153">
			<f a="size">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This is meant to create smoother fonts by creating them with double size while still keeping the original glyph size.</haxe_doc>
		</resizeTo>
		<hasChar public="1" set="method" line="171"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></hasChar>
		<dispose public="1" set="method" line="175"><f a=""><x path="Void"/></f></dispose>
		<new set="method" line="96"><f a="name:size:?type">
	<c path="String"/>
	<x path="Int"/>
	<e path="h2d.FontType"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="h2d._Graphics.GraphicsPoint" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Graphics.hx" private="1" module="h2d.Graphics"><c path="hxd.poly2tri.Point"/></typedef>
	<class path="h2d._Graphics.GPoint" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Graphics.hx" private="1" module="h2d.Graphics">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<r public="1"><x path="Float"/></r>
		<g public="1"><x path="Float"/></g>
		<b public="1"><x path="Float"/></b>
		<a public="1"><x path="Float"/></a>
		<new public="1" set="method" line="13"><f a="x:y:r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.impl._Serializable.NoSerializeSupport" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/Serializable.hx" private="1" module="hxd.impl.Serializable" interface="1"/>
	<class path="h3d.prim.Primitive" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/prim/Primitive.hx">
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<buffer public="1">
			<c path="h3d.Buffer"/>
			<haxe_doc>The primitive vertex buffer, holding its vertexes data.</haxe_doc>
		</buffer>
		<indexes public="1">
			<c path="h3d.Indexes"/>
			<haxe_doc>The primitive indexes buffer, holding its triangles indices.</haxe_doc>
		</indexes>
		<triCount public="1" set="method" line="22">
			<f a=""><x path="Int"/></f>
			<haxe_doc>The number of triangles the primitive has.</haxe_doc>
		</triCount>
		<vertexCount public="1" set="method" line="29">
			<f a=""><x path="Int"/></f>
			<haxe_doc>The number of vertexes the primitive has.</haxe_doc>
		</vertexCount>
		<getCollider public="1" set="method" line="36">
			<f a=""><c path="h3d.col.Collider"/></f>
			<haxe_doc>Return a local collider for the primitive</haxe_doc>
		</getCollider>
		<getBounds public="1" set="method" line="44">
			<f a=""><c path="h3d.col.Bounds"/></f>
			<haxe_doc>Return the bounds for the primitive</haxe_doc>
		</getBounds>
		<alloc public="1" set="method" line="52">
			<f a="engine">
				<c path="h3d.Engine"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allocate the primitive on GPU. Used for internal usage.</haxe_doc>
		</alloc>
		<selectMaterial public="1" set="method" line="59">
			<f a="material">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Select the specified sub material before drawin. Used for internal usage.</haxe_doc>
		</selectMaterial>
		<buildNormalsDisplay public="1" set="method" line="62">
			<f a=""><c path="h3d.prim.Primitive"/></f>
			<meta><m n=":noCompletion"/></meta>
		</buildNormalsDisplay>
		<render public="1" set="method" line="70">
			<f a="engine">
				<c path="h3d.Engine"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Render the primitive. Used for internal usage.</haxe_doc>
		</render>
		<dispose public="1" set="method" line="84">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Dispose the primitive, freeing the GPU memory it uses.</haxe_doc>
		</dispose>
		<toString public="1" set="method" line="98">
			<f a=""><x path="Null"><c path="String"/></x></f>
			<haxe_doc>Return the primitive type.</haxe_doc>
		</toString>
		<haxe_doc>h3d.prim.Primitive is the base class for all 3D primitives.
	You can't create an instance of it and need to use one of its subclasses.</haxe_doc>
	</class>
	<class path="h2d._Graphics.GraphicsContent" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Graphics.hx" private="1" module="h2d.Graphics">
		<extends path="h3d.prim.Primitive"/>
		<tmp><x path="hxd.FloatBuffer"/></tmp>
		<index><x path="hxd.IndexBuffer"/></index>
		<buffers><c path="Array"><a>
	<vbuf><c path="h3d.Buffer"/></vbuf>
	<idx><x path="hxd.IndexBuffer"/></idx>
	<ibuf><c path="h3d.Indexes"/></ibuf>
	<buf><x path="hxd.FloatBuffer"/></buf>
</a></c></buffers>
		<addIndex public="1" get="inline" set="null" line="34"><f a="i">
	<x path="Int"/>
	<x path="Void"/>
</f></addIndex>
		<add public="1" get="inline" set="null" line="38"><f a="x:y:u:v:r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></add>
		<next public="1" set="method" line="49"><f a=""><x path="Bool"/></f></next>
		<alloc public="1" set="method" line="60" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<render public="1" set="method" line="70" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<flush public="1" get="inline" set="null" line="78"><f a=""><x path="Void"/></f></flush>
		<dispose public="1" set="method" line="82" override="1"><f a=""><x path="Void"/></f></dispose>
		<clear public="1" set="method" line="93"><f a=""><x path="Void"/></f></clear>
		<new public="1" set="method" line="30"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.Graphics" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Graphics.hx">
		<extends path="h2d.Drawable"/>
		<EARCUT expr="null" line="299" static="1">
			<c path="hxd.earcut.Earcut"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</EARCUT>
		<content><c path="h2d._Graphics.GraphicsContent"/></content>
		<tmpPoints><c path="Array"><c path="h2d._Graphics.GPoint"/></c></tmpPoints>
		<pindex><x path="Int"/></pindex>
		<curR><x path="Float"/></curR>
		<curG><x path="Float"/></curG>
		<curB><x path="Float"/></curB>
		<curA><x path="Float"/></curA>
		<lineSize><x path="Float"/></lineSize>
		<lineR><x path="Float"/></lineR>
		<lineG><x path="Float"/></lineG>
		<lineB><x path="Float"/></lineB>
		<lineA><x path="Float"/></lineA>
		<doFill><x path="Bool"/></doFill>
		<xMin><x path="Float"/></xMin>
		<yMin><x path="Float"/></yMin>
		<xMax><x path="Float"/></xMax>
		<yMax><x path="Float"/></yMax>
		<ma expr="1.">
			<x path="Float"/>
			<meta><m n=":value"><e>1.</e></m></meta>
		</ma>
		<mb expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</mb>
		<mc expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</mc>
		<md expr="1.">
			<x path="Float"/>
			<meta><m n=":value"><e>1.</e></m></meta>
		</md>
		<mx expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</mx>
		<my expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</my>
		<tile public="1"><c path="h2d.Tile"/></tile>
		<bevel public="1" expr="0.25">
			<x path="Float"/>
			<meta><m n=":value"><e>0.25</e></m></meta>
		</bevel>
		<onRemove set="method" line="140" override="1"><f a=""><x path="Void"/></f></onRemove>
		<clear public="1" set="method" line="145"><f a=""><x path="Void"/></f></clear>
		<getBoundsRec set="method" line="156" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<isConvex set="method" line="161"><f a="points">
	<c path="Array"><c path="h2d._Graphics.GPoint"/></c>
	<x path="Bool"/>
</f></isConvex>
		<flushLine set="method" line="177"><f a="start">
	<x path="Int"/>
	<x path="Void"/>
</f></flushLine>
		<flushFill set="method" line="301"><f a="i0">
	<x path="Int"/>
	<x path="Void"/>
</f></flushFill>
		<flush set="method" line="332"><f a=""><x path="Void"/></f></flush>
		<beginFill public="1" set="method" line="349">
			<f a="?color:?alpha" v="0:1.">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1., color : 0 }</e></m></meta>
		</beginFill>
		<beginTileFill public="1" set="method" line="359">
			<f a="?dx:?dy:?scaleX:?scaleY:?tile">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h2d.Tile"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Position a virtual tile at the given position and scale. Every draw will display a part of this tile relative
		to these coordinates.</haxe_doc>
		</beginTileFill>
		<drawTile public="1" set="method" line="392"><f a="x:y:tile">
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></drawTile>
		<lineStyle public="1" set="method" line="398">
			<f a="?size:?color:?alpha" v="0:0:1.">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1., color : 0, size : 0 }</e></m></meta>
		</lineStyle>
		<moveTo public="1" get="inline" set="null" line="407"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<endFill public="1" set="method" line="412"><f a=""><x path="Void"/></f></endFill>
		<setColor public="1" get="inline" set="null" line="417">
			<f a="color:?alpha" v=":1.">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1. }</e></m></meta>
		</setColor>
		<drawRect public="1" set="method" line="424"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<drawRoundedRect public="1" set="method" line="434">
			<f a="x:y:w:h:radius:?nsegments" v=":::::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nsegments : 0 }</e></m></meta>
		</drawRoundedRect>
		<drawCircle public="1" set="method" line="465">
			<f a="cx:cy:radius:?nsegments" v=":::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nsegments : 0 }</e></m></meta>
		</drawCircle>
		<drawEllipse public="1" set="method" line="478">
			<f a="cx:cy:radiusX:radiusY:?rotationAngle:?nsegments" v="::::0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nsegments : 0, rotationAngle : 0 }</e></m></meta>
		</drawEllipse>
		<drawPie public="1" set="method" line="494">
			<f a="cx:cy:radius:angleStart:angleLength:?nsegments" v=":::::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nsegments : 0 }</e></m></meta>
		</drawPie>
		<lineTo public="1" get="inline" set="null" line="512"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<addVertex public="1" set="method" line="516">
			<f a="x:y:r:g:b:a:?u:?v" v="::::::0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ v : 0., u : 0. }</e></m></meta>
		</addVertex>
		<draw set="method" line="526" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<sync set="method" line="531" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<new public="1" set="method" line="133"><f a="?parent">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.Text" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Text.hx">
		<extends path="h2d.Drawable"/>
		<font public="1" set="accessor"><c path="h2d.Font"/></font>
		<text public="1" set="accessor"><t path="hxd.UString"/></text>
		<textColor public="1" set="accessor"><x path="Int"/></textColor>
		<maxWidth public="1" set="accessor"><x path="Null"><x path="Float"/></x></maxWidth>
		<dropShadow public="1"><a>
	<dy><x path="Float"/></dy>
	<dx><x path="Float"/></dx>
	<color><x path="Int"/></color>
	<alpha><x path="Float"/></alpha>
</a></dropShadow>
		<textWidth public="1" get="accessor" set="null"><x path="Float"/></textWidth>
		<textHeight public="1" get="accessor" set="null"><x path="Float"/></textHeight>
		<textAlign public="1" set="accessor"><e path="h2d.Align"/></textAlign>
		<letterSpacing public="1" set="accessor"><x path="Float"/></letterSpacing>
		<lineSpacing public="1" set="accessor"><x path="Float"/></lineSpacing>
		<glyphs><c path="h2d.TileGroup"/></glyphs>
		<calcDone><x path="Bool"/></calcDone>
		<calcXMin><x path="Float"/></calcXMin>
		<calcYMin><x path="Float"/></calcYMin>
		<calcWidth><x path="Float"/></calcWidth>
		<calcHeight><x path="Float"/></calcHeight>
		<calcSizeHeight><x path="Float"/></calcSizeHeight>
		<constraintWidth expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</constraintWidth>
		<realMaxWidth expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</realMaxWidth>
		<sdfShader><c path="h3d.shader.SignedDistanceField"/></sdfShader>
		<set_font set="method" line="51"><f a="font">
	<c path="h2d.Font"/>
	<c path="h2d.Font"/>
</f></set_font>
		<set_textAlign set="method" line="85"><f a="a">
	<e path="h2d.Align"/>
	<e path="h2d.Align"/>
</f></set_textAlign>
		<set_letterSpacing set="method" line="92"><f a="s">
	<x path="Float"/>
	<x path="Float"/>
</f></set_letterSpacing>
		<set_lineSpacing set="method" line="99"><f a="s">
	<x path="Float"/>
	<x path="Float"/>
</f></set_lineSpacing>
		<constraintSize set="method" line="106" override="1"><f a="width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></constraintSize>
		<onAdd set="method" line="111" override="1"><f a=""><x path="Void"/></f></onAdd>
		<draw set="method" line="116" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<set_text set="method" line="141"><f a="t">
	<t path="hxd.UString"/>
	<c path="String"/>
</f></set_text>
		<rebuild set="method" line="149"><f a=""><x path="Void"/></f></rebuild>
		<calcTextWidth public="1" set="method" line="155"><f a="text">
	<t path="hxd.UString"/>
	<x path="Float"/>
</f></calcTextWidth>
		<splitText public="1" set="method" line="173">
			<f a="text:?leftMargin:?afterData" v=":0.:0.">
				<t path="hxd.UString"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="hxd.UString"/>
			</f>
			<meta><m n=":value"><e>{ afterData : 0., leftMargin : 0. }</e></m></meta>
		</splitText>
		<initGlyphs set="method" line="230">
			<f a="text:?rebuild:?handleAlign:?lines" v=":true:true:null">
				<t path="hxd.UString"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ lines : null, handleAlign : true, rebuild : true }</e></m></meta>
		</initGlyphs>
		<updateSize get="inline" set="null" line="289"><f a=""><x path="Void"/></f></updateSize>
		<get_textHeight set="method" line="293"><f a=""><x path="Float"/></f></get_textHeight>
		<get_textWidth set="method" line="298"><f a=""><x path="Float"/></f></get_textWidth>
		<set_maxWidth set="method" line="303"><f a="w">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_maxWidth>
		<updateConstraint set="method" line="310"><f a=""><x path="Void"/></f></updateConstraint>
		<set_textColor set="method" line="322"><f a="c">
	<x path="Int"/>
	<x path="Int"/>
</f></set_textColor>
		<getBoundsRec set="method" line="331" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<new public="1" set="method" line="41"><f a="font:?parent">
	<c path="h2d.Font"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.HtmlText" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/HtmlText.hx">
		<extends path="h2d.Text"/>
		<REG_SPACES expr="~/[
	 ]+/" line="161" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/[
	 ]+/</e></m></meta>
		</REG_SPACES>
		<condenseWhite public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</condenseWhite>
		<elements expr="[]">
			<c path="Array"><c path="h2d.Object"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</elements>
		<xPos><x path="Float"/></xPos>
		<yPos><x path="Float"/></yPos>
		<xMax><x path="Float"/></xMax>
		<xMin><x path="Float"/></xMin>
		<sizePos><x path="Int"/></sizePos>
		<dropMatrix><c path="h3d.shader.ColorMatrix"/></dropMatrix>
		<prevChar><x path="Int"/></prevChar>
		<newLine><x path="Bool"/></newLine>
		<draw set="method" line="19" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<loadImage public="1" set="dynamic" line="42"><f a="url">
	<c path="String"/>
	<c path="h2d.Tile"/>
</f></loadImage>
		<loadFont public="1" set="dynamic" line="46"><f a="name">
	<c path="String"/>
	<c path="h2d.Font"/>
</f></loadFont>
		<initGlyphs set="method" line="50" override="1">
			<f a="text:?rebuild:?handleAlign:?lines" v=":true:true:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ handleAlign : true, rebuild : true }</e></m></meta>
		</initGlyphs>
		<buildSizes set="method" line="104"><f a="e:font:sizes">
	<c path="Xml"/>
	<c path="h2d.Font"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></buildSizes>
		<htmlToText set="method" line="162"><f a="t">
	<t path="hxd.UString"/>
	<t path="hxd.UString"/>
</f></htmlToText>
		<remainingSize set="method" line="168"><f a="sizes">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
</f></remainingSize>
		<addNode set="method" line="181">
			<f a="e:font:rebuild:handleAlign:sizes:?lines" v=":::::null">
				<c path="Xml"/>
				<c path="h2d.Font"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ lines : null }</e></m></meta>
		</addNode>
		<set_textColor set="method" line="330" override="1"><f a="c">
	<x path="Int"/>
	<x path="Int"/>
</f></set_textColor>
		<set_condenseWhite set="method" line="337"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_condenseWhite>
		<getBoundsRec set="method" line="345" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<new public="1" set="method" line="5"><f a="font:?parent">
	<c path="h2d.Font"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.Interactive" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/SceneEvents.hx" module="hxd.SceneEvents" interface="1">
		<handleEvent public="1" set="method"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></handleEvent>
		<getInteractiveScene public="1" set="method"><f a=""><c path="hxd.InteractiveScene"/></f></getInteractiveScene>
	</class>
	<class path="h2d.Interactive" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Interactive.hx">
		<extends path="h2d.Drawable"/>
		<implements path="hxd.Interactive"/>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>Width of the Interactive. Ignored if `shape` is set.</haxe_doc>
		</width>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>Height of the Interactive. Ignored if `shape` is set.</haxe_doc>
		</height>
		<cursor public="1" set="accessor">
			<e path="hxd.Cursor"/>
			<haxe_doc>Cursor used when Interactive is under mouse cursor ( default : Button )</haxe_doc>
		</cursor>
		<isEllipse public="1">
			<x path="Bool"/>
			<haxe_doc>Should object collision be in rectangle or ellipse form? Ignored if `shape` is set.</haxe_doc>
		</isEllipse>
		<cancelEvents public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Set the default `cancel` mode (see `hxd.Event`), default to false.</haxe_doc>
		</cancelEvents>
		<propagateEvents public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Set the default `propagate` mode (see `hxd.Event`), default to false.</haxe_doc>
		</propagateEvents>
		<backgroundColor public="1"><x path="Null"><x path="Int"/></x></backgroundColor>
		<enableRightButton public="1"><x path="Bool"/></enableRightButton>
		<scene><c path="h2d.Scene"/></scene>
		<mouseDownButton expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</mouseDownButton>
		<parentMask><c path="h2d.Mask"/></parentMask>
		<invDet><x path="Float"/></invDet>
		<shape public="1">
			<c path="h2d.col.Collider"/>
			<haxe_doc>Detailed shape collider for Interactive.
		If set, `width` and `height` properties are ignored for collision checks.</haxe_doc>
		</shape>
		<shapeX public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>Detailed shape X offset from Interactive.</haxe_doc>
		</shapeX>
		<shapeY public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>Detailed shape Y offset from Interactive.</haxe_doc>
		</shapeY>
		<onAdd set="method" line="59" override="1"><f a=""><x path="Void"/></f></onAdd>
		<draw set="method" line="66" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<getBoundsRec set="method" line="70" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<onParentChanged set="method" line="75" override="1"><f a=""><x path="Void"/></f></onParentChanged>
		<updateMask set="method" line="84"><f a=""><x path="Void"/></f></updateMask>
		<onRemove set="method" line="97" override="1"><f a=""><x path="Void"/></f></onRemove>
		<checkBounds set="method" line="105"><f a="e">
	<c path="hxd.Event"/>
	<x path="Bool"/>
</f></checkBounds>
		<preventClick public="1" set="method" line="115">
			<f a=""><x path="Void"/></f>
			<haxe_doc>This can be called during or after a push event in order to prevent the release from triggering a click.</haxe_doc>
		</preventClick>
		<getInteractiveScene public="1" set="method" line="119">
			<f a=""><c path="hxd.InteractiveScene"/></f>
			<meta><m n=":noCompletion"/></meta>
		</getInteractiveScene>
		<handleEvent public="1" set="method" line="123">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</handleEvent>
		<calcAbsPos set="method" line="199" override="1"><f a=""><x path="Void"/></f></calcAbsPos>
		<set_cursor set="method" line="205"><f a="c">
	<e path="hxd.Cursor"/>
	<e path="hxd.Cursor"/>
</f></set_cursor>
		<eventToLocal set="method" line="212"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></eventToLocal>
		<startDrag public="1" set="method" line="223"><f a="callb:?onCancel">
	<f a="">
		<c path="hxd.Event"/>
		<unknown/>
	</f>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></startDrag>
		<stopDrag public="1" set="method" line="233"><f a=""><x path="Void"/></f></stopDrag>
		<focus public="1" set="method" line="237"><f a=""><x path="Void"/></f></focus>
		<blur public="1" set="method" line="243"><f a=""><x path="Void"/></f></blur>
		<isOver public="1" set="method" line="247"><f a=""><x path="Bool"/></f></isOver>
		<hasFocus public="1" set="method" line="251"><f a=""><x path="Bool"/></f></hasFocus>
		<onOver public="1" set="dynamic" line="256">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when mouse enters Interactive hitbox area.</haxe_doc>
		</onOver>
		<onOut public="1" set="dynamic" line="260">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when mouse exits Interactive hitbox area.</haxe_doc>
		</onOut>
		<onPush public="1" set="dynamic" line="264">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when Interactive is pressed by user.</haxe_doc>
		</onPush>
		<onRelease public="1" set="dynamic" line="275">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent on multiple conditions.
		A. Always sent if user releases mouse while it is inside Interactive hitbox area.
			This happends regardless if that Interactive was pressed prior or not.
		B. Sent before `onReleaseOutside` if this Interactive was pressed, but released outside it's bounds.
		For first case `event.kind` will be `ERelease`, for second case - `EReleaseOutside`.
		See `onClick` and `onReleaseOutside` functions for separate events that trigger only when user interacts with this particular Interactive.</haxe_doc>
		</onRelease>
		<onReleaseOutside public="1" set="dynamic" line="282">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when user presses Interactive, moves mouse outside and releases it.
		This event fired only on Interactive that user pressed, but released mouse after moving it outside of Interactive hitbox area.</haxe_doc>
		</onReleaseOutside>
		<onClick public="1" set="dynamic" line="289">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when Interactive is clicked by user.
		This event fired only on Interactive that user pressed and released when mouse is inside Interactive hitbox area.</haxe_doc>
		</onClick>
		<onMove public="1" set="dynamic" line="292"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onMove>
		<onWheel public="1" set="dynamic" line="295"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onWheel>
		<onFocus public="1" set="dynamic" line="298"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onFocus>
		<onFocusLost public="1" set="dynamic" line="301"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onFocusLost>
		<onKeyUp public="1" set="dynamic" line="304"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onKeyUp>
		<onKeyDown public="1" set="dynamic" line="307"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onKeyDown>
		<onCheck public="1" set="dynamic" line="310"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onCheck>
		<onTextInput public="1" set="dynamic" line="313"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onTextInput>
		<new public="1" set="method" line="51"><f a="width:height:?parent:?shape">
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Object"/>
	<c path="h2d.col.Collider"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h2d.Scene</e></m>
		</meta>
	</class>
	<class path="h2d.Layers" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Layers.hx">
		<extends path="h2d.Object"/>
		<layersIndexes><c path="Array"><x path="Int"/></c></layersIndexes>
		<layerCount><x path="Int"/></layerCount>
		<addChild public="1" set="method" line="15" override="1"><f a="s">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></addChild>
		<add public="1" get="inline" set="null" line="19"><f a="s:layer">
	<c path="h2d.Object"/>
	<x path="Int"/>
	<x path="Void"/>
</f></add>
		<addChildAt public="1" set="method" line="23" override="1"><f a="s:layer">
	<c path="h2d.Object"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addChildAt>
		<removeChild public="1" set="method" line="38" override="1"><f a="s">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></removeChild>
		<under public="1" set="method" line="57"><f a="s">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></under>
		<over public="1" set="method" line="76"><f a="s">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></over>
		<getLayer public="1" set="method" line="90"><f a="layer">
	<x path="Int"/>
	<t path="Iterator"><c path="h2d.Object"/></t>
</f></getLayer>
		<drawLayer set="method" line="102"><f a="ctx:layer">
	<c path="h2d.RenderContext"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawLayer>
		<ysort public="1" set="method" line="117"><f a="layer">
	<x path="Int"/>
	<x path="Void"/>
</f></ysort>
		<new public="1" set="method" line="9"><f a="?parent">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h2d.Mask" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Mask.hx">
		<extends path="h2d.Object"/>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<parentMask><c path="h2d.Mask"/></parentMask>
		<onParentChanged set="method" line="15" override="1"><f a=""><x path="Void"/></f></onParentChanged>
		<onAdd set="method" line="20" override="1"><f a=""><x path="Void"/></f></onAdd>
		<updateMask set="method" line="25"><f a=""><x path="Void"/></f></updateMask>
		<getBoundsRec set="method" line="38" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<drawRec set="method" line="60" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></drawRec>
		<new public="1" set="method" line="9"><f a="width:height:?parent">
	<x path="Int"/>
	<x path="Int"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.impl.RenderContext" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/RenderContext.hx">
		<engine public="1"><c path="h3d.Engine"/></engine>
		<time public="1"><x path="Float"/></time>
		<elapsedTime public="1"><x path="Float"/></elapsedTime>
		<frame public="1"><x path="Int"/></frame>
		<textures public="1"><c path="h3d.impl.TextureCache"/></textures>
		<new set="method" line="11"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="h2d.RenderContext" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/RenderContext.hx">
		<extends path="h3d.impl.RenderContext"/>
		<BUFFERING get="inline" set="null" expr="false" line="5" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</BUFFERING>
		<globalAlpha public="1" expr="1.">
			<x path="Float"/>
			<meta><m n=":value"><e>1.</e></m></meta>
		</globalAlpha>
		<buffer public="1"><x path="hxd.FloatBuffer"/></buffer>
		<bufPos public="1"><x path="Int"/></bufPos>
		<scene public="1"><c path="h2d.Scene"/></scene>
		<defaultSmooth public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</defaultSmooth>
		<killAlpha public="1"><x path="Bool"/></killAlpha>
		<front2back public="1"><x path="Bool"/></front2back>
		<onBeginDraw public="1"><f a="">
	<c path="h2d.Drawable"/>
	<x path="Bool"/>
</f></onBeginDraw>
		<onEnterFilter public="1"><f a="">
	<c path="h2d.Object"/>
	<x path="Bool"/>
</f></onEnterFilter>
		<onLeaveFilter public="1"><f a="">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></onLeaveFilter>
		<tmpBounds public="1" expr="new h2d.col.Bounds()">
			<c path="h2d.col.Bounds"/>
			<meta><m n=":value"><e>new h2d.col.Bounds()</e></m></meta>
		</tmpBounds>
		<texture><c path="h3d.mat.Texture"/></texture>
		<baseShader><c path="h3d.shader.Base2d"/></baseShader>
		<manager><c path="h3d.pass.ShaderManager"/></manager>
		<compiledShader><c path="hxsl.RuntimeShader"/></compiledShader>
		<buffers><c path="h3d.shader.Buffers"/></buffers>
		<fixedBuffer><c path="h3d.Buffer"/></fixedBuffer>
		<pass><c path="h3d.mat.Pass"/></pass>
		<currentShaders><c path="hxsl.ShaderList"/></currentShaders>
		<baseShaderList><c path="hxsl.ShaderList"/></baseShaderList>
		<currentObj><c path="h2d.Drawable"/></currentObj>
		<stride><x path="Int"/></stride>
		<targetsStack><c path="Array"><a>
	<y><x path="Int"/></y>
	<x><x path="Int"/></x>
	<w><x path="Int"/></w>
	<t><c path="h3d.mat.Texture"/></t>
	<rzY><x path="Float"/></rzY>
	<rzX><x path="Float"/></rzX>
	<rzW><x path="Float"/></rzW>
	<rzH><x path="Float"/></rzH>
	<hasRZ><x path="Bool"/></hasRZ>
	<h><x path="Int"/></h>
</a></c></targetsStack>
		<targetsStackIndex><x path="Int"/></targetsStackIndex>
		<hasUVPos><x path="Bool"/></hasUVPos>
		<filterStack><c path="Array"><c path="h2d.Object"/></c></filterStack>
		<inFilter><c path="h2d.Object"/></inFilter>
		<inFilterBlend><e path="h2d.BlendMode"/></inFilterBlend>
		<curX><x path="Int"/></curX>
		<curY><x path="Int"/></curY>
		<curWidth><x path="Int"/></curWidth>
		<curHeight><x path="Int"/></curHeight>
		<hasRenderZone><x path="Bool"/></hasRenderZone>
		<renderX><x path="Float"/></renderX>
		<renderY><x path="Float"/></renderY>
		<renderW><x path="Float"/></renderW>
		<renderH><x path="Float"/></renderH>
		<currentBlend><e path="h2d.BlendMode"/></currentBlend>
		<baseFlipY><x path="Float"/></baseFlipY>
		<targetFlipY><x path="Float"/></targetFlipY>
		<dispose public="1" set="method" line="71"><f a=""><x path="Void"/></f></dispose>
		<hasBuffering public="1" get="inline" set="null" line="76"><f a=""><x path="Bool"/></f></hasBuffering>
		<begin public="1" set="method" line="80"><f a=""><x path="Void"/></f></begin>
		<allocTarget public="1" set="method" line="105">
			<f a="name:?filter" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<meta><m n=":value"><e>{ filter : false }</e></m></meta>
		</allocTarget>
		<clear public="1" set="method" line="111"><f a="color">
	<x path="Null"><x path="Int"/></x>
	<x path="Void"/>
</f></clear>
		<initShaders set="method" line="115"><f a="shaders">
	<c path="hxsl.ShaderList"/>
	<x path="Void"/>
</f></initShaders>
		<end public="1" set="method" line="127"><f a=""><x path="Void"/></f></end>
		<pushFilter public="1" set="method" line="135"><f a="spr">
	<c path="h2d.Object"/>
	<x path="Bool"/>
</f></pushFilter>
		<popFilter public="1" set="method" line="143"><f a=""><x path="Void"/></f></popFilter>
		<pushTarget public="1" set="method" line="153">
			<f a="t:?startX:?startY:?width:?height" v=":0:0:-1:-1">
				<c path="h3d.mat.Texture"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : -1, width : -1, startY : 0, startX : 0 }</e></m></meta>
		</pushTarget>
		<popTarget public="1" set="method" line="185">
			<f a="?restore" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ restore : true }</e></m></meta>
		</popTarget>
		<setRenderZone public="1" set="method" line="210"><f a="x:y:w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRenderZone>
		<clearRenderZone public="1" get="inline" set="null" line="234"><f a=""><x path="Void"/></f></clearRenderZone>
		<drawLayer set="method" line="239"><f a="layer">
	<x path="Int"/>
	<x path="Void"/>
</f></drawLayer>
		<drawScene public="1" set="method" line="243"><f a=""><x path="Void"/></f></drawScene>
		<flush public="1" get="inline" set="null" line="247"><f a=""><x path="Void"/></f></flush>
		<_flush set="method" line="251"><f a=""><x path="Void"/></f></_flush>
		<beforeDraw public="1" set="method" line="263"><f a=""><x path="Void"/></f></beforeDraw>
		<setupColor get="inline" set="null" line="294"><f a="obj">
	<c path="h2d.Drawable"/>
	<x path="Void"/>
</f></setupColor>
		<beginDrawObject public="1" set="method" line="306">
			<f a="obj:texture">
				<c path="h2d.Drawable"/>
				<c path="h3d.mat.Texture"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":access"><e>h2d.Drawable</e></m></meta>
		</beginDrawObject>
		<beginDrawBatch public="1" set="method" line="316">
			<f a="obj:texture">
				<c path="h2d.Drawable"/>
				<c path="h3d.mat.Texture"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":access"><e>h2d.Drawable</e></m></meta>
		</beginDrawBatch>
		<drawTile public="1" set="method" line="321">
			<f a="obj:tile">
				<c path="h2d.Drawable"/>
				<c path="h2d.Tile"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":access"><e>h2d.Drawable</e></m></meta>
		</drawTile>
		<beginDraw set="method" line="390">
			<f a="obj:texture:isRelative:?hasUVPos" v=":::false">
				<c path="h2d.Drawable"/>
				<c path="h3d.mat.Texture"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":value"><e>{ hasUVPos : false }</e></m>
				<m n=":access"><e>h2d.Drawable</e></m>
			</meta>
		</beginDraw>
		<new public="1" set="method" line="52"><f a="scene">
	<c path="h2d.Scene"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.TileGroup" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/TileGroup.hx">
		<extends path="h2d.Drawable"/>
		<content><c path="h2d._TileGroup.TileLayerContent"/></content>
		<curColor><c path="h3d.Vector"/></curColor>
		<tile public="1"><c path="h2d.Tile"/></tile>
		<rangeMin public="1"><x path="Int"/></rangeMin>
		<rangeMax public="1"><x path="Int"/></rangeMax>
		<getBoundsRec set="method" line="404" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<clear public="1" set="method" line="409"><f a=""><x path="Void"/></f></clear>
		<invalidate public="1" set="method" line="417">
			<f a=""><x path="Void"/></f>
			<haxe_doc>If you want to add tiles after the GPU memory has been allocated (when the tilegroup with sync/displayed),
		make sure to call invalidate() first to force a refresh of your data.</haxe_doc>
		</invalidate>
		<count public="1" set="method" line="424">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the number of tiles added to the group</haxe_doc>
		</count>
		<onRemove set="method" line="428" override="1"><f a=""><x path="Void"/></f></onRemove>
		<setDefaultColor public="1" set="method" line="433">
			<f a="rgb:?alpha" v=":1.0">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1.0 }</e></m></meta>
		</setDefaultColor>
		<add public="1" get="inline" set="null" line="440"><f a="x:y:t">
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></add>
		<addColor public="1" get="inline" set="null" line="444"><f a="x:y:r:g:b:a:t">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></addColor>
		<addAlpha public="1" get="inline" set="null" line="448"><f a="x:y:a:t">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></addAlpha>
		<addTransform public="1" get="inline" set="null" line="452"><f a="x:y:sx:sy:r:t">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></addTransform>
		<draw set="method" line="456" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<sync set="method" line="461" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<drawWith set="method" line="470">
			<f a="ctx:obj">
				<c path="h2d.RenderContext"/>
				<c path="h2d.Drawable"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h2d</e></m></meta>
		</drawWith>
		<new public="1" set="method" line="396"><f a="t:?parent">
	<c path="h2d.Tile"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.ScaleGridExt" params="" file="./h2d/ScaleGridExt.hx">
		<extends path="h2d.TileGroup"/>
		<borderTop public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>Height of the top border.</haxe_doc>
		</borderTop>
		<borderBottom public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>Height of the bottom border.</haxe_doc>
		</borderBottom>
		<borderLeft public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>Width of the left border.</haxe_doc>
		</borderLeft>
		<borderRight public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>Height of the right border.</haxe_doc>
		</borderRight>
		<width public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>Width of the ScaleGrid.</haxe_doc>
		</width>
		<height public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>Height of the ScaleGrid.</haxe_doc>
		</height>
		<tileBorders public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>If true, borders will be tiled instead of stretched.</haxe_doc>
		</tileBorders>
		<tileCenter public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>If true, central part will be tiled instead of stretched.</haxe_doc>
		</tileCenter>
		<set_tileBorders set="method" line="53"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_tileBorders>
		<set_tileCenter set="method" line="59"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_tileCenter>
		<set_width set="method" line="65"><f a="w">
	<x path="Int"/>
	<x path="Int"/>
</f></set_width>
		<set_height set="method" line="71"><f a="h">
	<x path="Int"/>
	<x path="Int"/>
</f></set_height>
		<set_borderTop set="method" line="77"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_borderTop>
		<set_borderBottom set="method" line="83"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_borderBottom>
		<set_borderLeft set="method" line="89"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_borderLeft>
		<set_borderRight set="method" line="95"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_borderRight>
		<getBoundsRec set="method" line="101" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<updateContent set="method" line="106"><f a=""><x path="Void"/></f></updateContent>
		<sync set="method" line="216" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<new public="1" set="method" line="43"><f a="tile:borderT:borderB:borderL:borderR:?parent">
	<c path="h2d.Tile"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Extended ScaleGrid: Allows for tiling of center and borders have individual sizes.</haxe_doc>
	</class>
	<class path="hxd.InteractiveScene" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/SceneEvents.hx" module="hxd.SceneEvents" interface="1">
		<setEvents public="1" set="method"><f a="s">
	<c path="hxd.SceneEvents"/>
	<x path="Void"/>
</f></setEvents>
		<handleEvent public="1" set="method"><f a="e:last">
	<c path="hxd.Event"/>
	<c path="hxd.Interactive"/>
	<c path="hxd.Interactive"/>
</f></handleEvent>
		<dispatchEvent public="1" set="method"><f a="e:to">
	<c path="hxd.Event"/>
	<c path="hxd.Interactive"/>
	<x path="Void"/>
</f></dispatchEvent>
		<dispatchListeners public="1" set="method"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></dispatchListeners>
		<isInteractiveVisible public="1" set="method"><f a="i">
	<c path="hxd.Interactive"/>
	<x path="Bool"/>
</f></isInteractiveVisible>
	</class>
	<class path="h3d.IDrawable" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/IDrawable.hx" interface="1"><render public="1" set="method"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render></class>
	<class path="h2d.Scene" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Scene.hx">
		<extends path="h2d.Layers"/>
		<implements path="hxd.InteractiveScene"/>
		<implements path="h3d.IDrawable"/>
		<width public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The current width (in pixels) of the scene. Can change if the screen gets resized.</haxe_doc>
		</width>
		<height public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The current height (in pixels) of the scene. Can change if the screen gets resized.</haxe_doc>
		</height>
		<mouseX public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>The current mouse X coordinates (in pixel) relative to the scene.</haxe_doc>
		</mouseX>
		<mouseY public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>The current mouse Y coordinates (in pixel) relative to the scene.</haxe_doc>
		</mouseY>
		<zoom public="1" set="accessor" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc><![CDATA[The zoom factor of the scene, allows to set a fixed x2, x4 etc. zoom for pixel art
		When setting a zoom > 0, the scene resize will be automaticaly managed.]]></haxe_doc>
		</zoom>
		<defaultSmooth public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Set the default value for `h2d.Drawable.smooth` (default: false)</haxe_doc>
		</defaultSmooth>
		<renderer public="1" get="accessor" set="accessor">
			<c path="h2d.RenderContext"/>
			<haxe_doc>The scene current renderer. Can be customized.</haxe_doc>
		</renderer>
		<fixedSize><x path="Bool"/></fixedSize>
		<interactive><c path="Array"><c path="h2d.Interactive"/></c></interactive>
		<eventListeners><c path="Array"><f a="">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></c></eventListeners>
		<ctx><c path="h2d.RenderContext"/></ctx>
		<window><c path="hxd.Window"/></window>
		<events>
			<c path="hxd.SceneEvents"/>
			<meta><m n=":allow"><e>h2d.Interactive</e></m></meta>
		</events>
		<shapePoint><c path="h2d.col.Point"/></shapePoint>
		<get_defaultSmooth get="inline" set="null" line="70"><f a=""><x path="Bool"/></f></get_defaultSmooth>
		<set_defaultSmooth get="inline" set="null" line="71"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_defaultSmooth>
		<setEvents public="1" set="method" line="74">
			<f a="events">
				<c path="hxd.SceneEvents"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</setEvents>
		<set_zoom set="method" line="78"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_zoom>
		<get_renderer set="method" line="91"><f a=""><c path="h2d.RenderContext"/></f></get_renderer>
		<set_renderer set="method" line="92"><f a="v">
	<c path="h2d.RenderContext"/>
	<c path="h2d.RenderContext"/>
</f></set_renderer>
		<setFixedSize public="1" set="method" line="97">
			<f a="w:h">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the fixed size for the scene, will prevent automatic scene resizing when screen size changes.</haxe_doc>
		</setFixedSize>
		<checkResize public="1" set="method" line="105">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</checkResize>
		<screenXToLocal get="inline" set="null" line="117"><f a="mx">
	<x path="Float"/>
	<x path="Float"/>
</f></screenXToLocal>
		<screenYToLocal get="inline" set="null" line="121"><f a="my">
	<x path="Float"/>
	<x path="Float"/>
</f></screenYToLocal>
		<get_mouseX set="method" line="125"><f a=""><x path="Float"/></f></get_mouseX>
		<get_mouseY set="method" line="129"><f a=""><x path="Float"/></f></get_mouseY>
		<dispatchListeners public="1" set="method" line="134">
			<f a="event">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</dispatchListeners>
		<isInteractiveVisible public="1" set="method" line="143">
			<f a="i">
				<c path="hxd.Interactive"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</isInteractiveVisible>
		<getInteractive public="1" set="method" line="155">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="h2d.Interactive"/>
			</f>
			<haxe_doc>Return the topmost visible Interactive at the specific coordinates</haxe_doc>
		</getInteractive>
		<screenToLocal set="method" line="208"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></screenToLocal>
		<dispatchEvent public="1" set="method" line="218">
			<f a="event:to">
				<c path="hxd.Event"/>
				<c path="hxd.Interactive"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</dispatchEvent>
		<handleEvent public="1" set="method" line="245">
			<f a="event:last">
				<c path="hxd.Event"/>
				<c path="hxd.Interactive"/>
				<c path="hxd.Interactive"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</handleEvent>
		<addEventListener public="1" set="method" line="328">
			<f a="f">
				<f a="">
					<c path="hxd.Event"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Add an event listener that will capture all events not caught by an h2d.Interactive</haxe_doc>
		</addEventListener>
		<removeEventListener public="1" set="method" line="335">
			<f a="f">
				<f a="">
					<c path="hxd.Event"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Remove a previously added event listener, return false it was not part of our event listeners.</haxe_doc>
		</removeEventListener>
		<startDrag public="1" set="method" line="349">
			<f a="onEvent:?onCancel:?refEvent">
				<f a="">
					<c path="hxd.Event"/>
					<x path="Void"/>
				</f>
				<f a=""><x path="Void"/></f>
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Start a drag and drop operation, sending all events to `onEvent` instead of the scene until `stopDrag()` is called.
		@param	onCancel	If defined, will be called when stopDrag is called
		@param	refEvent	For touch events, only capture events that matches the reference event touchId</haxe_doc>
		</startDrag>
		<stopDrag public="1" set="method" line="359">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stop the current drag and drop operation</haxe_doc>
		</stopDrag>
		<getFocus public="1" set="method" line="366">
			<f a=""><c path="h2d.Interactive"/></f>
			<haxe_doc>Get the currently focused Interactive</haxe_doc>
		</getFocus>
		<addEventTarget set="method" line="379">
			<f a="i">
				<c path="h2d.Interactive"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h2d</e></m></meta>
		</addEventTarget>
		<removeEventTarget set="method" line="431">
			<f a="i:?notify" v=":false">
				<c path="h2d.Interactive"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ notify : false }</e></m>
				<m n=":allow"><e>h2d</e></m>
			</meta>
		</removeEventTarget>
		<dispose public="1" set="method" line="440">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Dispose the scene and all its children, freeing used GPU memory</haxe_doc>
		</dispose>
		<setElapsedTime public="1" set="method" line="450">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Before render() or sync() are called, allow to set how much time has elapsed (in seconds) since the last frame in order to update scene animations.
		This is managed automatically by hxd.App</haxe_doc>
		</setElapsedTime>
		<drawImplTo set="method" line="454"><f a="s:t">
	<c path="h2d.Object"/>
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></drawImplTo>
		<syncOnly public="1" set="method" line="472">
			<f a="et">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronize the scene without rendering, updating all objects and animations by the given amount of time, in seconds.</haxe_doc>
		</syncOnly>
		<render public="1" set="method" line="485">
			<f a="engine">
				<c path="h3d.Engine"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Render the scene on screen. Internal usage only.</haxe_doc>
		</render>
		<sync set="method" line="497" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<captureBitmap public="1" set="method" line="507">
			<f a="?target">
				<c path="h2d.Tile"/>
				<c path="h2d.Bitmap"/>
			</f>
			<haxe_doc>Capture the scene into a texture and render the resulting Bitmap</haxe_doc>
		</captureBitmap>
		<new public="1" set="method" line="57">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Create a new scene. A default 2D scene is already available in `hxd.App.s2d`</haxe_doc>
		</new>
		<haxe_doc>h2d.Scene is the root class for a 2D scene. All root objects are added to it before being drawn on screen.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="h2d.Align" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Text.hx" module="h2d.Text">
		<Left/>
		<Right/>
		<Center/>
		<MultilineRight/>
		<MultilineCenter/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h2d.Tile" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/Tile.hx">
		<fromColor public="1" set="method" line="185" static="1">
			<f a="color:?width:?height:?alpha:?allocPos" v=":1:1:1.:">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<t path="h3d.impl.AllocPos"/>
				<c path="h2d.Tile"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1., height : 1, width : 1 }</e></m></meta>
		</fromColor>
		<fromBitmap public="1" set="method" line="193" static="1"><f a="bmp:?allocPos">
	<c path="hxd.BitmapData"/>
	<t path="h3d.impl.AllocPos"/>
	<c path="h2d.Tile"/>
</f></fromBitmap>
		<autoCut public="1" set="method" line="198" static="1"><f a="bmp:width:?height:?allocPos">
	<c path="hxd.BitmapData"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="h3d.impl.AllocPos"/>
	<a>
		<tiles><c path="Array"><c path="Array"><c path="h2d.Tile"/></c></c></tiles>
		<main><c path="h2d.Tile"/></main>
	</a>
</f></autoCut>
		<fromTexture public="1" set="method" line="229" static="1"><f a="t">
	<c path="h3d.mat.Texture"/>
	<c path="h2d.Tile"/>
</f></fromTexture>
		<fromPixels public="1" set="method" line="233" static="1"><f a="pixels:?allocPos">
	<c path="hxd.Pixels"/>
	<t path="h3d.impl.AllocPos"/>
	<c path="h2d.Tile"/>
</f></fromPixels>
		<isEmpty set="method" line="240" static="1"><f a="b:px:py:width:height:bg">
	<c path="hxd.BitmapData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Null"><a>
	<w><x path="Int"/></w>
	<h><x path="Int"/></h>
	<dy><x path="Int"/></dy>
	<dx><x path="Int"/></dx>
</a></x>
</f></isEmpty>
		<innerTex><c path="h3d.mat.Texture"/></innerTex>
		<u><x path="Float"/></u>
		<v><x path="Float"/></v>
		<u2><x path="Float"/></u2>
		<v2><x path="Float"/></v2>
		<dx public="1"><x path="Float"/></dx>
		<dy public="1"><x path="Float"/></dy>
		<x public="1" set="null"><x path="Float"/></x>
		<y public="1" set="null"><x path="Float"/></y>
		<width public="1" set="null"><x path="Float"/></width>
		<height public="1" set="null"><x path="Float"/></height>
		<getTexture public="1" get="inline" set="null" line="31"><f a=""><c path="h3d.mat.Texture"/></f></getTexture>
		<isDisposed public="1" set="method" line="35"><f a=""><x path="Bool"/></f></isDisposed>
		<setTexture set="method" line="39"><f a="tex">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></setTexture>
		<switchTexture public="1" get="inline" set="null" line="49"><f a="t">
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></switchTexture>
		<sub public="1" set="method" line="53">
			<f a="x:y:w:h:?dx:?dy" v="::::0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h2d.Tile"/>
			</f>
			<meta><m n=":value"><e>{ dy : 0., dx : 0. }</e></m></meta>
		</sub>
		<center public="1" set="method" line="57"><f a=""><c path="h2d.Tile"/></f></center>
		<setCenterRatio public="1" get="inline" set="null" line="61">
			<f a="?px:?py" v="0.5:0.5">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ py : 0.5, px : 0.5 }</e></m></meta>
		</setCenterRatio>
		<flipX public="1" set="method" line="66"><f a=""><x path="Void"/></f></flipX>
		<flipY public="1" set="method" line="71"><f a=""><x path="Void"/></f></flipY>
		<setPosition public="1" set="method" line="76"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPosition>
		<setSize public="1" set="method" line="88"><f a="w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setSize>
		<scaleToSize public="1" set="method" line="98"><f a="w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scaleToSize>
		<scrollDiscrete public="1" set="method" line="103"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollDiscrete>
		<dispose public="1" set="method" line="113"><f a=""><x path="Void"/></f></dispose>
		<clone public="1" set="method" line="118"><f a=""><c path="h2d.Tile"/></f></clone>
		<split public="1" set="method" line="131">
			<f a="?frames:?vertical" v="0:false">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="h2d.Tile"/></c>
			</f>
			<meta><m n=":value"><e>{ vertical : false, frames : 0 }</e></m></meta>
			<haxe_doc>Split horizontaly or verticaly the number of given frames</haxe_doc>
		</split>
		<gridFlatten public="1" set="method" line="153">
			<f a="size:?dx:?dy" v=":0.:0.">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><c path="h2d.Tile"/></c>
			</f>
			<meta><m n=":value"><e>{ dy : 0., dx : 0. }</e></m></meta>
			<haxe_doc>Split the tile into a list of tiles of Size x Size pixels.
		Unlike grid which is X/Y ordered, gridFlatten returns a single dimensional array ordered in Y/X.</haxe_doc>
		</gridFlatten>
		<grid public="1" set="method" line="160">
			<f a="size:?dx:?dy" v=":0.:0.">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><c path="Array"><c path="h2d.Tile"/></c></c>
			</f>
			<meta><m n=":value"><e>{ dy : 0., dx : 0. }</e></m></meta>
			<haxe_doc>Split the tile into a list of tiles of Size x Size pixels.</haxe_doc>
		</grid>
		<toString public="1" set="method" line="164"><f a=""><c path="String"/></f></toString>
		<upload set="method" line="168"><f a="bmp">
	<c path="hxd.BitmapData"/>
	<x path="Void"/>
</f></upload>
		<new set="method" line="20">
			<f a="tex:x:y:w:h:?dx:?dy" v=":::::0:0">
				<c path="h3d.mat.Texture"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dy : 0, dx : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h2d</e></m>
		</meta>
	</class>
	<class path="h2d._TileGroup.TileLayerContent" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/TileGroup.hx" private="1" module="h2d.TileGroup">
		<extends path="h3d.prim.Primitive"/>
		<tmp><x path="hxd.FloatBuffer"/></tmp>
		<xMin public="1"><x path="Float"/></xMin>
		<yMin public="1"><x path="Float"/></yMin>
		<xMax public="1"><x path="Float"/></xMax>
		<yMax public="1"><x path="Float"/></yMax>
		<clear public="1" set="method" line="15"><f a=""><x path="Void"/></f></clear>
		<isEmpty public="1" set="method" line="25"><f a=""><x path="Bool"/></f></isEmpty>
		<triCount public="1" set="method" line="29" override="1"><f a=""><x path="Int"/></f></triCount>
		<addColor public="1" get="inline" set="null" line="33"><f a="x:y:color:t">
	<x path="Float"/>
	<x path="Float"/>
	<c path="h3d.Vector"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></addColor>
		<add public="1" set="method" line="37"><f a="x:y:r:g:b:a:t">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></add>
		<addTransform public="1" set="method" line="82"><f a="x:y:sx:sy:r:c:t">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h3d.Vector"/>
	<c path="h2d.Tile"/>
	<x path="Void"/>
</f></addTransform>
		<addPoint public="1" set="method" line="151"><f a="x:y:color">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addPoint>
		<insertColor get="inline" set="null" line="163"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></insertColor>
		<rectColor public="1" get="inline" set="null" line="170"><f a="x:y:w:h:color">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rectColor>
		<rectGradient public="1" get="inline" set="null" line="200"><f a="x:y:w:h:ctl:ctr:cbl:cbr">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rectGradient>
		<fillArc public="1" get="inline" set="null" line="230"><f a="x:y:ray:c:start:end">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillArc>
		<fillCircle public="1" get="inline" set="null" line="264"><f a="x:y:radius:c">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fillCircle>
		<circle public="1" get="inline" set="null" line="296"><f a="x:y:ray:size:c">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></circle>
		<arc public="1" get="inline" set="null" line="325"><f a="x:y:ray:size:start:end:c">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></arc>
		<alloc public="1" set="method" line="369" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<flush public="1" get="inline" set="null" line="375"><f a=""><x path="Void"/></f></flush>
		<doRender public="1" set="method" line="379"><f a="engine:min:len">
	<c path="h3d.Engine"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></doRender>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.Tilemap" params="" file="./h2d/Tilemap.hx">
		<extends path="h2d.Drawable"/>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<tileWidth public="1" set="null"><x path="Int"/></tileWidth>
		<tileHeight public="1" set="null"><x path="Int"/></tileHeight>
		<batches><c path="Array"><c path="h2d.TilesetDisplay"/></c></batches>
		<tiles><c path="Array"><x path="Int"/></c></tiles>
		<tileCount><x path="Int"/></tileCount>
		<tilesets><c path="Array"><c path="h2d.Tileset"/></c></tilesets>
		<add public="1" set="method" line="35"><f a="x:y:gid">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></add>
		<getBoundsRec set="method" line="58" override="1"><f a="relativeTo:out:forSize">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getBoundsRec>
		<sync set="method" line="64" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<draw set="method" line="70" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="19"><f a="width:height:tileWidth:tileHeight:tilesets:?parent">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><c path="h2d.Tileset"/></c>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h2d.TilesetDisplay" params="" file="./h2d/Tilemap.hx" module="h2d.Tilemap">
		<tset><c path="h2d.Tileset"/></tset>
		<tile public="1"><c path="h2d.Tile"/></tile>
		<tmpBuf><x path="hxd.FloatBuffer"/></tmpBuf>
		<buffer><c path="h3d.Buffer"/></buffer>
		<bufferVertices><x path="Int"/></bufferVertices>
		<tileIndex><c path="Array"><x path="Int"/></c></tileIndex>
		<tileIds><c path="Array"><x path="Int"/></c></tileIds>
		<tileX><c path="Array"><x path="Float"/></c></tileX>
		<tileY><c path="Array"><x path="Float"/></c></tileY>
		<dirty><x path="Bool"/></dirty>
		<remove public="1" set="method" line="101"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></remove>
		<set public="1" set="method" line="111"><f a="index:tile:x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<sync public="1" set="method" line="129"><f a=""><x path="Void"/></f></sync>
		<flush set="method" line="134"><f a=""><x path="Void"/></f></flush>
		<render public="1" set="method" line="192"><f a="ctx:obj">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Drawable"/>
	<x path="Void"/>
</f></render>
		<dispose public="1" set="method" line="199"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="92"><f a="tileset">
	<c path="h2d.Tileset"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.Tileset" params="" file="./h2d/Tilemap.hx" module="h2d.Tilemap">
		<firstId public="1"><x path="Int"/></firstId>
		<source public="1"><c path="h2d.Tile"/></source>
		<tiles public="1"><c path="Array"><c path="h2d.Tile"/></c></tiles>
		<new public="1" set="method" line="216">
			<f a="source:firstId:tileWidth:tileHeight:?spacing:?margin:?dx:?dy" v="::::0:0:0:0">
				<c path="h2d.Tile"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dy : 0, dx : 0, margin : 0, spacing : 0 }</e></m></meta>
		</new>
	</class>
	<class path="h2d.col.Bounds" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/col/Bounds.hx">
		<fromValues public="1" get="inline" set="null" line="234" static="1"><f a="x0:y0:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.col.Bounds"/>
</f></fromValues>
		<fromPoints public="1" get="inline" set="null" line="243" static="1"><f a="min:max">
	<c path="h2d.col.Point"/>
	<c path="h2d.col.Point"/>
	<c path="h2d.col.Bounds"/>
</f></fromPoints>
		<xMin public="1"><x path="Float"/></xMin>
		<yMin public="1"><x path="Float"/></yMin>
		<xMax public="1"><x path="Float"/></xMax>
		<yMax public="1"><x path="Float"/></yMax>
		<x public="1" get="accessor" set="accessor"><x path="Float"/></x>
		<y public="1" get="accessor" set="accessor"><x path="Float"/></y>
		<width public="1" get="accessor" set="accessor"><x path="Float"/></width>
		<height public="1" get="accessor" set="accessor"><x path="Float"/></height>
		<toIBounds public="1" get="inline" set="null" line="22">
			<f a="?scale" v="1.">
				<x path="Float"/>
				<c path="h2d.col.IBounds"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1. }</e></m></meta>
		</toIBounds>
		<intersects public="1" get="inline" set="null" line="28"><f a="b">
	<c path="h2d.col.Bounds"/>
	<x path="Bool"/>
</f></intersects>
		<contains public="1" get="inline" set="null" line="32"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<addBounds public="1" get="inline" set="null" line="36"><f a="b">
	<c path="h2d.col.Bounds"/>
	<x path="Void"/>
</f></addBounds>
		<addPoint public="1" get="inline" set="null" line="43"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Void"/>
</f></addPoint>
		<addPos public="1" get="inline" set="null" line="50"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addPos>
		<set public="1" get="inline" set="null" line="57"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<setMin public="1" get="inline" set="null" line="64"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Void"/>
</f></setMin>
		<setMax public="1" get="inline" set="null" line="69"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Void"/>
</f></setMax>
		<doIntersect public="1" get="inline" set="null" line="74"><f a="b">
	<c path="h2d.col.Bounds"/>
	<x path="Void"/>
</f></doIntersect>
		<doUnion public="1" get="inline" set="null" line="81"><f a="b">
	<c path="h2d.col.Bounds"/>
	<x path="Void"/>
</f></doUnion>
		<intersection public="1" set="method" line="88"><f a="b">
	<c path="h2d.col.Bounds"/>
	<c path="h2d.col.Bounds"/>
</f></intersection>
		<union public="1" set="method" line="99"><f a="b">
	<c path="h2d.col.Bounds"/>
	<c path="h2d.col.Bounds"/>
</f></union>
		<load public="1" set="method" line="108"><f a="b">
	<c path="h2d.col.Bounds"/>
	<x path="Void"/>
</f></load>
		<scalePivot public="1" get="inline" set="null" line="115"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></scalePivot>
		<scaleCenter public="1" set="method" line="122"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleCenter>
		<rotate public="1" set="method" line="133"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<offset public="1" get="inline" set="null" line="144"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<getMin public="1" get="inline" set="null" line="151"><f a=""><c path="h2d.col.Point"/></f></getMin>
		<getCenter public="1" get="inline" set="null" line="155"><f a=""><c path="h2d.col.Point"/></f></getCenter>
		<getSize public="1" get="inline" set="null" line="159"><f a=""><c path="h2d.col.Point"/></f></getSize>
		<getMax public="1" get="inline" set="null" line="163"><f a=""><c path="h2d.col.Point"/></f></getMax>
		<isEmpty public="1" get="inline" set="null" line="167"><f a=""><x path="Bool"/></f></isEmpty>
		<empty public="1" get="inline" set="null" line="171"><f a=""><x path="Void"/></f></empty>
		<all public="1" get="inline" set="null" line="178"><f a=""><x path="Void"/></f></all>
		<clone public="1" get="inline" set="null" line="185"><f a=""><c path="h2d.col.Bounds"/></f></clone>
		<get_x get="inline" set="null" line="194"><f a=""><x path="Float"/></f></get_x>
		<get_y get="inline" set="null" line="198"><f a=""><x path="Float"/></f></get_y>
		<set_x get="inline" set="null" line="202"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y get="inline" set="null" line="207"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<get_width get="inline" set="null" line="212"><f a=""><x path="Float"/></f></get_width>
		<get_height get="inline" set="null" line="216"><f a=""><x path="Float"/></f></get_height>
		<set_width get="inline" set="null" line="220"><f a="w">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_height get="inline" set="null" line="225"><f a="h">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<toString public="1" set="method" line="230"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="18"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.col.Collider" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/col/Collider.hx" interface="1"><contains public="1" set="method"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Bool"/>
</f></contains></class>
	<class path="h2d.col.IBounds" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/col/IBounds.hx">
		<fromValues public="1" get="inline" set="null" line="203" static="1"><f a="x0:y0:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="h2d.col.IBounds"/>
</f></fromValues>
		<fromPoints public="1" get="inline" set="null" line="212" static="1"><f a="min:max">
	<c path="h2d.col.IPoint"/>
	<c path="h2d.col.IPoint"/>
	<c path="h2d.col.IBounds"/>
</f></fromPoints>
		<xMin public="1"><x path="Int"/></xMin>
		<yMin public="1"><x path="Int"/></yMin>
		<xMax public="1"><x path="Int"/></xMax>
		<yMax public="1"><x path="Int"/></yMax>
		<x public="1" get="accessor" set="accessor"><x path="Int"/></x>
		<y public="1" get="accessor" set="accessor"><x path="Int"/></y>
		<width public="1" get="accessor" set="accessor"><x path="Int"/></width>
		<height public="1" get="accessor" set="accessor"><x path="Int"/></height>
		<toBounds public="1" get="inline" set="null" line="22">
			<f a="?scale" v="1.">
				<x path="Float"/>
				<c path="h2d.col.Bounds"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1. }</e></m></meta>
		</toBounds>
		<intersects public="1" get="inline" set="null" line="26"><f a="b">
	<c path="h2d.col.IBounds"/>
	<x path="Bool"/>
</f></intersects>
		<contains public="1" get="inline" set="null" line="30"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Bool"/>
</f></contains>
		<addBounds public="1" get="inline" set="null" line="34"><f a="b">
	<c path="h2d.col.IBounds"/>
	<x path="Void"/>
</f></addBounds>
		<addPoint public="1" get="inline" set="null" line="41"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Void"/>
</f></addPoint>
		<addPos public="1" get="inline" set="null" line="48"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addPos>
		<set public="1" get="inline" set="null" line="55"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<setMin public="1" get="inline" set="null" line="62"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Void"/>
</f></setMin>
		<setMax public="1" get="inline" set="null" line="67"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Void"/>
</f></setMax>
		<doIntersect public="1" get="inline" set="null" line="72"><f a="b">
	<c path="h2d.col.IBounds"/>
	<x path="Void"/>
</f></doIntersect>
		<doUnion public="1" get="inline" set="null" line="79"><f a="b">
	<c path="h2d.col.IBounds"/>
	<x path="Void"/>
</f></doUnion>
		<intersection public="1" set="method" line="86"><f a="b">
	<c path="h2d.col.IBounds"/>
	<c path="h2d.col.Bounds"/>
</f></intersection>
		<union public="1" set="method" line="97"><f a="b">
	<c path="h2d.col.IBounds"/>
	<c path="h2d.col.Bounds"/>
</f></union>
		<load public="1" set="method" line="106"><f a="b">
	<c path="h2d.col.IBounds"/>
	<x path="Void"/>
</f></load>
		<offset public="1" get="inline" set="null" line="113"><f a="dx:dy">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></offset>
		<getMin public="1" get="inline" set="null" line="120"><f a=""><c path="h2d.col.IPoint"/></f></getMin>
		<getCenter public="1" get="inline" set="null" line="124"><f a=""><c path="h2d.col.IPoint"/></f></getCenter>
		<getSize public="1" get="inline" set="null" line="128"><f a=""><c path="h2d.col.IPoint"/></f></getSize>
		<getMax public="1" get="inline" set="null" line="132"><f a=""><c path="h2d.col.IPoint"/></f></getMax>
		<isEmpty public="1" get="inline" set="null" line="136"><f a=""><x path="Bool"/></f></isEmpty>
		<empty public="1" get="inline" set="null" line="140"><f a=""><x path="Void"/></f></empty>
		<all public="1" get="inline" set="null" line="147"><f a=""><x path="Void"/></f></all>
		<clone public="1" get="inline" set="null" line="154"><f a=""><c path="h2d.col.IBounds"/></f></clone>
		<get_x get="inline" set="null" line="163"><f a=""><x path="Int"/></f></get_x>
		<get_y get="inline" set="null" line="167"><f a=""><x path="Int"/></f></get_y>
		<set_x get="inline" set="null" line="171"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></set_x>
		<set_y get="inline" set="null" line="176"><f a="y">
	<x path="Int"/>
	<x path="Int"/>
</f></set_y>
		<get_width get="inline" set="null" line="181"><f a=""><x path="Int"/></f></get_width>
		<get_height get="inline" set="null" line="185"><f a=""><x path="Int"/></f></get_height>
		<set_width get="inline" set="null" line="189"><f a="w">
	<x path="Int"/>
	<x path="Int"/>
</f></set_width>
		<set_height get="inline" set="null" line="194"><f a="h">
	<x path="Int"/>
	<x path="Int"/>
</f></set_height>
		<toString public="1" set="method" line="199"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="18"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.col.IPoint" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/col/IPoint.hx">
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<toPoint public="1" get="inline" set="null" line="14">
			<f a="?scale" v="1.">
				<x path="Float"/>
				<c path="h2d.col.Point"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1. }</e></m></meta>
		</toPoint>
		<distanceSq public="1" get="inline" set="null" line="18"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Int"/>
</f></distanceSq>
		<distance public="1" get="inline" set="null" line="24"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Float"/>
</f></distance>
		<toString public="1" set="method" line="28"><f a=""><c path="String"/></f></toString>
		<sub public="1" get="inline" set="null" line="32"><f a="p">
	<c path="h2d.col.IPoint"/>
	<c path="h2d.col.Point"/>
</f></sub>
		<add public="1" get="inline" set="null" line="36"><f a="p">
	<c path="h2d.col.IPoint"/>
	<c path="h2d.col.Point"/>
</f></add>
		<dot public="1" get="inline" set="null" line="40"><f a="p">
	<c path="h2d.col.IPoint"/>
	<x path="Int"/>
</f></dot>
		<lengthSq public="1" get="inline" set="null" line="44"><f a=""><x path="Int"/></f></lengthSq>
		<length public="1" get="inline" set="null" line="48"><f a=""><x path="Float"/></f></length>
		<set public="1" get="inline" set="null" line="52"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<clone public="1" get="inline" set="null" line="57"><f a=""><c path="h2d.col.IPoint"/></f></clone>
		<new public="1" get="inline" set="null" line="9">
			<f a="?x:?y" v="0:0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.col.Matrix" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/col/Matrix.hx">
		<tmp expr="new Matrix()" line="9" static="1">
			<c path="h2d.col.Matrix"/>
			<meta><m n=":value"><e>new Matrix()</e></m></meta>
		</tmp>
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<identity public="1" get="inline" set="null" line="22"><f a=""><x path="Void"/></f></identity>
		<initTranslate public="1" get="inline" set="null" line="27"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initTranslate>
		<initScale public="1" get="inline" set="null" line="33"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initScale>
		<initRotate public="1" get="inline" set="null" line="38"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></initRotate>
		<invert public="1" set="method" line="49"><f a=""><x path="Void"/></f></invert>
		<getDeterminant public="1" get="inline" set="null" line="53"><f a=""><x path="Float"/></f></getDeterminant>
		<inverse public="1" set="method" line="57"><f a="m">
	<c path="h2d.col.Matrix"/>
	<x path="Void"/>
</f></inverse>
		<transform public="1" get="inline" set="null" line="70"><f a="pt">
	<c path="h2d.col.Point"/>
	<c path="h2d.col.Point"/>
</f></transform>
		<translate public="1" get="inline" set="null" line="74"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<prependTranslate public="1" get="inline" set="null" line="79"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependTranslate>
		<multiply public="1" set="method" line="84"><f a="a:b">
	<c path="h2d.col.Matrix"/>
	<c path="h2d.col.Matrix"/>
	<x path="Void"/>
</f></multiply>
		<scale public="1" get="inline" set="null" line="95"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<rotate public="1" set="method" line="104"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<toString public="1" set="method" line="109"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Affine 2D 2x3 matrix</haxe_doc>
	</class>
	<class path="h2d.col.Point" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/col/Point.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<toIPoint public="1" get="inline" set="null" line="14">
			<f a="?scale" v="1.">
				<x path="Float"/>
				<c path="h2d.col.IPoint"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1. }</e></m></meta>
		</toIPoint>
		<distanceSq public="1" get="inline" set="null" line="18"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Float"/>
</f></distanceSq>
		<distance public="1" get="inline" set="null" line="24"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Float"/>
</f></distance>
		<toString public="1" set="method" line="28"><f a=""><c path="String"/></f></toString>
		<sub public="1" get="inline" set="null" line="32"><f a="p">
	<c path="h2d.col.Point"/>
	<c path="h2d.col.Point"/>
</f></sub>
		<add public="1" get="inline" set="null" line="36"><f a="p">
	<c path="h2d.col.Point"/>
	<c path="h2d.col.Point"/>
</f></add>
		<dot public="1" get="inline" set="null" line="40"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Float"/>
</f></dot>
		<rotate public="1" get="inline" set="null" line="44"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<lengthSq public="1" get="inline" set="null" line="53"><f a=""><x path="Float"/></f></lengthSq>
		<length public="1" get="inline" set="null" line="57"><f a=""><x path="Float"/></f></length>
		<normalize public="1" set="method" line="61"><f a=""><x path="Void"/></f></normalize>
		<normalizeFast public="1" get="inline" set="null" line="68"><f a=""><x path="Void"/></f></normalizeFast>
		<set public="1" get="inline" set="null" line="75"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<load public="1" get="inline" set="null" line="80"><f a="p">
	<c path="h2d.col.Point"/>
	<x path="Void"/>
</f></load>
		<scale public="1" get="inline" set="null" line="85"><f a="f">
	<x path="Float"/>
	<c path="h2d.col.Point"/>
</f></scale>
		<clone public="1" get="inline" set="null" line="91"><f a=""><c path="h2d.col.Point"/></f></clone>
		<new public="1" get="inline" set="null" line="9">
			<f a="?x:?y" v="0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0., x : 0. }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h2d.filter.Filter" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h2d/filter/Filter.hx">
		<autoBounds public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</autoBounds>
		<boundsExtend public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</boundsExtend>
		<smooth public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</smooth>
		<enable public="1" get="accessor" set="accessor" expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":isVar"/>
			</meta>
		</enable>
		<get_enable set="method" line="16"><f a=""><x path="Bool"/></f></get_enable>
		<set_enable set="method" line="17"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enable>
		<sync public="1" set="method" line="19"><f a="ctx:s">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></sync>
		<bind public="1" set="method" line="22"><f a="s">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></bind>
		<unbind public="1" set="method" line="25"><f a="s">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></unbind>
		<getBounds public="1" set="method" line="28"><f a="s:bounds">
	<c path="h2d.Object"/>
	<c path="h2d.col.Bounds"/>
	<x path="Void"/>
</f></getBounds>
		<draw public="1" set="method" line="36"><f a="ctx:input">
	<c path="h2d.RenderContext"/>
	<c path="h2d.Tile"/>
	<c path="h2d.Tile"/>
</f></draw>
		<new set="method" line="13"><f a=""><x path="Void"/></f></new>
		<haxe_doc>The base filter class, you can extend it in order to define your own filters, although ShaderFilter will be the most straightforward way to define simple custom filter.</haxe_doc>
	</class>
	<class path="h2d.ui.Button" params="" file="./h2d/ui/Button.hx">
		<extends path="h2d.Interactive"/>
		<bg><c path="h2d.Tile"/></bg>
		<hover><c path="h2d.Tile"/></hover>
		<down><c path="h2d.Tile"/></down>
		<pressed><x path="Bool"/></pressed>
		<draw set="method" line="36" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<handleEvent public="1" set="method" line="48" override="1"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></handleEvent>
		<new public="1" set="method" line="19"><f a="w:h:label:?parent">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Primitive Button with label.
  Can be used for fast UI creation for debugging purposes.</haxe_doc>
	</class>
	<class path="h2d.ui.Checkbox" params="" file="./h2d/ui/Checkbox.hx">
		<extends path="h2d.Interactive"/>
		<bg static="1"><c path="h2d.Tile"/></bg>
		<check static="1"><c path="h2d.Tile"/></check>
		<checked public="1">
			<x path="Bool"/>
			<haxe_doc>Current checkbox state. Does not trigger `onChange` when changed, use `setChecked` function instead if even is required.</haxe_doc>
		</checked>
		<setChecked public="1" set="method" line="47">
			<f a="v">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets `checked` flag and triggers `onChange` if value changes.</haxe_doc>
		</setChecked>
		<draw set="method" line="56" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<handleEvent public="1" set="method" line="62" override="1"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></handleEvent>
		<onChange public="1" set="dynamic" line="78"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></onChange>
		<new public="1" set="method" line="20"><f a="?parent">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Primitive checkbox.
  Can be used for fast UI creation for debugging purposes.</haxe_doc>
	</class>
	<class path="h2d.ui.EventInteractive" params="" file="./h2d/ui/EventInteractive.hx">
		<extends path="h2d.Interactive"/>
		<onOverEvent public="1" expr="new EventSignal1()">
			<c path="hxd.heeps.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onOverEvent>
		<onOutEvent public="1" expr="new EventSignal1()">
			<c path="hxd.heeps.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onOutEvent>
		<onPushEvent public="1" expr="new EventSignal1()">
			<c path="hxd.heeps.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onPushEvent>
		<onReleaseEvent public="1" expr="new EventSignal1()">
			<c path="hxd.heeps.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onReleaseEvent>
		<onReleaseOutsideEvent public="1" expr="new EventSignal1()">
			<c path="hxd.heeps.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onReleaseOutsideEvent>
		<onClickEvent public="1" expr="new EventSignal1()">
			<c path="hxd.heeps.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onClickEvent>
		<onMoveEvent public="1" expr="new EventSignal1()">
			<c path="hxd.heeps.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onMoveEvent>
		<onWheelEvent public="1" expr="new EventSignal1()">
			<c path="hxd.heeps.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onWheelEvent>
		<onFocusEvent public="1" expr="new EventSignal1()">
			<c path="hxd.heeps.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onFocusEvent>
		<onFocusLostEvent public="1" expr="new EventSignal1()">
			<c path="hxd.heeps.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onFocusLostEvent>
		<onKeyUpEvent public="1" expr="new EventSignal1()">
			<c path="hxd.heeps.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onKeyUpEvent>
		<onKeyDownEvent public="1" expr="new EventSignal1()">
			<c path="hxd.heeps.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onKeyDownEvent>
		<onCheckEvent public="1" expr="new EventSignal1()">
			<c path="hxd.heeps.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onCheckEvent>
		<onTextInputEvent public="1" expr="new EventSignal1()">
			<c path="hxd.heeps.EventSignal1"><c path="hxd.Event"/></c>
			<meta><m n=":value"><e>new EventSignal1()</e></m></meta>
		</onTextInputEvent>
		<handleEvent public="1" set="method" line="29" override="1"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></handleEvent>
		<new public="1" set="method" line="11"><f a="width:height:?parent:?shape">
	<x path="Float"/>
	<x path="Float"/>
	<c path="h2d.Object"/>
	<c path="h2d.col.Collider"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Simple wrapper to Interactive that allows multiple subscriptions to on* events.
  Overriding on* functions still possible.</haxe_doc>
	</class>
	<class path="h2d.ui.ManifestProgress" params="" file="./h2d/ui/ManifestProgress.hx">
		<extends path="h2d.Object"/>
		<g><c path="h2d.Graphics"/></g>
		<text><c path="h2d.Text"/></text>
		<loader><c path="hxd.res.ManifestLoader"/></loader>
		<color><x path="Int"/></color>
		<onLoaded><f a=""><x path="Void"/></f></onLoaded>
		<start public="1" set="method" line="29"><f a=""><x path="Void"/></f></start>
		<setProgress set="method" line="50"><f a="b:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setProgress>
		<finish set="method" line="60"><f a=""><x path="Void"/></f></finish>
		<showFileName set="method" line="67"><f a="f">
	<c path="hxd.fs.ManifestEntry"/>
	<x path="Void"/>
</f></showFileName>
		<fileLoaded set="method" line="72"><f a="f">
	<c path="hxd.fs.ManifestEntry"/>
	<x path="Void"/>
</f></fileLoaded>
		<fileProgress set="method" line="78"><f a="f:b:t">
	<c path="hxd.fs.ManifestEntry"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fileProgress>
		<new public="1" set="method" line="15">
			<f a="loader:?color:onLoaded:?parent" v=":0xffffff::">
				<c path="hxd.res.ManifestLoader"/>
				<x path="Int"/>
				<f a=""><x path="Void"/></f>
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ color : 0xffffff }</e></m></meta>
		</new>
	</class>
	<class path="h2d.ui.RadioButton" params="" file="./h2d/ui/RadioButton.hx">
		<extends path="h2d.ui.Checkbox"/>
		<bg static="1"><c path="h2d.Tile"/></bg>
		<check static="1"><c path="h2d.Tile"/></check>
		<group public="1" set="null">
			<c path="h2d.ui.RadioGroup"/>
			<haxe_doc>Group this Radiobutton belongs to.</haxe_doc>
		</group>
		<index public="1" set="null">
			<x path="Int"/>
			<haxe_doc>Index of this checkbox in the group.</haxe_doc>
		</index>
		<setChecked public="1" set="method" line="56" override="1"><f a="v">
	<x path="Bool"/>
	<x path="Void"/>
</f></setChecked>
		<draw set="method" line="61" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<onRadio public="1" set="dynamic" line="72">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Triggers when RadioGroup changes selected button.
    Happens on all buttons.</haxe_doc>
		</onRadio>
		<new public="1" set="method" line="24"><f a="?parent:?group">
	<c path="h2d.Object"/>
	<c path="h2d.ui.RadioGroup"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Primitive radio button.
  Can be used for fast UI creation for debugging purposes.</haxe_doc>
	</class>
	<class path="h2d.ui.RadioGroup" params="" file="./h2d/ui/RadioButton.hx" module="h2d.ui.RadioButton">
		<buttons><c path="Array"><c path="h2d.ui.RadioButton"/></c></buttons>
		<selectedIndex public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>Currently selected index.
    Always triggers onChange and onRadio in buttons when changed.</haxe_doc>
		</selectedIndex>
		<get_selectedIndex set="method" line="102"><f a=""><x path="Int"/></f></get_selectedIndex>
		<set_selectedIndex set="method" line="108"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_selectedIndex>
		<add public="1" set="method" line="133">
			<f a="radio">
				<c path="h2d.ui.RadioButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds new RadioButton to the group.</haxe_doc>
		</add>
		<remove public="1" set="method" line="144">
			<f a="radio">
				<c path="h2d.ui.RadioButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes RadioButton from the group.</haxe_doc>
		</remove>
		<onChange public="1" set="dynamic" line="157">
			<f a="index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Triggers when selected index changes.</haxe_doc>
		</onChange>
		<new public="1" set="method" line="93"><f a="?buttons">
	<c path="Array"><c path="h2d.ui.RadioButton"/></c>
	<x path="Void"/>
</f></new>
		<haxe_doc>A group of RadioButtons for, duh, grouping of RadioButtons.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>h2d.ui.RadioButton</e></m>
		</meta>
	</class>
	<class path="h2d.ui.ScrollArea" params="" file="./h2d/ui/ScrollArea.hx">
		<extends path="h2d.Mask"/>
		<scrollX public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</scrollX>
		<scrollY public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</scrollY>
		<scrollVertically public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</scrollVertically>
		<scrollHorizontally public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</scrollHorizontally>
		<scrollBounds public="1"><c path="h2d.col.Bounds"/></scrollBounds>
		<scrollStep public="1"><x path="Int"/></scrollStep>
		<set_scrollX set="method" line="29"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scrollX>
		<set_scrollY set="method" line="36"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scrollY>
		<scrollBy set="method" line="43"><f a="deltaX:deltaY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scrollBy>
		<calcAbsPos set="method" line="49" override="1"><f a=""><x path="Void"/></f></calcAbsPos>
		<globalToLocal public="1" set="method" line="56" override="1"><f a="pt">
	<c path="h2d.col.Point"/>
	<c path="h2d.col.Point"/>
</f></globalToLocal>
		<drawRec set="method" line="63" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></drawRec>
		<objDrawRec set="method" line="109"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></objDrawRec>
		<new public="1" set="method" line="22">
			<f a="width:height:?scrollStep:?bounds:?parent" v="::16::">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="h2d.col.Bounds"/>
				<c path="h2d.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scrollStep : 16 }</e></m></meta>
		</new>
		<haxe_doc>Scrollable container.</haxe_doc>
	</class>
	<class path="h2d.ui.ScrollText" params="" file="./h2d/ui/ScrollText.hx">
		<extends path="h2d.Mask"/>
		<text public="1">
			<c path="h2d.Text"/>
			<haxe_doc>Reference to Text instance.</haxe_doc>
		</text>
		<htmlText public="1">
			<c path="h2d.HtmlText"/>
			<haxe_doc>Reference to HtmlText instance if passed one at creation.</haxe_doc>
		</htmlText>
		<maxScrollV public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>Maxiumm possible `scrollV` value.</haxe_doc>
		</maxScrollV>
		<scrollV public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>Current scrollV value. Starts at 0, up to maxScrollV.</haxe_doc>
		</scrollV>
		<bottomScrollV public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>Bottom of current scrollV value. Represents bottom of visible Text area.</haxe_doc>
		</bottomScrollV>
		<scrollStep public="1"><x path="Float"/></scrollStep>
		<scrollVLimit get="inline" set="null" line="49"><f a=""><x path="Int"/></f></scrollVLimit>
		<get_maxScrollV set="method" line="54"><f a=""><x path="Int"/></f></get_maxScrollV>
		<get_bottomScrollV set="method" line="61"><f a=""><x path="Float"/></f></get_bottomScrollV>
		<set_scrollV set="method" line="69"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scrollV>
		<new public="1" set="method" line="39"><f a="text:width:height:?parent">
	<c path="h2d.Text"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Vertically scrollable text container.
  Useful for creation of walls of text.</haxe_doc>
	</class>
	<class path="h2d.ui.SimpleButton" params="" file="./h2d/ui/SimpleButton.hx">
		<extends path="h2d.Interactive"/>
		<idle><c path="h2d.Object"/></idle>
		<hover><c path="h2d.Object"/></hover>
		<press><c path="h2d.Object"/></press>
		<disabled><c path="h2d.Object"/></disabled>
		<pressed><x path="Bool"/></pressed>
		<over><x path="Bool"/></over>
		<enabled public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>Button availability state. If `false`, does not Interact with mouse and showns `disabled` state.</haxe_doc>
		</enabled>
		<set_enabled set="method" line="46"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enabled>
		<updateState set="method" line="54"><f a=""><x path="Void"/></f></updateState>
		<handleEvent public="1" set="method" line="81" override="1"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></handleEvent>
		<new public="1" set="method" line="26"><f a="w:h:idle:hover:press:?disabled:?parent:?shape">
	<x path="Int"/>
	<x path="Int"/>
	<c path="h2d.Object"/>
	<c path="h2d.Object"/>
	<c path="h2d.Object"/>
	<c path="h2d.Object"/>
	<c path="h2d.Object"/>
	<c path="h2d.col.Collider"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>A simple button with simple premade 4 states.
  Based on openfl.display.SimpleButton design.</haxe_doc>
	</class>
	<enum path="h3d.BufferFlag" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Buffer.hx" module="h3d.Buffer">
		<Dynamic><haxe_doc>Indicate that the buffer content will be often modified.</haxe_doc></Dynamic>
		<Triangles><haxe_doc>The buffer contains only triangles. Imply Managed. Make sure the position is aligned on 3 vertices multiples.</haxe_doc></Triangles>
		<Quads><haxe_doc>The buffer contains only quads. Imply Managed. Make sure the position is aligned on 4 vertices multiples.</haxe_doc></Quads>
		<Managed><haxe_doc>Will allocate the memory as part of an shared buffer pool, preventing a lot of small GPU buffers to be allocated.</haxe_doc></Managed>
		<RawFormat><haxe_doc>Directly map the buffer content to the shader inputs, without assuming [pos:vec3,normal:vec3,uv:vec2] default prefix.</haxe_doc></RawFormat>
		<NoAlloc><haxe_doc>Used internaly</haxe_doc></NoAlloc>
		<UniformBuffer><haxe_doc>Used for shader input buffer</haxe_doc></UniformBuffer>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h3d.Buffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Buffer.hx">
		<GUID public="1" expr="0" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</GUID>
		<ofFloats public="1" set="method" line="139" static="1"><f a="v:stride:?flags:?allocPos">
	<x path="hxd.FloatBuffer"/>
	<x path="Int"/>
	<c path="Array"><e path="h3d.BufferFlag"/></c>
	<t path="h3d.impl.AllocPos"/>
	<c path="h3d.Buffer"/>
</f></ofFloats>
		<ofSubFloats public="1" set="method" line="146" static="1"><f a="v:stride:vertices:?flags:?allocPos">
	<x path="hxd.FloatBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><e path="h3d.BufferFlag"/></c>
	<t path="h3d.impl.AllocPos"/>
	<c path="h3d.Buffer"/>
</f></ofSubFloats>
		<id public="1"><x path="Int"/></id>
		<buffer public="1" set="null"><c path="h3d.impl.ManagedBuffer"/></buffer>
		<position public="1" set="null"><x path="Int"/></position>
		<vertices public="1" set="null"><x path="Int"/></vertices>
		<next public="1" set="null"><c path="h3d.Buffer"/></next>
		<flags public="1" set="null"><x path="haxe.EnumFlags"><e path="h3d.BufferFlag"/></x></flags>
		<isDisposed public="1" set="method" line="68"><f a=""><x path="Bool"/></f></isDisposed>
		<dispose public="1" set="method" line="72"><f a=""><x path="Void"/></f></dispose>
		<totalVertices public="1" set="method" line="83">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the total number of vertices including the potential next buffers if it is split.</haxe_doc>
		</totalVertices>
		<uploadVector public="1" set="method" line="93">
			<f a="buf:bufPos:vertices:?startVertice" v=":::0">
				<x path="hxd.FloatBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ startVertice : 0 }</e></m></meta>
		</uploadVector>
		<uploadBytes public="1" set="method" line="110"><f a="data:dataPos:vertices">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadBytes>
		<readBytes public="1" set="method" line="122">
			<f a="bytes:bytesPosition:vertices:?startVertice" v=":::0">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ startVertice : 0 }</e></m></meta>
		</readBytes>
		<new public="1" set="method" line="48"><f a="vertices:stride:?flags:?allocPos">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><e path="h3d.BufferFlag"/></c>
	<t path="h3d.impl.AllocPos"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.BufferOffset" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Buffer.hx" module="h3d.Buffer">
		<UID expr="0" line="164" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UID>
		<id public="1"><x path="Int"/></id>
		<buffer public="1"><c path="h3d.Buffer"/></buffer>
		<offset public="1"><x path="Int"/></offset>
		<next public="1"><c path="h3d.BufferOffset"/></next>
		<dispose public="1" set="method" line="171"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="166"><f a="buffer:offset">
	<c path="h3d.Buffer"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.Camera" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Camera.hx">
		<zoom public="1"><x path="Float"/></zoom>
		<screenRatio public="1">
			<x path="Float"/>
			<haxe_doc>The screenRatio represents the W/H screen ratio.</haxe_doc>
		</screenRatio>
		<fovY public="1">
			<x path="Float"/>
			<haxe_doc>The vertical FieldOfView, in degrees.
		Usually cameras are using an horizontal FOV, but the value will change depending on the screen ratio.
		For instance a 4:3 screen will have a lower horizontal FOV than a 16:9 one, however the vertical FOV remains constant.
		Use setFovX to initialize fovY based on an horizontal FOV and an initial screen ratio.</haxe_doc>
		</fovY>
		<zNear public="1"><x path="Float"/></zNear>
		<zFar public="1"><x path="Float"/></zFar>
		<orthoBounds public="1">
			<c path="h3d.col.Bounds"/>
			<haxe_doc>Set orthographic bounds.</haxe_doc>
		</orthoBounds>
		<rightHanded public="1"><x path="Bool"/></rightHanded>
		<mproj public="1"><c path="h3d.Matrix"/></mproj>
		<mcam public="1"><c path="h3d.Matrix"/></mcam>
		<m public="1"><c path="h3d.Matrix"/></m>
		<pos public="1"><c path="h3d.Vector"/></pos>
		<up public="1"><c path="h3d.Vector"/></up>
		<target public="1"><c path="h3d.Vector"/></target>
		<viewX public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</viewX>
		<viewY public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</viewY>
		<follow public="1"><a>
	<target><c path="h3d.scene.Object"/></target>
	<pos><c path="h3d.scene.Object"/></pos>
</a></follow>
		<frustum public="1" set="null" expr="new h3d.col.Frustum()">
			<c path="h3d.col.Frustum"/>
			<meta><m n=":value"><e>new h3d.col.Frustum()</e></m></meta>
		</frustum>
		<minv><c path="h3d.Matrix"/></minv>
		<miview><c path="h3d.Matrix"/></miview>
		<needInv><x path="Bool"/></needInv>
		<setFovX public="1" set="method" line="69">
			<f a="fovX:withRatio">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the vertical fov based on a given horizontal fov (in degrees) for a specified screen ratio.</haxe_doc>
		</setFovX>
		<getFovX public="1" set="method" line="77">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Calculate the current horizontal fov (in degrees).</haxe_doc>
		</getFovX>
		<clone public="1" set="method" line="84"><f a=""><c path="h3d.Camera"/></f></clone>
		<getInverseViewProj public="1" set="method" line="96">
			<f a=""><c path="h3d.Matrix"/></f>
			<haxe_doc>Returns the inverse of the camera matrix view and projection. Cache the result until the next update().</haxe_doc>
		</getInverseViewProj>
		<getInverseView public="1" set="method" line="108">
			<f a=""><c path="h3d.Matrix"/></f>
			<haxe_doc>Returns the inverse of the camera matrix view only. Cache the result until the next update().</haxe_doc>
		</getInverseView>
		<setCubeMap public="1" set="method" line="121">
			<f a="face:position">
				<x path="Int"/>
				<c path="h3d.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Setup camera for cubemap rendering on the given face.</haxe_doc>
		</setCubeMap>
		<unproject public="1" set="method" line="142">
			<f a="screenX:screenY:camZ">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h3d.Vector"/>
			</f>
			<haxe_doc>Transforms a 2D screen position into the 3D one according to the current camera.
		The screenX and screenY values must be in the [-1,1] range.
		The camZ value represents the normalized z in the frustum in the [0,1] range.
		[unproject] can be used to get the ray from the camera position to a given screen position by using two different camZ values.
		For instance the 3D ray between unproject(0,0,0) and unproject(0,0,1) is the center axis of the 3D frustum.</haxe_doc>
		</unproject>
		<rayFromScreen public="1" set="method" line="148"><f a="pixelX:pixelY">
	<x path="Float"/>
	<x path="Float"/>
	<c path="h3d.col.Ray"/>
</f></rayFromScreen>
		<update public="1" set="method" line="155"><f a=""><x path="Void"/></f></update>
		<getFrustumCorners public="1" set="method" line="187"><f a=""><c path="Array"><c path="h3d.Vector"/></c></f></getFrustumCorners>
		<lostUp public="1" set="method" line="194"><f a=""><x path="Bool"/></f></lostUp>
		<movePosAxis public="1" set="method" line="200">
			<f a="dx:dy:?dz" v="::0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dz : 0. }</e></m></meta>
		</movePosAxis>
		<moveTargetAxis public="1" set="method" line="208">
			<f a="dx:dy:?dz" v="::0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dz : 0. }</e></m></meta>
		</moveTargetAxis>
		<forward public="1" set="method" line="216">
			<f a="?speed" v="1.">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ speed : 1. }</e></m></meta>
		</forward>
		<backward public="1" set="method" line="225">
			<f a="?speed" v="1.">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ speed : 1. }</e></m></meta>
		</backward>
		<makeCameraMatrix set="method" line="234"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></makeCameraMatrix>
		<makeFrustumMatrix set="method" line="266"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></makeFrustumMatrix>
		<project public="1" set="method" line="324">
			<f a="x:y:z:screenWidth:screenHeight:?snapToPixel" v=":::::true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="h3d.Vector"/>
			</f>
			<meta><m n=":value"><e>{ snapToPixel : true }</e></m></meta>
			<haxe_doc>Project a 3D point into the 2D screen. Make sure to update() the camera if it's been moved before using that.</haxe_doc>
		</project>
		<load public="1" set="method" line="336"><f a="cam">
	<c path="h3d.Camera"/>
	<x path="Void"/>
</f></load>
		<new public="1" set="method" line="50">
			<f a="?fovY:?zoom:?screenRatio:?zNear:?zFar:?rightHanded" v="25.:1.:1.333333:0.02:4000.:false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ rightHanded : false, zFar : 4000., zNear : 0.02, screenRatio : 1.333333, zoom : 1., fovY : 25. }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d._Engine.TargetTmp" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Engine.hx" private="1" module="h3d.Engine">
		<t public="1"><c path="h3d.mat.Texture"/></t>
		<next public="1"><c path="h3d._Engine.TargetTmp"/></next>
		<layer public="1"><x path="Int"/></layer>
		<mipLevel public="1"><x path="Int"/></mipLevel>
		<new public="1" set="method" line="9"><f a="t:n:l:m">
	<c path="h3d.mat.Texture"/>
	<c path="h3d._Engine.TargetTmp"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.Engine" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Engine.hx">
		<CURRENT expr="null" line="83" static="1">
			<c path="h3d.Engine"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</CURRENT>
		<getCurrent public="1" get="inline" set="null" line="90" static="1"><f a=""><c path="h3d.Engine"/></f></getCurrent>
		<driver public="1" set="null"><c path="h3d.impl.Driver"/></driver>
		<mem public="1" set="null"><c path="h3d.impl.MemoryManager"/></mem>
		<hardware public="1" set="null"><x path="Bool"/></hardware>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<debug public="1" set="accessor"><x path="Bool"/></debug>
		<drawTriangles public="1" set="null"><x path="Int"/></drawTriangles>
		<drawCalls public="1" set="null"><x path="Int"/></drawCalls>
		<shaderSwitches public="1" set="null"><x path="Int"/></shaderSwitches>
		<backgroundColor public="1" expr="0xFF000000">
			<x path="Null"><x path="Int"/></x>
			<meta><m n=":value"><e>0xFF000000</e></m></meta>
		</backgroundColor>
		<autoResize public="1"><x path="Bool"/></autoResize>
		<fullScreen public="1" set="accessor"><x path="Bool"/></fullScreen>
		<fps public="1" get="accessor" set="null"><x path="Float"/></fps>
		<realFps><x path="Float"/></realFps>
		<lastTime><x path="Float"/></lastTime>
		<antiAlias><x path="Int"/></antiAlias>
		<tmpVector expr="new h3d.Vector()">
			<c path="h3d.Vector"/>
			<meta><m n=":value"><e>new h3d.Vector()</e></m></meta>
		</tmpVector>
		<window><c path="hxd.Window"/></window>
		<targetTmp><c path="h3d._Engine.TargetTmp"/></targetTmp>
		<targetStack><c path="h3d._Engine.TargetTmp"/></targetStack>
		<currentTargetTex><c path="h3d.mat.Texture"/></currentTargetTex>
		<currentTargetLayer><x path="Int"/></currentTargetLayer>
		<currentTargetMip><x path="Int"/></currentTargetMip>
		<needFlushTarget><x path="Bool"/></needFlushTarget>
		<nullTexture><c path="h3d.mat.Texture"/></nullTexture>
		<textureColorCache expr="new Map&lt;Int,h3d.mat.Texture&gt;()">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="h3d.mat.Texture"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,h3d.mat.Texture>()]]></e></m></meta>
		</textureColorCache>
		<ready public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</ready>
		<resCache expr="new Map&lt;{ },Dynamic&gt;()">
			<x path="haxe.ds.Map">
				<a/>
				<d/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<{ },Dynamic>()]]></e></m>
				<m n=":allow"><e>hxd.res</e></m>
			</meta>
		</resCache>
		<setDriver public="1" set="method" line="85"><f a="d">
	<c path="h3d.impl.Driver"/>
	<x path="Void"/>
</f></setDriver>
		<setCurrent public="1" get="inline" set="null" line="94"><f a=""><x path="Void"/></f></setCurrent>
		<init public="1" set="method" line="98"><f a=""><x path="Void"/></f></init>
		<driverName public="1" set="method" line="102">
			<f a="?details" v="false">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ details : false }</e></m></meta>
		</driverName>
		<selectShader public="1" set="method" line="106"><f a="shader">
	<c path="hxsl.RuntimeShader"/>
	<x path="Void"/>
</f></selectShader>
		<selectMaterial public="1" set="method" line="112"><f a="pass">
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></selectMaterial>
		<uploadShaderBuffers public="1" set="method" line="116"><f a="buffers:which">
	<c path="h3d.shader.Buffers"/>
	<x path="h3d.shader.BufferKind"/>
	<x path="Void"/>
</f></uploadShaderBuffers>
		<selectBuffer set="method" line="120"><f a="buf">
	<c path="h3d.Buffer"/>
	<x path="Bool"/>
</f></selectBuffer>
		<renderTriBuffer public="1" get="inline" set="null" line="128">
			<f a="b:?start:?max" v=":0:-1">
				<c path="h3d.Buffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ max : -1, start : 0 }</e></m></meta>
		</renderTriBuffer>
		<renderQuadBuffer public="1" get="inline" set="null" line="132">
			<f a="b:?start:?max" v=":0:-1">
				<c path="h3d.Buffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ max : -1, start : 0 }</e></m></meta>
		</renderQuadBuffer>
		<renderBuffer set="method" line="137">
			<f a="b:indexes:vertPerTri:?startTri:?drawTri" v=":::0:-1">
				<c path="h3d.Buffer"/>
				<c path="h3d.Indexes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ drawTri : -1, startTri : 0 }</e></m></meta>
		</renderBuffer>
		<renderIndexed public="1" set="method" line="172">
			<f a="b:indexes:?startTri:?drawTri" v="::0:-1">
				<c path="h3d.Buffer"/>
				<c path="h3d.Indexes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ drawTri : -1, startTri : 0 }</e></m></meta>
		</renderIndexed>
		<renderMultiBuffers public="1" set="method" line="187">
			<f a="buffers:indexes:?startTri:?drawTri" v="::0:-1">
				<c path="h3d.BufferOffset"/>
				<c path="h3d.Indexes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ drawTri : -1, startTri : 0 }</e></m></meta>
		</renderMultiBuffers>
		<renderInstanced public="1" set="method" line="203"><f a="buffers:indexes:commands">
	<c path="h3d.BufferOffset"/>
	<c path="h3d.Indexes"/>
	<c path="h3d.impl.InstanceBuffer"/>
	<x path="Void"/>
</f></renderInstanced>
		<set_debug set="method" line="215"><f a="d">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_debug>
		<onCreate set="method" line="221"><f a="disposed">
	<x path="Bool"/>
	<x path="Void"/>
</f></onCreate>
		<onContextLost public="1" set="dynamic" line="244"><f a=""><x path="Void"/></f></onContextLost>
		<onReady public="1" set="dynamic" line="247"><f a=""><x path="Void"/></f></onReady>
		<onWindowResize set="method" line="250"><f a=""><x path="Void"/></f></onWindowResize>
		<set_fullScreen set="method" line="259"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_fullScreen>
		<onResized public="1" set="dynamic" line="266"><f a=""><x path="Void"/></f></onResized>
		<resize public="1" set="method" line="269"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<begin public="1" set="method" line="278"><f a=""><x path="Bool"/></f></begin>
		<hasFeature public="1" set="method" line="295"><f a="f">
	<e path="h3d.impl.Feature"/>
	<x path="Bool"/>
</f></hasFeature>
		<end public="1" set="method" line="299"><f a=""><x path="Void"/></f></end>
		<getCurrentTarget public="1" set="method" line="303"><f a=""><x path="Null"><c path="h3d.mat.Texture"/></x></f></getCurrentTarget>
		<pushTarget public="1" set="method" line="307">
			<f a="tex:?layer:?mipLevel" v=":0:0">
				<c path="h3d.mat.Texture"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mipLevel : 0, layer : 0 }</e></m></meta>
		</pushTarget>
		<updateNeedFlush set="method" line="322"><f a=""><x path="Void"/></f></updateNeedFlush>
		<pushTargets public="1" set="method" line="330"><f a="textures">
	<c path="Array"><c path="h3d.mat.Texture"/></c>
	<x path="Void"/>
</f></pushTargets>
		<popTarget public="1" set="method" line="338"><f a=""><x path="Void"/></f></popTarget>
		<flushTarget get="inline" set="null" line="350"><f a=""><x path="Void"/></f></flushTarget>
		<doFlushTarget set="method" line="354"><f a=""><x path="Void"/></f></doFlushTarget>
		<clearF public="1" set="method" line="368"><f a="color:?depth:?stencil">
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clearF>
		<clear public="1" set="method" line="373"><f a="?color:?depth:?stencil">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<setRenderZone public="1" set="method" line="384">
			<f a="?x:?y:?width:?height" v="0:0:-1:-1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : -1, width : -1, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* Sets up a scissored zone to eliminate pixels outside the given range.
	 * Call with no parameters to reset to full viewport.</haxe_doc>
		</setRenderZone>
		<render public="1" set="method" line="389"><f a="obj">
	<a><render set="method"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render></a>
	<x path="Bool"/>
</f></render>
		<dispose public="1" set="method" line="406"><f a=""><x path="Void"/></f></dispose>
		<get_fps set="method" line="411"><f a=""><x path="Float"/></f></get_fps>
		<new public="1" set="method" line="56">
			<f a="?hardware:?aa" v="true:0">
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ aa : 0, hardware : true }</e></m>
				<m n=":access"><e>hxd.Window</e></m>
			</meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.Indexes" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Indexes.hx">
		<alloc public="1" set="method" line="40" static="1">
			<f a="i:?startPos:?length" v=":0:-1">
				<x path="hxd.IndexBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="h3d.Indexes"/>
			</f>
			<meta><m n=":value"><e>{ length : -1, startPos : 0 }</e></m></meta>
		</alloc>
		<mem><c path="h3d.impl.MemoryManager"/></mem>
		<ibuf><t path="h3d.impl.IndexBuffer"/></ibuf>
		<is32 public="1" set="null"><x path="Bool"/></is32>
		<count public="1" set="null"><x path="Int"/></count>
		<isDisposed public="1" set="method" line="19"><f a=""><x path="Bool"/></f></isDisposed>
		<upload public="1" set="method" line="23">
			<f a="indexes:pos:count:?bufferPos" v=":::0">
				<x path="hxd.IndexBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ bufferPos : 0 }</e></m></meta>
		</upload>
		<uploadBytes public="1" set="method" line="27"><f a="bytes:dataPos:indices">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadBytes>
		<readBytes public="1" set="method" line="31">
			<f a="bytes:bytesPosition:indices:?startIndice" v=":::0">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ startIndice : 0 }</e></m></meta>
		</readBytes>
		<dispose public="1" set="method" line="35"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="12">
			<f a="count:?is32" v=":false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ is32 : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.impl.MemoryManager</e></m>
			<m n=":allow"><e>h3d.Engine</e></m>
		</meta>
	</class>
	<typedef path="h3d.ColorAdjust" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Matrix.hx" module="h3d.Matrix"><a>
	<saturation>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</saturation>
	<lightness>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</lightness>
	<hue>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</hue>
	<gain>
		<x path="Null"><a>
	<color><x path="Int"/></color>
	<alpha><x path="Float"/></alpha>
</a></x>
		<meta><m n=":optional"/></meta>
	</gain>
	<contrast>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</contrast>
</a></typedef>
	<class path="h3d.Matrix" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Matrix.hx">
		<tmp expr="new Matrix()" line="15" static="1">
			<c path="h3d.Matrix"/>
			<meta><m n=":value"><e>new Matrix()</e></m></meta>
		</tmp>
		<lumR get="inline" set="null" expr="0.212671" line="564" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.212671</e></m></meta>
		</lumR>
		<lumG get="inline" set="null" expr="0.71516" line="565" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.71516</e></m></meta>
		</lumG>
		<lumB get="inline" set="null" expr="0.072169" line="566" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.072169</e></m></meta>
		</lumB>
		<SQ13 get="inline" set="null" expr="0.57735026918962576450914878050196" line="568" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.57735026918962576450914878050196</e></m></meta>
		</SQ13>
		<I public="1" set="method" line="729" static="1"><f a=""><c path="h3d.Matrix"/></f></I>
		<L public="1" set="method" line="735" static="1"><f a="a">
	<c path="Array"><x path="Float"/></c>
	<c path="h3d.Matrix"/>
</f></L>
		<T public="1" set="method" line="741" static="1">
			<f a="?x:?y:?z" v="0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h3d.Matrix"/>
			</f>
			<meta><m n=":value"><e>{ z : 0., y : 0., x : 0. }</e></m></meta>
		</T>
		<R public="1" set="method" line="747" static="1"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h3d.Matrix"/>
</f></R>
		<S public="1" set="method" line="753" static="1">
			<f a="?x:?y:?z" v="1.:1.:1.0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h3d.Matrix"/>
			</f>
			<meta><m n=":value"><e>{ z : 1.0, y : 1., x : 1. }</e></m></meta>
		</S>
		<lookAtX public="1" set="method" line="762" static="1">
			<f a="dir:?up:?m">
				<c path="h3d.Vector"/>
				<c path="h3d.Vector"/>
				<c path="h3d.Matrix"/>
				<x path="Null"><c path="h3d.Matrix"/></x>
			</f>
			<haxe_doc>Build a rotation Matrix so the X axis will look at the given direction, and the Z axis will be the Up vector ([0,0,1] by default)</haxe_doc>
		</lookAtX>
		<_11 public="1"><x path="Float"/></_11>
		<_12 public="1"><x path="Float"/></_12>
		<_13 public="1"><x path="Float"/></_13>
		<_14 public="1"><x path="Float"/></_14>
		<_21 public="1"><x path="Float"/></_21>
		<_22 public="1"><x path="Float"/></_22>
		<_23 public="1"><x path="Float"/></_23>
		<_24 public="1"><x path="Float"/></_24>
		<_31 public="1"><x path="Float"/></_31>
		<_32 public="1"><x path="Float"/></_32>
		<_33 public="1"><x path="Float"/></_33>
		<_34 public="1"><x path="Float"/></_34>
		<_41 public="1"><x path="Float"/></_41>
		<_42 public="1"><x path="Float"/></_42>
		<_43 public="1"><x path="Float"/></_43>
		<_44 public="1"><x path="Float"/></_44>
		<tx public="1" get="accessor" set="accessor"><x path="Float"/></tx>
		<ty public="1" get="accessor" set="accessor"><x path="Float"/></ty>
		<tz public="1" get="accessor" set="accessor"><x path="Float"/></tz>
		<get_tx get="inline" set="null" line="41"><f a=""><x path="Float"/></f></get_tx>
		<get_ty get="inline" set="null" line="42"><f a=""><x path="Float"/></f></get_ty>
		<get_tz get="inline" set="null" line="43"><f a=""><x path="Float"/></f></get_tz>
		<set_tx get="inline" set="null" line="44"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_tx>
		<set_ty get="inline" set="null" line="45"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ty>
		<set_tz get="inline" set="null" line="46"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_tz>
		<zero public="1" set="method" line="48"><f a=""><x path="Void"/></f></zero>
		<identity public="1" set="method" line="55"><f a=""><x path="Void"/></f></identity>
		<initRotationX public="1" set="method" line="62"><f a="a">
	<x path="Float"/>
	<x path="Void"/>
</f></initRotationX>
		<initRotationY public="1" set="method" line="71"><f a="a">
	<x path="Float"/>
	<x path="Void"/>
</f></initRotationY>
		<initRotationZ public="1" set="method" line="80"><f a="a">
	<x path="Float"/>
	<x path="Void"/>
</f></initRotationZ>
		<initTranslation public="1" set="method" line="89">
			<f a="?x:?y:?z" v="0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0., y : 0., x : 0. }</e></m></meta>
		</initTranslation>
		<initScale public="1" set="method" line="96">
			<f a="?x:?y:?z" v="1.:1.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 1., y : 1., x : 1. }</e></m></meta>
		</initScale>
		<initRotationAxis public="1" set="method" line="103"><f a="axis:angle">
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initRotationAxis>
		<initRotation public="1" set="method" line="128"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initRotation>
		<translate public="1" set="method" line="155">
			<f a="?x:?y:?z" v="0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0., y : 0., x : 0. }</e></m></meta>
		</translate>
		<scale public="1" set="method" line="170">
			<f a="?x:?y:?z" v="1.:1.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 1., y : 1., x : 1. }</e></m></meta>
		</scale>
		<rotate public="1" set="method" line="185"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<rotateAxis public="1" set="method" line="191"><f a="axis:angle">
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rotateAxis>
		<getPosition public="1" get="inline" set="null" line="197"><f a="?v">
	<c path="h3d.Vector"/>
	<x path="Null"><c path="h3d.Vector"/></x>
</f></getPosition>
		<setPosition public="1" get="inline" set="null" line="203"><f a="v">
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></setPosition>
		<prependTranslation public="1" set="method" line="210">
			<f a="?x:?y:?z" v="0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0., y : 0., x : 0. }</e></m></meta>
		</prependTranslation>
		<getScale public="1" get="inline" set="null" line="221"><f a=""><c path="h3d.Vector"/></f></getScale>
		<prependRotation public="1" set="method" line="234"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependRotation>
		<prependRotationAxis public="1" set="method" line="240"><f a="axis:angle">
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependRotationAxis>
		<prependScale public="1" set="method" line="246">
			<f a="?sx:?sy:?sz" v="1.:1.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ sz : 1., sy : 1., sx : 1. }</e></m></meta>
		</prependScale>
		<multiply3x4 public="1" set="method" line="253">
			<f a="a:b">
				<c path="h3d.Matrix"/>
				<c path="h3d.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</multiply3x4>
		<multiply3x4inline public="1" get="inline" set="null" line="257"><f a="a:b">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></multiply3x4inline>
		<multiply public="1" set="method" line="288"><f a="a:b">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></multiply>
		<multiplyValue public="1" set="method" line="319"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></multiplyValue>
		<invert public="1" get="inline" set="null" line="338"><f a=""><x path="Void"/></f></invert>
		<getDeterminant public="1" get="inline" set="null" line="342"><f a=""><x path="Float"/></f></getDeterminant>
		<inverse3x4 public="1" set="method" line="346"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></inverse3x4>
		<initInverse public="1" set="method" line="380"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></initInverse>
		<initInverse3x3 public="1" set="method" line="429"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></initInverse3x3>
		<front public="1" get="inline" set="null" line="469"><f a=""><c path="h3d.Vector"/></f></front>
		<right public="1" get="inline" set="null" line="475"><f a=""><c path="h3d.Vector"/></f></right>
		<up public="1" get="inline" set="null" line="481"><f a=""><c path="h3d.Vector"/></f></up>
		<transpose public="1" set="method" line="487"><f a=""><x path="Void"/></f></transpose>
		<clone public="1" set="method" line="497"><f a=""><c path="h3d.Matrix"/></f></clone>
		<load public="1" set="method" line="506"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></load>
		<loadValues public="1" set="method" line="513"><f a="a">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></loadValues>
		<getFloats public="1" set="method" line="520"><f a=""><c path="Array"><x path="Float"/></c></f></getFloats>
		<getEulerAngles public="1" set="method" line="527">
			<f a=""><c path="h3d.Vector"/></f>
			<haxe_doc>Extracts Euler rotation angles from rotation matrix</haxe_doc>
		</getEulerAngles>
		<toString public="1" set="method" line="553"><f a=""><c path="String"/></f></toString>
		<colorHue public="1" set="method" line="569"><f a="hue">
	<x path="Float"/>
	<x path="Void"/>
</f></colorHue>
		<colorSaturate public="1" set="method" line="595"><f a="sat">
	<x path="Float"/>
	<x path="Void"/>
</f></colorSaturate>
		<colorContrast public="1" set="method" line="617"><f a="contrast">
	<x path="Float"/>
	<x path="Void"/>
</f></colorContrast>
		<colorLightness public="1" set="method" line="635"><f a="lightness">
	<x path="Float"/>
	<x path="Void"/>
</f></colorLightness>
		<colorGain public="1" set="method" line="641"><f a="color:alpha">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></colorGain>
		<colorBits public="1" set="method" line="659"><f a="bits:blend">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></colorBits>
		<colorAdd public="1" get="inline" set="null" line="707"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></colorAdd>
		<colorSet public="1" get="inline" set="null" line="713">
			<f a="c:?alpha" v=":1.">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1. }</e></m></meta>
		</colorSet>
		<adjustColor public="1" set="method" line="719"><f a="col">
	<t path="h3d.ColorAdjust"/>
	<x path="Void"/>
</f></adjustColor>
		<new public="1" set="method" line="38"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="h3d.Quat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Quat.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<w public="1"><x path="Float"/></w>
		<set public="1" get="inline" set="null" line="19"><f a="x:y:z:w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<identity public="1" get="inline" set="null" line="26"><f a=""><x path="Void"/></f></identity>
		<lengthSq public="1" get="inline" set="null" line="31"><f a=""><x path="Float"/></f></lengthSq>
		<length public="1" get="inline" set="null" line="35"><f a=""><x path="Float"/></f></length>
		<load public="1" get="inline" set="null" line="39"><f a="q">
	<c path="h3d.Quat"/>
	<x path="Void"/>
</f></load>
		<clone public="1" set="method" line="46"><f a=""><c path="h3d.Quat"/></f></clone>
		<initMoveTo public="1" set="method" line="50"><f a="from:to">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></initMoveTo>
		<initDirection public="1" set="method" line="66"><f a="dir">
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></initDirection>
		<initRotateAxis public="1" set="method" line="108"><f a="x:y:z:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initRotateAxis>
		<initRotateMatrix public="1" set="method" line="118"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></initRotateMatrix>
		<normalize public="1" set="method" line="151"><f a=""><x path="Void"/></f></normalize>
		<initRotation public="1" set="method" line="165"><f a="ax:ay:az">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></initRotation>
		<multiply public="1" set="method" line="180"><f a="q1:q2">
	<c path="h3d.Quat"/>
	<c path="h3d.Quat"/>
	<x path="Void"/>
</f></multiply>
		<toEuler public="1" set="method" line="191"><f a=""><c path="h3d.Vector"/></f></toEuler>
		<lerp public="1" get="inline" set="null" line="195">
			<f a="q1:q2:v:?nearest" v=":::false">
				<c path="h3d.Quat"/>
				<c path="h3d.Quat"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ nearest : false }</e></m></meta>
		</lerp>
		<slerp public="1" set="method" line="211"><f a="q1:q2:v">
	<c path="h3d.Quat"/>
	<c path="h3d.Quat"/>
	<x path="Float"/>
	<x path="Void"/>
</f></slerp>
		<conjugate public="1" get="inline" set="null" line="234"><f a=""><x path="Void"/></f></conjugate>
		<negate public="1" get="inline" set="null" line="243">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Negate the quaternion: this will not change the actual angle, use `conjugate` for that.</haxe_doc>
		</negate>
		<dot public="1" get="inline" set="null" line="250"><f a="q">
	<c path="h3d.Quat"/>
	<x path="Float"/>
</f></dot>
		<getDirection public="1" get="inline" set="null" line="254"><f a=""><c path="h3d.Vector"/></f></getDirection>
		<toMatrix public="1" set="method" line="261">
			<f a="?m">
				<c path="h3d.Matrix"/>
				<x path="Null"><c path="h3d.Matrix"/></x>
			</f>
			<haxe_doc>Save to a Left-Handed matrix</haxe_doc>
		</toMatrix>
		<toString public="1" set="method" line="291"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="12">
			<f a="?x:?y:?z:?w" v="0.:0.:0.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 1., z : 0., y : 0., x : 0. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="h3d.Vector" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/Vector.hx">
		<fromColor public="1" get="inline" set="null" line="256" static="1">
			<f a="c:?scale" v=":1.0">
				<x path="Int"/>
				<x path="Float"/>
				<c path="h3d.Vector"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1.0 }</e></m></meta>
		</fromColor>
		<fromArray public="1" get="inline" set="null" line="261" static="1"><f a="a">
	<c path="Array"><x path="Float"/></c>
	<c path="h3d.Vector"/>
</f></fromArray>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<w public="1"><x path="Float"/></w>
		<distance public="1" get="inline" set="null" line="22"><f a="v">
	<c path="h3d.Vector"/>
	<x path="Float"/>
</f></distance>
		<distanceSq public="1" get="inline" set="null" line="26"><f a="v">
	<c path="h3d.Vector"/>
	<x path="Float"/>
</f></distanceSq>
		<sub public="1" get="inline" set="null" line="33"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></sub>
		<add public="1" get="inline" set="null" line="37"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></add>
		<cross public="1" get="inline" set="null" line="42"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></cross>
		<reflect public="1" get="inline" set="null" line="46"><f a="n">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></reflect>
		<dot3 public="1" get="inline" set="null" line="51"><f a="v">
	<c path="h3d.Vector"/>
	<x path="Float"/>
</f></dot3>
		<dot4 public="1" get="inline" set="null" line="55"><f a="v">
	<c path="h3d.Vector"/>
	<x path="Float"/>
</f></dot4>
		<lengthSq public="1" get="inline" set="null" line="59"><f a=""><x path="Float"/></f></lengthSq>
		<length public="1" get="inline" set="null" line="63"><f a=""><x path="Float"/></f></length>
		<normalize public="1" set="method" line="67"><f a=""><x path="Void"/></f></normalize>
		<normalizeFast public="1" get="inline" set="null" line="75"><f a=""><x path="Void"/></f></normalizeFast>
		<getNormalized public="1" get="inline" set="null" line="82"><f a=""><c path="h3d.Vector"/></f></getNormalized>
		<set public="1" get="inline" set="null" line="88">
			<f a="?x:?y:?z:?w" v="0.:0.:0.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 1., z : 0., y : 0., x : 0. }</e></m></meta>
		</set>
		<load public="1" get="inline" set="null" line="95"><f a="v">
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></load>
		<scale3 public="1" get="inline" set="null" line="102"><f a="f">
	<x path="Float"/>
	<x path="Void"/>
</f></scale3>
		<project public="1" get="inline" set="null" line="108"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></project>
		<lerp public="1" get="inline" set="null" line="119"><f a="v1:v2:k">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lerp>
		<transform3x4 public="1" get="inline" set="null" line="130"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform3x4>
		<transform3x3 public="1" get="inline" set="null" line="139"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform3x3>
		<transform public="1" get="inline" set="null" line="148"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<clone public="1" get="inline" set="null" line="159"><f a=""><c path="h3d.Vector"/></f></clone>
		<toPoint public="1" get="inline" set="null" line="163"><f a=""><c path="h3d.col.Point"/></f></toPoint>
		<toString public="1" set="method" line="167"><f a=""><c path="String"/></f></toString>
		<r public="1" get="accessor" set="accessor"><x path="Float"/></r>
		<g public="1" get="accessor" set="accessor"><x path="Float"/></g>
		<b public="1" get="accessor" set="accessor"><x path="Float"/></b>
		<a public="1" get="accessor" set="accessor"><x path="Float"/></a>
		<get_r get="inline" set="null" line="178"><f a=""><x path="Float"/></f></get_r>
		<get_g get="inline" set="null" line="179"><f a=""><x path="Float"/></f></get_g>
		<get_b get="inline" set="null" line="180"><f a=""><x path="Float"/></f></get_b>
		<get_a get="inline" set="null" line="181"><f a=""><x path="Float"/></f></get_a>
		<set_r get="inline" set="null" line="182"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_r>
		<set_g get="inline" set="null" line="183"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_g>
		<set_b get="inline" set="null" line="184"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_b>
		<set_a get="inline" set="null" line="185"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_a>
		<setColor public="1" get="inline" set="null" line="187"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></setColor>
		<makeColor public="1" set="method" line="194">
			<f a="hue:?saturation:?brightness" v=":1.:0.5">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ brightness : 0.5, saturation : 1. }</e></m></meta>
		</makeColor>
		<toColor public="1" get="inline" set="null" line="230"><f a=""><x path="Int"/></f></toColor>
		<toColorHSL public="1" set="method" line="234"><f a=""><c path="h3d.Vector"/></f></toColorHSL>
		<new public="1" get="inline" set="null" line="15">
			<f a="?x:?y:?z:?w" v="0.:0.:0.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 1., z : 0., y : 0., x : 0. }</e></m></meta>
		</new>
		<haxe_doc>A 4 floats vector. Everytime a Vector is returned, it means a copy is created.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="h3d.anim.AnimatedObject" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/Animation.hx" module="h3d.anim.Animation">
		<objectName public="1"><c path="String"/></objectName>
		<targetObject public="1"><c path="h3d.scene.Object"/></targetObject>
		<targetSkin public="1"><c path="h3d.scene.Skin"/></targetSkin>
		<targetJoint public="1"><x path="Int"/></targetJoint>
		<clone public="1" set="method" line="16"><f a=""><c path="h3d.anim.AnimatedObject"/></f></clone>
		<new public="1" set="method" line="12"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.anim.Animation" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/Animation.hx">
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<EPSILON get="inline" set="null" expr="0.000001" line="24" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.000001</e></m></meta>
		</EPSILON>
		<name public="1">
			<c path="String"/>
			<meta><m n=":s"/></meta>
		</name>
		<frameCount public="1" set="null">
			<x path="Int"/>
			<meta><m n=":s"/></meta>
		</frameCount>
		<sampling public="1" set="null">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
		</sampling>
		<frame public="1" set="null">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
		</frame>
		<speed public="1">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
		</speed>
		<onAnimEnd public="1"><f a=""><x path="Void"/></f></onAnimEnd>
		<onEvent public="1"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></onEvent>
		<pause public="1">
			<x path="Bool"/>
			<meta><m n=":s"/></meta>
		</pause>
		<loop public="1">
			<x path="Bool"/>
			<meta><m n=":s"/></meta>
		</loop>
		<events public="1" set="null"><c path="Array"><c path="Array"><c path="String"/></c></c></events>
		<isInstance><x path="Bool"/></isInstance>
		<objects><c path="Array"><c path="h3d.anim.AnimatedObject"/></c></objects>
		<isSync><x path="Bool"/></isSync>
		<lastEvent><x path="Int"/></lastEvent>
		<getDuration public="1" set="method" line="57"><f a=""><x path="Float"/></f></getDuration>
		<getIFrame get="inline" set="null" line="61"><f a=""><x path="Int"/></f></getIFrame>
		<unbind public="1" set="method" line="68"><f a="objectName">
	<c path="String"/>
	<x path="Void"/>
</f></unbind>
		<setEvents public="1" set="method" line="83">
			<f a="el">
				<t path="Iterable"><a>
	<frame><x path="Int"/></frame>
	<data><c path="String"/></data>
</a></t>
				<x path="Void"/>
			</f>
			<haxe_doc>Register a callback function that will be called once when a frame is reached.</haxe_doc>
		</setEvents>
		<addEvent public="1" set="method" line="91"><f a="frame:data">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></addEvent>
		<getEvents public="1" set="method" line="100"><f a=""><c path="Array"><c path="Array"><c path="String"/></c></c></f></getEvents>
		<getObjects public="1" set="method" line="102"><f a=""><c path="Array"><c path="h3d.anim.AnimatedObject"/></c></f></getObjects>
		<setFrame public="1" set="method" line="104"><f a="f">
	<x path="Float"/>
	<x path="Void"/>
</f></setFrame>
		<clone set="method" line="111"><f a="?a">
	<c path="h3d.anim.Animation"/>
	<c path="h3d.anim.Animation"/>
</f></clone>
		<initInstance set="method" line="122"><f a=""><x path="Void"/></f></initInstance>
		<createInstance public="1" set="method" line="127"><f a="base">
	<c path="h3d.scene.Object"/>
	<c path="h3d.anim.Animation"/>
</f></createInstance>
		<bind public="1" set="method" line="140">
			<f a="base">
				<c path="h3d.scene.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>h3d.scene.Skin.skinData</e></m></meta>
			<haxe_doc>If one of the animated object has been changed, it is necessary to call bind() so the animation can keep with the change.</haxe_doc>
		</bind>
		<getPropValue public="1" set="method" line="173">
			<f a="objectName:propName">
				<c path="String"/>
				<c path="String"/>
				<x path="Null"><x path="Float"/></x>
			</f>
			<haxe_doc>Returns the current value of animation property for the given object, or null if not found.</haxe_doc>
		</getPropValue>
		<sync public="1" set="method" line="181">
			<f a="?decompose" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ decompose : false }</e></m></meta>
			<haxe_doc>Synchronize the target object matrix.
		If decompose is true, then the rotation quaternion is stored in [m12,m13,m21,m23] instead of mixed with the scale.</haxe_doc>
		</sync>
		<isPlaying set="method" line="186"><f a=""><x path="Bool"/></f></isPlaying>
		<endFrame set="method" line="190"><f a=""><x path="Int"/></f></endFrame>
		<update public="1" set="method" line="194"><f a="dt">
	<x path="Float"/>
	<x path="Float"/>
</f></update>
		<initAndBind set="method" line="258"><f a="obj">
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></initAndBind>
		<toString public="1" set="method" line="265"><f a=""><c path="String"/></f></toString>
		<new set="method" line="45"><f a="name:frameCount:sampling">
	<c path="String"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.anim.LinearFrame" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/LinearAnimation.hx" module="h3d.anim.LinearAnimation">
		<tx public="1"><x path="Float"/></tx>
		<ty public="1"><x path="Float"/></ty>
		<tz public="1"><x path="Float"/></tz>
		<qx public="1"><x path="Float"/></qx>
		<qy public="1"><x path="Float"/></qy>
		<qz public="1"><x path="Float"/></qz>
		<qw public="1"><x path="Float"/></qw>
		<sx public="1"><x path="Float"/></sx>
		<sy public="1"><x path="Float"/></sy>
		<sz public="1"><x path="Float"/></sz>
		<toMatrix public="1" set="method" line="17"><f a=""><c path="h3d.Matrix"/></f></toMatrix>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim.LinearObject" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/LinearAnimation.hx" module="h3d.anim.LinearAnimation">
		<extends path="h3d.anim.AnimatedObject"/>
		<hasRotation public="1"><x path="Bool"/></hasRotation>
		<hasScale public="1"><x path="Bool"/></hasScale>
		<frames public="1"><x path="haxe.ds.Vector"><c path="h3d.anim.LinearFrame"/></x></frames>
		<alphas public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></alphas>
		<uvs public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></uvs>
		<propName public="1"><c path="String"/></propName>
		<propValues public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></propValues>
		<matrix public="1"><c path="h3d.Matrix"/></matrix>
		<propCurrentValue public="1"><x path="Float"/></propCurrentValue>
		<clone public="1" set="method" line="36" override="1"><f a=""><c path="h3d.anim.AnimatedObject"/></f></clone>
		<new public="1" set="method" line="26"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim.LinearAnimation" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/LinearAnimation.hx">
		<extends path="h3d.anim.Animation"/>
		<resPath public="1">
			<c path="String"/>
			<meta><m n=":s"/></meta>
		</resPath>
		<syncFrame><x path="Float"/></syncFrame>
		<addCurve public="1" set="method" line="59"><f a="objName:frames:hasRot:hasScale">
	<c path="String"/>
	<x path="haxe.ds.Vector"><c path="h3d.anim.LinearFrame"/></x>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addCurve>
		<addAlphaCurve public="1" set="method" line="67"><f a="objName:alphas">
	<c path="String"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></addAlphaCurve>
		<addUVCurve public="1" set="method" line="73"><f a="objName:uvs">
	<c path="String"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></addUVCurve>
		<addPropCurve public="1" set="method" line="79"><f a="objName:propName:values">
	<c path="String"/>
	<c path="String"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></addPropCurve>
		<getPropValue public="1" set="method" line="86" override="1"><f a="objName:propName">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><x path="Float"/></x>
</f></getPropValue>
		<getFrames get="inline" set="null" line="93"><f a=""><c path="Array"><c path="h3d.anim.LinearObject"/></c></f></getFrames>
		<clone set="method" line="97" override="1"><f a="?a">
	<c path="h3d.anim.Animation"/>
	<x path="Null"><c path="h3d.anim.Animation"/></x>
</f></clone>
		<endFrame set="method" line="106" override="1"><f a=""><x path="Int"/></f></endFrame>
		<initInstance set="method" line="112" override="1"><f a=""><x path="Void"/></f></initInstance>
		<sortByFrameCountDesc set="method" line="130"><f a="o1:o2">
	<c path="h3d.anim.LinearObject"/>
	<c path="h3d.anim.LinearObject"/>
	<x path="Int"/>
</f></sortByFrameCountDesc>
		<uvLerp get="inline" set="null" line="134"><f a="v1:v2:k">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></uvLerp>
		<sync public="1" set="method" line="146" override="1">
			<f a="?decompose" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ decompose : false }</e></m>
				<m n=":access"><e>h3d.scene.Skin</e></m>
				<m n=":noDebug"/>
			</meta>
		</sync>
		<new public="1" set="method" line="54"><f a="name:frame:sampling">
	<c path="String"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim.Joint" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/Skin.hx" module="h3d.anim.Skin">
		<index public="1"><x path="Int"/></index>
		<name public="1"><c path="String"/></name>
		<bindIndex public="1"><x path="Int"/></bindIndex>
		<splitIndex public="1"><x path="Int"/></splitIndex>
		<defMat public="1"><c path="h3d.Matrix"/></defMat>
		<transPos public="1"><c path="h3d.Matrix"/></transPos>
		<parent public="1"><c path="h3d.anim.Joint"/></parent>
		<subs public="1"><c path="Array"><c path="h3d.anim.Joint"/></c></subs>
		<retargetAnim public="1">
			<x path="Bool"/>
			<haxe_doc>When animated, we will use the default bind pose translation instead of the animated translation,
		enabling retargeting on a skeleton with different proportions</haxe_doc>
		</retargetAnim>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim._Skin.Permut" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/Skin.hx" private="1" module="h3d.anim.Skin">
		<joints public="1"><c path="Array"><c path="h3d.anim.Joint"/></c></joints>
		<triangles public="1"><c path="Array"><x path="Int"/></c></triangles>
		<material public="1"><x path="Int"/></material>
		<indexedJoints public="1"><c path="Array"><c path="h3d.anim.Joint"/></c></indexedJoints>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim._Skin.Influence" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/Skin.hx" private="1" module="h3d.anim.Skin">
		<j public="1"><c path="h3d.anim.Joint"/></j>
		<w public="1"><x path="Float"/></w>
		<new public="1" set="method" line="39"><f a="j:w">
	<c path="h3d.anim.Joint"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.anim.Skin" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/anim/Skin.hx">
		<name public="1"><c path="String"/></name>
		<vertexCount public="1" set="null"><x path="Int"/></vertexCount>
		<bonesPerVertex public="1" set="null"><x path="Int"/></bonesPerVertex>
		<vertexJoints public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></vertexJoints>
		<vertexWeights public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></vertexWeights>
		<rootJoints public="1" set="null"><c path="Array"><c path="h3d.anim.Joint"/></c></rootJoints>
		<namedJoints public="1" set="null"><t path="Map">
	<c path="String"/>
	<c path="h3d.anim.Joint"/>
</t></namedJoints>
		<allJoints public="1" set="null"><c path="Array"><c path="h3d.anim.Joint"/></c></allJoints>
		<boundJoints public="1" set="null"><c path="Array"><c path="h3d.anim.Joint"/></c></boundJoints>
		<primitive public="1"><c path="h3d.prim.Primitive"/></primitive>
		<splitJoints public="1" set="null"><c path="Array"><a>
	<material><x path="Int"/></material>
	<joints><c path="Array"><c path="h3d.anim.Joint"/></c></joints>
</a></c></splitJoints>
		<triangleGroups public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></triangleGroups>
		<envelop><c path="Array"><c path="Array"><c path="h3d.anim._Skin.Influence"/></c></c></envelop>
		<setJoints public="1" set="method" line="77"><f a="joints:roots">
	<c path="Array"><c path="h3d.anim.Joint"/></c>
	<c path="Array"><c path="h3d.anim.Joint"/></c>
	<x path="Void"/>
</f></setJoints>
		<addInfluence public="1" get="inline" set="null" line="86"><f a="vid:j:w">
	<x path="Int"/>
	<c path="h3d.anim.Joint"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addInfluence>
		<sortInfluences set="method" line="93"><f a="i1:i2">
	<c path="h3d.anim._Skin.Influence"/>
	<c path="h3d.anim._Skin.Influence"/>
	<x path="Int"/>
</f></sortInfluences>
		<isSplit public="1" get="inline" set="null" line="97"><f a=""><x path="Bool"/></f></isSplit>
		<initWeights public="1" set="method" line="101"><f a=""><x path="Void"/></f></initWeights>
		<sortByBindIndex set="method" line="133"><f a="j1:j2">
	<c path="h3d.anim.Joint"/>
	<c path="h3d.anim.Joint"/>
	<x path="Int"/>
</f></sortByBindIndex>
		<isSub set="method" line="137"><f a="a:b">
	<c path="Array"><c path="h3d.anim.Joint"/></c>
	<c path="Array"><c path="h3d.anim.Joint"/></c>
	<x path="Bool"/>
</f></isSub>
		<merge set="method" line="149"><f a="permuts">
	<c path="Array"><c path="h3d.anim._Skin.Permut"/></c>
	<x path="Bool"/>
</f></merge>
		<jointsDiff set="method" line="161"><f a="p1:p2">
	<c path="h3d.anim._Skin.Permut"/>
	<c path="h3d.anim._Skin.Permut"/>
	<x path="Int"/>
</f></jointsDiff>
		<split public="1" set="method" line="182"><f a="maxBones:index:triangleMaterials">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Null"><c path="Array"><x path="Int"/></c></x>
	<x path="Bool"/>
</f></split>
		<new public="1" set="method" line="66"><f a="name:vertexCount:bonesPerVertex">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.Collider" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Collider.hx" interface="1">
		<extends path="hxd.impl._Serializable.NoSerializeSupport"/>
		<rayIntersection public="1" set="method">
			<f a="r:bestMatch">
				<c path="h3d.col.Ray"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the distance of intersection between the ray and the collider, or negative if no collision.</haxe_doc>
		</rayIntersection>
		<contains public="1" set="method"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<inFrustum public="1" set="method"><f a="mvp">
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
	</class>
	<class path="h3d.col.Bounds" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Bounds.hx">
		<implements path="h3d.col.Collider"/>
		<fromPoints public="1" get="inline" set="null" line="365" static="1"><f a="min:max">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Bounds"/>
</f></fromPoints>
		<fromValues public="1" get="inline" set="null" line="372" static="1"><f a="x:y:z:dx:dy:dz">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h3d.col.Bounds"/>
</f></fromValues>
		<xMin public="1"><x path="Float"/></xMin>
		<xMax public="1"><x path="Float"/></xMax>
		<yMin public="1"><x path="Float"/></yMin>
		<yMax public="1"><x path="Float"/></yMax>
		<zMin public="1"><x path="Float"/></zMin>
		<zMax public="1"><x path="Float"/></zMax>
		<xSize public="1" get="accessor" set="accessor"><x path="Float"/></xSize>
		<ySize public="1" get="accessor" set="accessor"><x path="Float"/></ySize>
		<zSize public="1" get="accessor" set="accessor"><x path="Float"/></zSize>
		<inFrustum public="1" set="method" line="21"><f a="mvp">
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<testPlane get="inline" set="null" line="37"><f a="p">
	<c path="h3d.col.Plane"/>
	<x path="Float"/>
</f></testPlane>
		<rayIntersection public="1" set="method" line="49"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<inFrustumDetails public="1" set="method" line="77">
			<f a="mvp:?checkZ" v=":true">
				<c path="h3d.Matrix"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ checkZ : true }</e></m></meta>
			<haxe_doc>* Check if the camera model-view-projection Matrix intersects with the Bounds. Returns -1 if outside, 0 if interests and 1 if fully inside.
	 * @param	mvp : the model-view-projection matrix to test against
	 * @param	checkZ : tells if we will check against the near/far plane</haxe_doc>
		</inFrustumDetails>
		<transform3x3 public="1" set="method" line="130"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform3x3>
		<transform public="1" set="method" line="160"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<collide public="1" get="inline" set="null" line="193"><f a="b">
	<c path="h3d.col.Bounds"/>
	<x path="Bool"/>
</f></collide>
		<contains public="1" get="inline" set="null" line="197"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<add public="1" get="inline" set="null" line="201"><f a="b">
	<c path="h3d.col.Bounds"/>
	<x path="Void"/>
</f></add>
		<addPoint public="1" get="inline" set="null" line="210"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></addPoint>
		<addPos public="1" get="inline" set="null" line="219"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addPos>
		<intersection public="1" set="method" line="228"><f a="a:b">
	<c path="h3d.col.Bounds"/>
	<c path="h3d.col.Bounds"/>
	<x path="Void"/>
</f></intersection>
		<offset public="1" get="inline" set="null" line="243"><f a="dx:dy:dz">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<setMin public="1" get="inline" set="null" line="252"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></setMin>
		<setMax public="1" get="inline" set="null" line="258"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></setMax>
		<load public="1" set="method" line="264"><f a="b">
	<c path="h3d.col.Bounds"/>
	<x path="Void"/>
</f></load>
		<scalePivot public="1" get="inline" set="null" line="273"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></scalePivot>
		<scaleCenter public="1" set="method" line="283"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleCenter>
		<getMin public="1" get="inline" set="null" line="298"><f a=""><c path="h3d.col.Point"/></f></getMin>
		<getCenter public="1" get="inline" set="null" line="302"><f a=""><c path="h3d.col.Point"/></f></getCenter>
		<getSize public="1" get="inline" set="null" line="306"><f a=""><c path="h3d.col.Point"/></f></getSize>
		<getMax public="1" get="inline" set="null" line="310"><f a=""><c path="h3d.col.Point"/></f></getMax>
		<get_xSize get="inline" set="null" line="314"><f a=""><x path="Float"/></f></get_xSize>
		<get_ySize get="inline" set="null" line="315"><f a=""><x path="Float"/></f></get_ySize>
		<get_zSize get="inline" set="null" line="316"><f a=""><x path="Float"/></f></get_zSize>
		<set_xSize get="inline" set="null" line="317"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_xSize>
		<set_ySize get="inline" set="null" line="318"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ySize>
		<set_zSize get="inline" set="null" line="319"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_zSize>
		<isEmpty public="1" get="inline" set="null" line="321"><f a=""><x path="Bool"/></f></isEmpty>
		<empty public="1" get="inline" set="null" line="325"><f a=""><x path="Void"/></f></empty>
		<all public="1" get="inline" set="null" line="334"><f a=""><x path="Void"/></f></all>
		<clone public="1" get="inline" set="null" line="343"><f a=""><c path="h3d.col.Bounds"/></f></clone>
		<toString public="1" set="method" line="354"><f a=""><c path="String"/></f></toString>
		<toSphere public="1" get="inline" set="null" line="358"><f a=""><c path="h3d.col.Sphere"/></f></toSphere>
		<new public="1" get="inline" set="null" line="17"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.OptimizedCollider" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Collider.hx" module="h3d.col.Collider">
		<implements path="h3d.col.Collider"/>
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<a public="1">
			<c path="h3d.col.Collider"/>
			<meta><m n=":s"/></meta>
		</a>
		<b public="1">
			<c path="h3d.col.Collider"/>
			<meta><m n=":s"/></meta>
		</b>
		<rayIntersection public="1" set="method" line="25"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<contains public="1" set="method" line="31"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<inFrustum public="1" set="method" line="35"><f a="mvp">
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<new public="1" set="method" line="20"><f a="a:b">
	<c path="h3d.col.Collider"/>
	<c path="h3d.col.Collider"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.GroupCollider" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Collider.hx" module="h3d.col.Collider">
		<implements path="h3d.col.Collider"/>
		<colliders public="1"><c path="Array"><c path="h3d.col.Collider"/></c></colliders>
		<rayIntersection public="1" set="method" line="57"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<contains public="1" set="method" line="69"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<inFrustum public="1" set="method" line="76"><f a="mvp">
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<new public="1" set="method" line="53"><f a="colliders">
	<c path="Array"><c path="h3d.col.Collider"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.FPoint" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/FPoint.hx">
		<x public="1"><t path="hxd.impl.Float32"/></x>
		<y public="1"><t path="hxd.impl.Float32"/></y>
		<z public="1"><t path="hxd.impl.Float32"/></z>
		<sub public="1" get="inline" set="null" line="16"><f a="p">
	<c path="h3d.col.FPoint"/>
	<c path="h3d.col.FPoint"/>
</f></sub>
		<add public="1" get="inline" set="null" line="20"><f a="p">
	<c path="h3d.col.FPoint"/>
	<c path="h3d.col.FPoint"/>
</f></add>
		<cross public="1" get="inline" set="null" line="24"><f a="p">
	<c path="h3d.col.FPoint"/>
	<c path="h3d.col.FPoint"/>
</f></cross>
		<dot public="1" get="inline" set="null" line="28"><f a="p">
	<c path="h3d.col.FPoint"/>
	<x path="Float"/>
</f></dot>
		<toString public="1" set="method" line="32"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="10">
			<f a="?x:?y:?z" v="0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0., y : 0., x : 0. }</e></m></meta>
		</new>
	</class>
	<class path="h3d.col.Frustum" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Frustum.hx">
		<pleft public="1"><c path="h3d.col.Plane"/></pleft>
		<pright public="1"><c path="h3d.col.Plane"/></pright>
		<ptop public="1"><c path="h3d.col.Plane"/></ptop>
		<pbottom public="1"><c path="h3d.col.Plane"/></pbottom>
		<pnear public="1"><c path="h3d.col.Plane"/></pnear>
		<pfar public="1"><c path="h3d.col.Plane"/></pfar>
		<checkNearFar public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</checkNearFar>
		<loadMatrix public="1" set="method" line="24"><f a="mvp">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></loadMatrix>
		<transform public="1" set="method" line="39"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<transform3x3 public="1" set="method" line="59"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform3x3>
		<hasSphere public="1" set="method" line="79"><f a="s">
	<c path="h3d.col.Sphere"/>
	<x path="Bool"/>
</f></hasSphere>
		<hasBounds public="1" set="method" line="92"><f a="b">
	<c path="h3d.col.Bounds"/>
	<x path="Bool"/>
</f></hasBounds>
		<new public="1" set="method" line="13"><f a="?mvp">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.ObjectCollider" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/ObjectCollider.hx">
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<implements path="h3d.col.Collider"/>
		<obj public="1">
			<c path="h3d.scene.Object"/>
			<meta><m n=":s"/></meta>
		</obj>
		<collider public="1">
			<c path="h3d.col.Collider"/>
			<meta><m n=":s"/></meta>
		</collider>
		<tmpRay expr="new Ray()">
			<c path="h3d.col.Ray"/>
			<meta><m n=":value"><e>new Ray()</e></m></meta>
		</tmpRay>
		<rayIntersection public="1" set="method" line="14"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<contains public="1" set="method" line="28"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<inFrustum public="1" set="method" line="36"><f a="mvp">
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<new public="1" set="method" line="9"><f a="obj:collider">
	<c path="h3d.scene.Object"/>
	<c path="h3d.col.Collider"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.Plane" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Plane.hx">
		<fromPoints public="1" get="inline" set="null" line="99" static="1"><f a="p0:p1:p2">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Plane"/>
</f></fromPoints>
		<fromNormalPoint public="1" get="inline" set="null" line="106" static="1"><f a="n:p">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Plane"/>
</f></fromNormalPoint>
		<X public="1" get="inline" set="null" line="110" static="1">
			<f a="?v" v="0.0">
				<x path="Float"/>
				<c path="h3d.col.Plane"/>
			</f>
			<meta><m n=":value"><e>{ v : 0.0 }</e></m></meta>
		</X>
		<Y public="1" get="inline" set="null" line="114" static="1">
			<f a="?v" v="0.0">
				<x path="Float"/>
				<c path="h3d.col.Plane"/>
			</f>
			<meta><m n=":value"><e>{ v : 0.0 }</e></m></meta>
		</Y>
		<Z public="1" get="inline" set="null" line="118" static="1">
			<f a="?v" v="0.0">
				<x path="Float"/>
				<c path="h3d.col.Plane"/>
			</f>
			<meta><m n=":value"><e>{ v : 0.0 }</e></m></meta>
		</Z>
		<frustumLeft public="1" get="inline" set="null" line="122" static="1"><f a="mvp">
	<c path="h3d.Matrix"/>
	<c path="h3d.col.Plane"/>
</f></frustumLeft>
		<frustumRight public="1" get="inline" set="null" line="126" static="1"><f a="mvp">
	<c path="h3d.Matrix"/>
	<c path="h3d.col.Plane"/>
</f></frustumRight>
		<frustumBottom public="1" get="inline" set="null" line="130" static="1"><f a="mvp">
	<c path="h3d.Matrix"/>
	<c path="h3d.col.Plane"/>
</f></frustumBottom>
		<frustumTop public="1" get="inline" set="null" line="134" static="1"><f a="mvp">
	<c path="h3d.Matrix"/>
	<c path="h3d.col.Plane"/>
</f></frustumTop>
		<frustumNear public="1" get="inline" set="null" line="138" static="1"><f a="mvp">
	<c path="h3d.Matrix"/>
	<c path="h3d.col.Plane"/>
</f></frustumNear>
		<frustumFar public="1" get="inline" set="null" line="142" static="1"><f a="mvp">
	<c path="h3d.Matrix"/>
	<c path="h3d.col.Plane"/>
</f></frustumFar>
		<nx><x path="Float"/></nx>
		<ny><x path="Float"/></ny>
		<nz><x path="Float"/></nz>
		<d><x path="Float"/></d>
		<getNormal public="1" get="inline" set="null" line="23">
			<f a=""><c path="h3d.col.Point"/></f>
			<haxe_doc>Returns the plan normal</haxe_doc>
		</getNormal>
		<getNormalDistance public="1" get="inline" set="null" line="27"><f a=""><x path="Float"/></f></getNormalDistance>
		<load public="1" get="inline" set="null" line="31"><f a="p">
	<c path="h3d.col.Plane"/>
	<x path="Void"/>
</f></load>
		<transform public="1" set="method" line="38"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<transform3x3 public="1" set="method" line="45"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform3x3>
		<transformInverseTranspose get="inline" set="null" line="52"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transformInverseTranspose>
		<normalize public="1" get="inline" set="null" line="64">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Normalize the plan, so we can use distance().</haxe_doc>
		</normalize>
		<toString public="1" set="method" line="72"><f a=""><c path="String"/></f></toString>
		<distance public="1" get="inline" set="null" line="79">
			<f a="p">
				<c path="h3d.col.Point"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the signed distance between a point an the plane. This requires the plan to be normalized. If the distance is negative it means that we are "under" the plan.</haxe_doc>
		</distance>
		<side public="1" get="inline" set="null" line="83"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></side>
		<project public="1" get="inline" set="null" line="87"><f a="p">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
</f></project>
		<projectTo public="1" get="inline" set="null" line="92"><f a="p:out">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></projectTo>
		<new public="1" get="inline" set="null" line="13"><f a="nx:ny:nz:d">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.col</e></m>
		</meta>
	</class>
	<class path="h3d.col.Point" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Point.hx">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<scale public="1" get="inline" set="null" line="16"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<inFrustum public="1" set="method" line="22"><f a="mvp">
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<set public="1" get="inline" set="null" line="38"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<sub public="1" get="inline" set="null" line="44"><f a="p">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
</f></sub>
		<add public="1" get="inline" set="null" line="48"><f a="p">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
</f></add>
		<cross public="1" get="inline" set="null" line="52"><f a="p">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
</f></cross>
		<lengthSq public="1" get="inline" set="null" line="56"><f a=""><x path="Float"/></f></lengthSq>
		<setLength public="1" get="inline" set="null" line="60"><f a="len">
	<x path="Float"/>
	<x path="Void"/>
</f></setLength>
		<length public="1" get="inline" set="null" line="67"><f a=""><x path="Float"/></f></length>
		<dot public="1" get="inline" set="null" line="71"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Float"/>
</f></dot>
		<distanceSq public="1" get="inline" set="null" line="75"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Float"/>
</f></distanceSq>
		<distance public="1" get="inline" set="null" line="82"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Float"/>
</f></distance>
		<normalize public="1" set="method" line="87"><f a=""><x path="Void"/></f></normalize>
		<normalizeFast public="1" get="inline" set="null" line="95"><f a=""><x path="Void"/></f></normalizeFast>
		<transform public="1" get="inline" set="null" line="103"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<transform3x3 public="1" get="inline" set="null" line="112"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform3x3>
		<toVector public="1" get="inline" set="null" line="121"><f a=""><c path="h3d.Vector"/></f></toVector>
		<clone public="1" get="inline" set="null" line="125"><f a=""><c path="h3d.col.Point"/></f></clone>
		<load public="1" get="inline" set="null" line="129"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></load>
		<toString public="1" set="method" line="135"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="10">
			<f a="?x:?y:?z" v="0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0., y : 0., x : 0. }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.TriPlane" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Polygon.hx" module="h3d.col.Polygon">
		<implements path="h3d.col.Collider"/>
		<next public="1" expr="null">
			<c path="h3d.col.TriPlane"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</next>
		<p0x><x path="Float"/></p0x>
		<p0y><x path="Float"/></p0y>
		<p0z><x path="Float"/></p0z>
		<d1x><x path="Float"/></d1x>
		<d1y><x path="Float"/></d1y>
		<d1z><x path="Float"/></d1z>
		<d2x><x path="Float"/></d2x>
		<d2y><x path="Float"/></d2y>
		<d2z><x path="Float"/></d2z>
		<dot00><x path="Float"/></dot00>
		<dot01><x path="Float"/></dot01>
		<dot11><x path="Float"/></dot11>
		<invDenom><x path="Float"/></invDenom>
		<nx><x path="Float"/></nx>
		<ny><x path="Float"/></ny>
		<nz><x path="Float"/></nz>
		<d><x path="Float"/></d>
		<init public="1" get="inline" set="null" line="31"><f a="p0:p1:p2">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></init>
		<clone public="1" get="inline" set="null" line="56"><f a=""><c path="h3d.col.TriPlane"/></f></clone>
		<load public="1" get="inline" set="null" line="64"><f a="tp">
	<c path="h3d.col.TriPlane"/>
	<x path="Void"/>
</f></load>
		<transform public="1" set="method" line="84"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<contains public="1" get="inline" set="null" line="94"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<side public="1" get="inline" set="null" line="98"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></side>
		<inFrustum public="1" set="method" line="102"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<rayIntersection public="1" get="inline" set="null" line="107"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<isPointInTriangle get="inline" set="null" line="123"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></isPointInTriangle>
		<getPoints public="1" set="method" line="137"><f a=""><c path="Array"><c path="h3d.col.Point"/></c></f></getPoints>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.Polygon" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Polygon.hx">
		<implements path="h3d.col.Collider"/>
		<triPlanes><c path="h3d.col.TriPlane"/></triPlanes>
		<addBuffers public="1" set="method" line="159">
			<f a="vertexes:indexes:?stride" v="::3">
				<x path="haxe.ds.Vector"><t path="hxd.impl.Float32"/></x>
				<x path="haxe.ds.Vector"><t path="hxd.impl.UInt16"/></x>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ stride : 3 }</e></m></meta>
		</addBuffers>
		<isConvex public="1" set="method" line="180"><f a=""><x path="Bool"/></f></isConvex>
		<clone public="1" set="method" line="185"><f a=""><c path="h3d.col.Polygon"/></f></clone>
		<transform public="1" set="method" line="192"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<getPoints public="1" set="method" line="200"><f a=""><c path="Array"><c path="h3d.col.Point"/></c></f></getPoints>
		<contains public="1" set="method" line="210"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<rayIntersection public="1" set="method" line="222"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<inFrustum public="1" set="method" line="236"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<new public="1" set="method" line="156"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.PolygonBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/PolygonBuffer.hx">
		<implements path="h3d.col.Collider"/>
		<buffer><x path="haxe.ds.Vector"><t path="hxd.impl.Float32"/></x></buffer>
		<indexes><x path="haxe.ds.Vector"><t path="hxd.impl.UInt16"/></x></indexes>
		<startIndex><x path="Int"/></startIndex>
		<triCount><x path="Int"/></triCount>
		<source public="1"><a>
	<geometryName><c path="String"/></geometryName>
	<entry><c path="hxd.fs.FileEntry"/></entry>
</a></source>
		<setData public="1" set="method" line="14">
			<f a="buffer:indexes:?startIndex:?triCount" v="::0:-1">
				<x path="haxe.ds.Vector"><t path="hxd.impl.Float32"/></x>
				<x path="haxe.ds.Vector"><t path="hxd.impl.UInt16"/></x>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ triCount : -1, startIndex : 0 }</e></m></meta>
		</setData>
		<contains public="1" set="method" line="21"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<inFrustum public="1" set="method" line="44"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<rayIntersection public="1" set="method" line="50"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.col.Ray" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Ray.hx">
		<fromPoints public="1" get="inline" set="null" line="137" static="1"><f a="p1:p2">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Ray"/>
</f></fromPoints>
		<fromValues public="1" get="inline" set="null" line="149" static="1"><f a="x:y:z:dx:dy:dz">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="h3d.col.Ray"/>
</f></fromValues>
		<px public="1"><x path="Float"/></px>
		<py public="1"><x path="Float"/></py>
		<pz public="1"><x path="Float"/></pz>
		<lx public="1"><x path="Float"/></lx>
		<ly public="1"><x path="Float"/></ly>
		<lz public="1"><x path="Float"/></lz>
		<clone public="1" get="inline" set="null" line="17"><f a=""><c path="h3d.col.Ray"/></f></clone>
		<load public="1" get="inline" set="null" line="28"><f a="r">
	<c path="h3d.col.Ray"/>
	<x path="Void"/>
</f></load>
		<normalize set="method" line="37"><f a=""><x path="Void"/></f></normalize>
		<transform public="1" get="inline" set="null" line="46"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></transform>
		<getPos public="1" get="inline" set="null" line="60"><f a=""><c path="h3d.col.Point"/></f></getPos>
		<getDir public="1" get="inline" set="null" line="64"><f a=""><c path="h3d.col.Point"/></f></getDir>
		<getPoint public="1" get="inline" set="null" line="68"><f a="distance">
	<x path="Float"/>
	<c path="h3d.col.Point"/>
</f></getPoint>
		<toString public="1" set="method" line="72"><f a=""><c path="String"/></f></toString>
		<intersect public="1" get="inline" set="null" line="76"><f a="p">
	<c path="h3d.col.Plane"/>
	<x path="Null"><c path="h3d.col.Point"/></x>
</f></intersect>
		<collideFrustum public="1" get="inline" set="null" line="88"><f a="mvp">
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></collideFrustum>
		<collide public="1" get="inline" set="null" line="113"><f a="b">
	<c path="h3d.col.Bounds"/>
	<x path="Bool"/>
</f></collide>
		<new get="inline" set="null" line="14"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.col</e></m>
		</meta>
	</class>
	<class path="h3d.col.SkinCollider" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/SkinCollider.hx">
		<implements path="h3d.col.Collider"/>
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<obj>
			<c path="h3d.scene.Skin"/>
			<meta><m n=":s"/></meta>
		</obj>
		<col>
			<c path="h3d.col.PolygonBuffer"/>
			<meta><m n=":s"/></meta>
		</col>
		<transform><c path="h3d.col.PolygonBuffer"/></transform>
		<lastFrame><x path="Int"/></lastFrame>
		<contains public="1" set="method" line="19"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<inFrustum public="1" set="method" line="24"><f a="p">
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<rayIntersection public="1" set="method" line="29"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<applyTransform set="method" line="34"><f a=""><x path="Void"/></f></applyTransform>
		<new public="1" set="method" line="12"><f a="obj:col">
	<c path="h3d.scene.Skin"/>
	<c path="h3d.col.PolygonBuffer"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>h3d.col.PolygonBuffer</e></m>
			<m n=":access"><e>h3d.scene.Skin</e></m>
		</meta>
	</class>
	<class path="h3d.col.Sphere" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/col/Sphere.hx">
		<implements path="h3d.col.Collider"/>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<r public="1"><x path="Float"/></r>
		<getCenter public="1" get="inline" set="null" line="17"><f a=""><c path="h3d.col.Point"/></f></getCenter>
		<contains public="1" get="inline" set="null" line="21"><f a="p">
	<c path="h3d.col.Point"/>
	<x path="Bool"/>
</f></contains>
		<rayIntersection public="1" set="method" line="28"><f a="r:bestMatch">
	<c path="h3d.col.Ray"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></rayIntersection>
		<inFrustum public="1" set="method" line="46"><f a="mvp">
	<c path="h3d.Matrix"/>
	<x path="Bool"/>
</f></inFrustum>
		<toString public="1" set="method" line="75"><f a=""><c path="String"/></f></toString>
		<new public="1" get="inline" set="null" line="10">
			<f a="?x:?y:?z:?r" v="0.:0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ r : 0., z : 0., y : 0., x : 0. }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="h3d.impl.AllocPos" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/AllocPos.hx"><a><__alloc><x path="Int"/></__alloc></a></typedef>
	<typedef path="h3d.impl.IndexBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver"><a/></typedef>
	<typedef path="h3d.impl.VertexBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver"><a/></typedef>
	<typedef path="h3d.impl.Texture" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver"><a/></typedef>
	<typedef path="h3d.impl.DepthBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver"><a/></typedef>
	<typedef path="h3d.impl.Query" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver"><a/></typedef>
	<enum path="h3d.impl.Feature" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver">
		<StandardDerivatives/>
		<FloatTextures/>
		<AllocDepthBuffer/>
		<HardwareAccelerated/>
		<MultipleRenderTargets/>
		<Queries/>
		<SRGBTextures/>
		<ShaderModel3/>
		<BottomLeftCoords/>
		<Wireframe/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.impl.QueryKind" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver">
		<TimeStamp><haxe_doc>The result will give the GPU Timestamp (in nanoseconds, 1e-9 seconds) at the time the endQuery is performed</haxe_doc></TimeStamp>
		<Samples><haxe_doc>The result will give the number of samples that passes the depth buffer between beginQuery/endQuery range</haxe_doc></Samples>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="h3d.impl.RenderFlag" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/Driver.hx" module="h3d.impl.Driver">
		<CameraHandness><haxe_doc>0 = LeftHanded (default), 1 = RightHanded. Affects the meaning of triangle culling value.</haxe_doc></CameraHandness>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h3d.impl.Driver" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/Driver.hx">
		<logEnable public="1"><x path="Bool"/></logEnable>
		<hasFeature public="1" set="method" line="132"><f a="f">
	<e path="h3d.impl.Feature"/>
	<x path="Bool"/>
</f></hasFeature>
		<setRenderFlag public="1" set="method" line="136"><f a="r:value">
	<e path="h3d.impl.RenderFlag"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setRenderFlag>
		<isSupportedFormat public="1" set="method" line="139"><f a="fmt">
	<t path="h3d.mat.TextureFormat"/>
	<x path="Bool"/>
</f></isSupportedFormat>
		<isDisposed public="1" set="method" line="143"><f a=""><x path="Bool"/></f></isDisposed>
		<dispose public="1" set="method" line="147"><f a=""><x path="Void"/></f></dispose>
		<begin public="1" set="method" line="150"><f a="frame">
	<x path="Int"/>
	<x path="Void"/>
</f></begin>
		<log public="1" get="inline" set="null" line="153"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></log>
		<generateMipMaps public="1" set="method" line="159"><f a="texture">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></generateMipMaps>
		<getNativeShaderCode public="1" set="method" line="163"><f a="shader">
	<c path="hxsl.RuntimeShader"/>
	<c path="String"/>
</f></getNativeShaderCode>
		<logImpl set="method" line="167"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></logImpl>
		<clear public="1" set="method" line="170"><f a="?color:?depth:?stencil">
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<captureRenderBuffer public="1" set="method" line="173"><f a="pixels">
	<c path="hxd.Pixels"/>
	<x path="Void"/>
</f></captureRenderBuffer>
		<capturePixels public="1" set="method" line="176"><f a="tex:layer:mipLevel:?region">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="h2d.col.IBounds"/>
	<c path="hxd.Pixels"/>
</f></capturePixels>
		<getDriverName public="1" set="method" line="181"><f a="details">
	<x path="Bool"/>
	<c path="String"/>
</f></getDriverName>
		<init public="1" set="method" line="185">
			<f a="onCreate:?forceSoftware" v=":false">
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceSoftware : false }</e></m></meta>
		</init>
		<resize public="1" set="method" line="188"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<selectShader public="1" set="method" line="191"><f a="shader">
	<c path="hxsl.RuntimeShader"/>
	<x path="Bool"/>
</f></selectShader>
		<selectMaterial public="1" set="method" line="195"><f a="pass">
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></selectMaterial>
		<uploadShaderBuffers public="1" set="method" line="198"><f a="buffers:which">
	<c path="h3d.shader.Buffers"/>
	<x path="h3d.shader.BufferKind"/>
	<x path="Void"/>
</f></uploadShaderBuffers>
		<getShaderInputNames public="1" set="method" line="201"><f a=""><c path="Array"><c path="String"/></c></f></getShaderInputNames>
		<selectBuffer public="1" set="method" line="205"><f a="buffer">
	<c path="h3d.Buffer"/>
	<x path="Void"/>
</f></selectBuffer>
		<selectMultiBuffers public="1" set="method" line="208"><f a="buffers">
	<c path="h3d.BufferOffset"/>
	<x path="Void"/>
</f></selectMultiBuffers>
		<draw public="1" set="method" line="211"><f a="ibuf:startIndex:ntriangles">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></draw>
		<drawInstanced public="1" set="method" line="214"><f a="ibuf:commands">
	<t path="h3d.impl.IndexBuffer"/>
	<c path="h3d.impl.InstanceBuffer"/>
	<x path="Void"/>
</f></drawInstanced>
		<setRenderZone public="1" set="method" line="217"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setRenderZone>
		<setRenderTarget public="1" set="method" line="220">
			<f a="tex:?layer:?mipLevel" v=":0:0">
				<x path="Null"><c path="h3d.mat.Texture"/></x>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mipLevel : 0, layer : 0 }</e></m></meta>
		</setRenderTarget>
		<setRenderTargets public="1" set="method" line="223"><f a="textures">
	<c path="Array"><c path="h3d.mat.Texture"/></c>
	<x path="Void"/>
</f></setRenderTargets>
		<allocDepthBuffer public="1" set="method" line="226"><f a="b">
	<c path="h3d.mat.DepthBuffer"/>
	<t path="h3d.impl.DepthBuffer"/>
</f></allocDepthBuffer>
		<disposeDepthBuffer public="1" set="method" line="230"><f a="b">
	<c path="h3d.mat.DepthBuffer"/>
	<x path="Void"/>
</f></disposeDepthBuffer>
		<getDefaultDepthBuffer public="1" set="method" line="233"><f a=""><c path="h3d.mat.DepthBuffer"/></f></getDefaultDepthBuffer>
		<present public="1" set="method" line="237"><f a=""><x path="Void"/></f></present>
		<end public="1" set="method" line="240"><f a=""><x path="Void"/></f></end>
		<setDebug public="1" set="method" line="243"><f a="b">
	<x path="Bool"/>
	<x path="Void"/>
</f></setDebug>
		<allocTexture public="1" set="method" line="246"><f a="t">
	<c path="h3d.mat.Texture"/>
	<t path="h3d.impl.Texture"/>
</f></allocTexture>
		<allocIndexes public="1" set="method" line="250"><f a="count:is32">
	<x path="Int"/>
	<x path="Bool"/>
	<t path="h3d.impl.IndexBuffer"/>
</f></allocIndexes>
		<allocVertexes public="1" set="method" line="254"><f a="m">
	<c path="h3d.impl.ManagedBuffer"/>
	<t path="h3d.impl.VertexBuffer"/>
</f></allocVertexes>
		<allocInstanceBuffer public="1" set="method" line="258"><f a="b:bytes">
	<c path="h3d.impl.InstanceBuffer"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></allocInstanceBuffer>
		<disposeTexture public="1" set="method" line="261"><f a="t">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></disposeTexture>
		<disposeIndexes public="1" set="method" line="264"><f a="i">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Void"/>
</f></disposeIndexes>
		<disposeVertexes public="1" set="method" line="267"><f a="v">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Void"/>
</f></disposeVertexes>
		<disposeInstanceBuffer public="1" set="method" line="270"><f a="b">
	<c path="h3d.impl.InstanceBuffer"/>
	<x path="Void"/>
</f></disposeInstanceBuffer>
		<uploadIndexBuffer public="1" set="method" line="273"><f a="i:startIndice:indiceCount:buf:bufPos">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="hxd.IndexBuffer"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadIndexBuffer>
		<uploadIndexBytes public="1" set="method" line="276"><f a="i:startIndice:indiceCount:buf:bufPos">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadIndexBytes>
		<uploadVertexBuffer public="1" set="method" line="279"><f a="v:startVertex:vertexCount:buf:bufPos">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="hxd.FloatBuffer"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadVertexBuffer>
		<uploadVertexBytes public="1" set="method" line="282"><f a="v:startVertex:vertexCount:buf:bufPos">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadVertexBytes>
		<uploadTextureBitmap public="1" set="method" line="285"><f a="t:bmp:mipLevel:side">
	<c path="h3d.mat.Texture"/>
	<c path="hxd.BitmapData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadTextureBitmap>
		<uploadTexturePixels public="1" set="method" line="288"><f a="t:pixels:mipLevel:side">
	<c path="h3d.mat.Texture"/>
	<c path="hxd.Pixels"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadTexturePixels>
		<readVertexBytes public="1" set="method" line="291"><f a="v:startVertex:vertexCount:buf:bufPos">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readVertexBytes>
		<readIndexBytes public="1" set="method" line="295"><f a="v:startVertex:vertexCount:buf:bufPos">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readIndexBytes>
		<copyTexture public="1" set="method" line="302">
			<f a="from:to">
				<c path="h3d.mat.Texture"/>
				<c path="h3d.mat.Texture"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if we could copy the texture, false otherwise (not supported by driver or mismatch in size/format)</haxe_doc>
		</copyTexture>
		<allocQuery public="1" set="method" line="308"><f a="queryKind">
	<e path="h3d.impl.QueryKind"/>
	<t path="h3d.impl.Query"/>
</f></allocQuery>
		<deleteQuery public="1" set="method" line="312"><f a="q">
	<t path="h3d.impl.Query"/>
	<x path="Void"/>
</f></deleteQuery>
		<beginQuery public="1" set="method" line="315"><f a="q">
	<t path="h3d.impl.Query"/>
	<x path="Void"/>
</f></beginQuery>
		<endQuery public="1" set="method" line="318"><f a="q">
	<t path="h3d.impl.Query"/>
	<x path="Void"/>
</f></endQuery>
		<queryResultAvailable public="1" set="method" line="321"><f a="q">
	<t path="h3d.impl.Query"/>
	<x path="Bool"/>
</f></queryResultAvailable>
		<queryResult public="1" set="method" line="325"><f a="q">
	<t path="h3d.impl.Query"/>
	<x path="Float"/>
</f></queryResult>
	</class>
	<class path="h3d.impl.InstanceBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/InstanceBuffer.hx">
		<data><d/></data>
		<driver><c path="h3d.impl.Driver"/></driver>
		<triCount public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</triCount>
		<commandCount public="1" set="null"><x path="Int"/></commandCount>
		<dispose public="1" set="method" line="33"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="19">
			<f a="commandCount:bytes">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Bytes are structures of 5 i32 with the following values:
		- indexCount : number of indexes per instance
		- instanceCount : number of indexed draws
		- startIndexLocation : offset in indexes
		- baseVertexLocation : offset in buffer
		- startInstanceLocation : offset in per instance buffer</haxe_doc>
		</new>
		<meta><m n=":allow"><e>h3d.impl.Driver</e></m></meta>
	</class>
	<class path="h3d.impl.LogDriver" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/LogDriver.hx">
		<extends path="h3d.impl.Driver"/>
		<debug public="1" set="method" line="359" static="1"><f a="f">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></debug>
		<d><c path="h3d.impl.Driver"/></d>
		<loggedShaders expr="new Map&lt;Int,Bool&gt;()">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<x path="Bool"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Bool>()]]></e></m></meta>
		</loggedShaders>
		<currentShader><c path="hxsl.RuntimeShader"/></currentShader>
		<logLines public="1" expr="null">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</logLines>
		<logImpl set="method" line="17" override="1"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></logImpl>
		<hasFeature public="1" set="method" line="24" override="1"><f a="f">
	<e path="h3d.impl.Feature"/>
	<x path="Bool"/>
</f></hasFeature>
		<isSupportedFormat public="1" set="method" line="28" override="1"><f a="fmt">
	<t path="h3d.mat.TextureFormat"/>
	<x path="Bool"/>
</f></isSupportedFormat>
		<isDisposed public="1" set="method" line="32" override="1"><f a=""><x path="Bool"/></f></isDisposed>
		<dispose public="1" set="method" line="36" override="1"><f a=""><x path="Void"/></f></dispose>
		<begin public="1" set="method" line="41" override="1"><f a="frame">
	<x path="Int"/>
	<x path="Void"/>
</f></begin>
		<clear public="1" set="method" line="46" override="1"><f a="?color:?depth:?stencil">
	<c path="h3d.Vector"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<captureRenderBuffer public="1" set="method" line="51" override="1"><f a="pixels">
	<c path="hxd.Pixels"/>
	<x path="Void"/>
</f></captureRenderBuffer>
		<getDriverName public="1" set="method" line="56" override="1"><f a="details">
	<x path="Bool"/>
	<c path="String"/>
</f></getDriverName>
		<init public="1" set="method" line="60" override="1">
			<f a="onCreate:?forceSoftware" v=":false">
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceSoftware : false }</e></m></meta>
		</init>
		<resize public="1" set="method" line="68" override="1"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<selectShader public="1" set="method" line="73" override="1"><f a="shader">
	<c path="hxsl.RuntimeShader"/>
	<x path="Bool"/>
</f></selectShader>
		<getNativeShaderCode public="1" set="method" line="168" override="1"><f a="shader">
	<c path="hxsl.RuntimeShader"/>
	<c path="String"/>
</f></getNativeShaderCode>
		<selectMaterial public="1" set="method" line="172" override="1"><f a="pass">
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></selectMaterial>
		<sizeOf set="method" line="177"><f a="t">
	<e path="hxsl.Type"/>
	<x path="Int"/>
</f></sizeOf>
		<uploadShaderBuffers public="1" set="method" line="190" override="1"><f a="buffers:which">
	<c path="h3d.shader.Buffers"/>
	<x path="h3d.shader.BufferKind"/>
	<x path="Void"/>
</f></uploadShaderBuffers>
		<textureInfos set="method" line="236"><f a="buf:tid">
	<x path="haxe.ds.Vector"><c path="h3d.mat.Texture"/></x>
	<x path="Int"/>
	<c path="String"/>
</f></textureInfos>
		<getShaderInputNames public="1" set="method" line="250" override="1"><f a=""><c path="Array"><c path="String"/></c></f></getShaderInputNames>
		<selectBuffer public="1" set="method" line="254" override="1"><f a="buffer">
	<c path="h3d.Buffer"/>
	<x path="Void"/>
</f></selectBuffer>
		<selectMultiBuffers public="1" set="method" line="259" override="1"><f a="buffers">
	<c path="h3d.BufferOffset"/>
	<x path="Void"/>
</f></selectMultiBuffers>
		<draw public="1" set="method" line="264" override="1"><f a="ibuf:startIndex:ntriangles">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></draw>
		<setRenderZone public="1" set="method" line="269" override="1"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setRenderZone>
		<setRenderTarget public="1" set="method" line="274" override="1">
			<f a="tex:?face:?mipMap" v=":0:0">
				<x path="Null"><c path="h3d.mat.Texture"/></x>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mipMap : 0, face : 0 }</e></m></meta>
		</setRenderTarget>
		<setRenderTargets public="1" set="method" line="279" override="1"><f a="textures">
	<c path="Array"><c path="h3d.mat.Texture"/></c>
	<x path="Void"/>
</f></setRenderTargets>
		<end public="1" set="method" line="284" override="1"><f a=""><x path="Void"/></f></end>
		<present public="1" set="method" line="289" override="1"><f a=""><x path="Void"/></f></present>
		<setDebug public="1" set="method" line="294" override="1"><f a="b">
	<x path="Bool"/>
	<x path="Void"/>
</f></setDebug>
		<allocTexture public="1" set="method" line="299" override="1"><f a="t">
	<c path="h3d.mat.Texture"/>
	<t path="h3d.impl.Texture"/>
</f></allocTexture>
		<allocIndexes public="1" set="method" line="304" override="1"><f a="count:is32">
	<x path="Int"/>
	<x path="Bool"/>
	<t path="h3d.impl.IndexBuffer"/>
</f></allocIndexes>
		<allocVertexes public="1" set="method" line="309" override="1"><f a="m">
	<c path="h3d.impl.ManagedBuffer"/>
	<t path="h3d.impl.VertexBuffer"/>
</f></allocVertexes>
		<disposeTexture public="1" set="method" line="314" override="1"><f a="t">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></disposeTexture>
		<disposeIndexes public="1" set="method" line="319" override="1"><f a="i">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Void"/>
</f></disposeIndexes>
		<disposeVertexes public="1" set="method" line="324" override="1"><f a="v">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Void"/>
</f></disposeVertexes>
		<uploadIndexBuffer public="1" set="method" line="329" override="1"><f a="i:startIndice:indiceCount:buf:bufPos">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="hxd.IndexBuffer"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadIndexBuffer>
		<uploadIndexBytes public="1" set="method" line="334" override="1"><f a="i:startIndice:indiceCount:buf:bufPos">
	<t path="h3d.impl.IndexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadIndexBytes>
		<uploadVertexBuffer public="1" set="method" line="339" override="1"><f a="v:startVertex:vertexCount:buf:bufPos">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="hxd.FloatBuffer"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadVertexBuffer>
		<uploadVertexBytes public="1" set="method" line="344" override="1"><f a="v:startVertex:vertexCount:buf:bufPos">
	<t path="h3d.impl.VertexBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadVertexBytes>
		<uploadTextureBitmap public="1" set="method" line="349" override="1"><f a="t:bmp:mipLevel:side">
	<c path="h3d.mat.Texture"/>
	<c path="hxd.BitmapData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadTextureBitmap>
		<uploadTexturePixels public="1" set="method" line="354" override="1"><f a="t:pixels:mipLevel:side">
	<c path="h3d.mat.Texture"/>
	<c path="hxd.Pixels"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadTexturePixels>
		<new public="1" set="method" line="11"><f a="driver">
	<c path="h3d.impl.Driver"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.impl._ManagedBuffer.FreeCell" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/ManagedBuffer.hx" private="1" module="h3d.impl.ManagedBuffer">
		<pos><x path="Int"/></pos>
		<count><x path="Int"/></count>
		<next><c path="h3d.impl._ManagedBuffer.FreeCell"/></next>
		<new set="method" line="8"><f a="pos:count:next">
	<x path="Int"/>
	<x path="Int"/>
	<c path="h3d.impl._ManagedBuffer.FreeCell"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d</e></m>
		</meta>
	</class>
	<class path="h3d.impl.ManagedBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/ManagedBuffer.hx">
		<mem><c path="h3d.impl.MemoryManager"/></mem>
		<stride public="1" set="null"><x path="Int"/></stride>
		<size public="1" set="null"><x path="Int"/></size>
		<flags public="1" set="null"><x path="haxe.EnumFlags"><e path="h3d.BufferFlag"/></x></flags>
		<vbuf><t path="h3d.impl.VertexBuffer"/></vbuf>
		<freeList><c path="h3d.impl._ManagedBuffer.FreeCell"/></freeList>
		<next><c path="h3d.impl.ManagedBuffer"/></next>
		<uploadVertexBuffer public="1" set="method" line="44">
			<f a="start:vertices:buf:?bufPos" v=":::0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="hxd.FloatBuffer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ bufPos : 0 }</e></m></meta>
		</uploadVertexBuffer>
		<uploadVertexBytes public="1" set="method" line="48">
			<f a="start:vertices:data:?dataPos" v=":::0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dataPos : 0 }</e></m></meta>
		</uploadVertexBytes>
		<readVertexBytes public="1" set="method" line="52">
			<f a="start:vertices:data:?dataPos" v=":::0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ dataPos : 0 }</e></m></meta>
		</readVertexBytes>
		<alloc public="1" set="method" line="56"><f a="vertices:align">
	<x path="Int"/>
	<x path="Int"/>
	<c path="h3d.Buffer"/>
</f></alloc>
		<getFreeVertices public="1" set="method" line="72"><f a=""><x path="Int"/></f></getFreeVertices>
		<allocPosition set="method" line="82"><f a="nvert:align">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></allocPosition>
		<allocBuffer set="method" line="107"><f a="b">
	<c path="h3d.Buffer"/>
	<x path="Bool"/>
</f></allocBuffer>
		<freeBuffer set="method" line="123">
			<f a="b">
				<c path="h3d.Buffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.Buffer.dispose</e></m></meta>
		</freeBuffer>
		<dispose public="1" set="method" line="174"><f a=""><x path="Void"/></f></dispose>
		<isDisposed public="1" get="inline" set="null" line="178"><f a=""><x path="Bool"/></f></isDisposed>
		<new public="1" set="method" line="30"><f a="stride:size:?flags">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><e path="h3d.BufferFlag"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.impl.MemoryManager</e></m>
		</meta>
	</class>
	<class path="h3d.impl.MemoryManager" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/MemoryManager.hx">
		<MAX_MEMORY get="inline" set="null" expr="4096 * (1024. * 1024.)" line="5" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>4096 * (1024. * 1024.)</e></m></meta>
		</MAX_MEMORY>
		<MAX_BUFFERS get="inline" set="null" expr="1 &lt;&lt; 16" line="6" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e><![CDATA[1 << 16]]></e></m></meta>
		</MAX_BUFFERS>
		<SIZE get="inline" set="null" expr="65533" line="7" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>65533</e></m></meta>
		</SIZE>
		<ALL_FLAGS expr="Type.allEnums(Buffer.BufferFlag)" line="8" static="1">
			<c path="Array"><e path="h3d.BufferFlag"/></c>
			<meta><m n=":value"><e>Type.allEnums(Buffer.BufferFlag)</e></m></meta>
		</ALL_FLAGS>
		<driver>
			<c path="h3d.impl.Driver"/>
			<meta><m n=":allow"><e>h3d</e></m></meta>
		</driver>
		<buffers><c path="Array"><c path="h3d.impl.ManagedBuffer"/></c></buffers>
		<indexes><c path="Array"><c path="h3d.Indexes"/></c></indexes>
		<textures><c path="Array"><c path="h3d.mat.Texture"/></c></textures>
		<depths><c path="Array"><c path="h3d.mat.DepthBuffer"/></c></depths>
		<triIndexes public="1" set="null"><c path="h3d.Indexes"/></triIndexes>
		<quadIndexes public="1" set="null"><c path="h3d.Indexes"/></quadIndexes>
		<usedMemory public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</usedMemory>
		<texMemory public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</texMemory>
		<bufferCount public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bufferCount>
		<init public="1" set="method" line="27"><f a=""><x path="Void"/></f></init>
		<initIndexes set="method" line="35"><f a=""><x path="Void"/></f></initIndexes>
		<garbage public="1" set="dynamic" line="59">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Call user-defined garbage function that will cleanup some unused allocated objects.
		Might be called several times if we need to allocate a lot of memory</haxe_doc>
		</garbage>
		<cleanManagedBuffers public="1" set="method" line="67">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Clean empty (unused) buffers</haxe_doc>
		</cleanManagedBuffers>
		<allocManaged set="method" line="85">
			<f a="m">
				<c path="h3d.impl.ManagedBuffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.impl.ManagedBuffer</e></m></meta>
		</allocManaged>
		<freeManaged set="method" line="110">
			<f a="m">
				<c path="h3d.impl.ManagedBuffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.impl.ManagedBuffer</e></m></meta>
		</freeManaged>
		<allocBuffer set="method" line="131">
			<f a="b:stride">
				<c path="h3d.Buffer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":allow"><e>h3d.Buffer</e></m>
				<m n=":access"><e>h3d.Buffer</e></m>
			</meta>
		</allocBuffer>
		<deleteIndexes set="method" line="211">
			<f a="i">
				<c path="h3d.Indexes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.Indexes</e></m></meta>
		</deleteIndexes>
		<allocIndexes set="method" line="219">
			<f a="i">
				<c path="h3d.Indexes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.Indexes</e></m></meta>
		</allocIndexes>
		<bpp set="method" line="228"><f a="t">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
</f></bpp>
		<cleanTextures public="1" set="method" line="232">
			<f a="?force" v="true">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ force : true }</e></m></meta>
		</cleanTextures>
		<sortByLRU set="method" line="244"><f a="t1:t2">
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
</f></sortByLRU>
		<deleteTexture set="method" line="249">
			<f a="t">
				<c path="h3d.mat.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.mat.Texture.dispose</e></m></meta>
		</deleteTexture>
		<allocTexture set="method" line="256">
			<f a="t">
				<c path="h3d.mat.Texture"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.mat.Texture.alloc</e></m></meta>
		</allocTexture>
		<allocDepth set="method" line="270">
			<f a="b">
				<c path="h3d.mat.DepthBuffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.mat.DepthBuffer.alloc</e></m></meta>
		</allocDepth>
		<deleteDepth set="method" line="284">
			<f a="b">
				<c path="h3d.mat.DepthBuffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.mat.DepthBuffer.dispose</e></m></meta>
		</deleteDepth>
		<onContextLost public="1" set="method" line="292"><f a=""><x path="Void"/></f></onContextLost>
		<dispose public="1" set="method" line="297"><f a=""><x path="Void"/></f></dispose>
		<freeMemorySize set="method" line="325"><f a=""><x path="Int"/></f></freeMemorySize>
		<stats public="1" set="method" line="341"><f a=""><a>
	<totalMemory><x path="Float"/></totalMemory>
	<textureMemory><x path="Float"/></textureMemory>
	<textureCount><x path="Int"/></textureCount>
	<managedMemory><x path="Int"/></managedMemory>
	<freeManagedMemory><x path="Int"/></freeManagedMemory>
	<bufferCount><x path="Int"/></bufferCount>
</a></f></stats>
		<allocStats public="1" set="method" line="367">
			<f a=""><c path="Array"><a>
	<tex><x path="Bool"/></tex>
	<size><x path="Int"/></size>
	<line><x path="Int"/></line>
	<file><c path="String"/></file>
	<count><x path="Int"/></count>
</a></c></f>
			<meta><m n=":access"><e>h3d.Buffer</e></m></meta>
		</allocStats>
		<new public="1" set="method" line="23"><f a="driver">
	<c path="h3d.impl.Driver"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.impl.NullDriver" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/NullDriver.hx">
		<extends path="h3d.impl.Driver"/>
		<cur><c path="hxsl.RuntimeShader"/></cur>
		<hasFeature public="1" set="method" line="11" override="1"><f a="f">
	<e path="h3d.impl.Feature"/>
	<x path="Bool"/>
</f></hasFeature>
		<isSupportedFormat public="1" set="method" line="15" override="1"><f a="fmt">
	<t path="h3d.mat.TextureFormat"/>
	<x path="Bool"/>
</f></isSupportedFormat>
		<logImpl set="method" line="19" override="1"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></logImpl>
		<isDisposed public="1" set="method" line="27" override="1"><f a=""><x path="Bool"/></f></isDisposed>
		<getDriverName public="1" set="method" line="31" override="1"><f a="details">
	<x path="Bool"/>
	<c path="String"/>
</f></getDriverName>
		<init public="1" set="method" line="35" override="1">
			<f a="onCreate:?forceSoftware" v=":false">
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceSoftware : false }</e></m></meta>
		</init>
		<selectShader public="1" set="method" line="39" override="1"><f a="shader">
	<c path="hxsl.RuntimeShader"/>
	<x path="Bool"/>
</f></selectShader>
		<getShaderInputNames public="1" set="method" line="45" override="1"><f a=""><c path="Array"><c path="String"/></c></f></getShaderInputNames>
		<allocTexture public="1" set="method" line="53" override="1"><f a="t">
	<c path="h3d.mat.Texture"/>
	<t path="h3d.impl.Texture"/>
</f></allocTexture>
		<allocIndexes public="1" set="method" line="57" override="1"><f a="count:is32">
	<x path="Int"/>
	<x path="Bool"/>
	<t path="h3d.impl.IndexBuffer"/>
</f></allocIndexes>
		<allocVertexes public="1" set="method" line="61" override="1"><f a="m">
	<c path="h3d.impl.ManagedBuffer"/>
	<t path="h3d.impl.VertexBuffer"/>
</f></allocVertexes>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.impl.TextureCache" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/impl/TextureCache.hx">
		<cache><c path="Array"><c path="h3d.mat.Texture"/></c></cache>
		<position expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</position>
		<defaultDepthBuffer><c path="h3d.mat.DepthBuffer"/></defaultDepthBuffer>
		<ctx><c path="h3d.impl.RenderContext"/></ctx>
		<defaultFormat public="1"><e path="hxd.PixelFormat"/></defaultFormat>
		<get public="1" get="inline" set="null" line="19">
			<f a="?index" v="0">
				<x path="Int"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<meta><m n=":value"><e>{ index : 0 }</e></m></meta>
		</get>
		<getNamed public="1" set="method" line="23"><f a="name">
	<c path="String"/>
	<c path="h3d.mat.Texture"/>
</f></getNamed>
		<set public="1" set="method" line="30"><f a="t:index">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<begin public="1" set="method" line="34"><f a=""><x path="Void"/></f></begin>
		<allocTarget public="1" set="method" line="43">
			<f a="name:width:height:?defaultDepth:?format:?flags" v=":::true::">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<e path="hxd.PixelFormat"/>
				<c path="Array"><e path="h3d.mat.TextureFlags"/></c>
				<c path="h3d.mat.Texture"/>
			</f>
			<meta><m n=":value"><e>{ defaultDepth : true }</e></m></meta>
		</allocTarget>
		<allocTargetScale public="1" set="method" line="57">
			<f a="name:scale:?defaultDepth:?format" v="::true:">
				<c path="String"/>
				<x path="Float"/>
				<x path="Bool"/>
				<e path="hxd.PixelFormat"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<meta><m n=":value"><e>{ defaultDepth : true }</e></m></meta>
		</allocTargetScale>
		<dispose public="1" set="method" line="62"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="11"><f a="ctx">
	<c path="h3d.impl.RenderContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.impl.AnyProps" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/AnyProps.hx">
		<props public="1" set="accessor"><x path="Any"/></props>
		<set_props set="method" line="7"><f a="p">
	<x path="Any"/>
	<x path="Any"/>
</f></set_props>
		<setDefaultProps public="1" set="method" line="13"><f a="kind">
	<c path="String"/>
	<x path="Void"/>
</f></setDefaultProps>
		<getDefaultProps public="1" set="method" line="17"><f a="?kind">
	<c path="String"/>
	<x path="Any"/>
</f></getDefaultProps>
		<refreshProps public="1" set="method" line="21"><f a=""><x path="Void"/></f></refreshProps>
	</class>
	<class path="h3d.mat.BaseMaterial" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/BaseMaterial.hx">
		<extends path="hxd.impl.AnyProps"/>
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<passes>
			<c path="h3d.mat.Pass"/>
			<meta><m n=":s"/></meta>
		</passes>
		<name public="1">
			<c path="String"/>
			<meta><m n=":s"/></meta>
		</name>
		<mainPass public="1" get="accessor" set="null"><c path="h3d.mat.Pass"/></mainPass>
		<addPass public="1" params="T" set="method" line="16"><f a="p">
	<c path="addPass.T"/>
	<c path="addPass.T"/>
</f></addPass>
		<removePass public="1" set="method" line="30"><f a="p">
	<c path="h3d.mat.Pass"/>
	<x path="Bool"/>
</f></removePass>
		<get_mainPass get="inline" set="null" line="47"><f a=""><c path="h3d.mat.Pass"/></f></get_mainPass>
		<getPasses public="1" set="method" line="51"><f a=""><t path="Iterator"><c path="h3d.mat.Pass"/></t></f></getPasses>
		<getPass public="1" set="method" line="61"><f a="name">
	<c path="String"/>
	<c path="h3d.mat.Pass"/>
</f></getPass>
		<allocPass public="1" set="method" line="71">
			<f a="name:?inheritMain" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="h3d.mat.Pass"/>
			</f>
			<meta><m n=":value"><e>{ inheritMain : true }</e></m></meta>
		</allocPass>
		<clone public="1" set="method" line="79"><f a="?m">
	<c path="h3d.mat.BaseMaterial"/>
	<c path="h3d.mat.BaseMaterial"/>
</f></clone>
		<new set="method" line="11"><f a="?shader">
	<c path="hxsl.Shader"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="h3d.mat.BlendMode" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/BlendMode.hx"><e path="h2d.BlendMode"/></typedef>
	<enum path="h3d.mat.Face" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<None/>
		<Back/>
		<Front/>
		<Both/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.Blend" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<One/>
		<Zero/>
		<SrcAlpha/>
		<SrcColor/>
		<DstAlpha/>
		<DstColor/>
		<OneMinusSrcAlpha/>
		<OneMinusSrcColor/>
		<OneMinusDstAlpha/>
		<OneMinusDstColor/>
		<ConstantColor/>
		<ConstantAlpha/>
		<OneMinusConstantColor/>
		<OneMinusConstantAlpha/>
		<SrcAlphaSaturate/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.Compare" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<Always/>
		<Never/>
		<Equal/>
		<NotEqual/>
		<Greater/>
		<GreaterEqual/>
		<Less/>
		<LessEqual/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.StencilOp" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<Keep/>
		<Zero/>
		<Replace/>
		<Increment/>
		<IncrementWrap/>
		<Decrement/>
		<DecrementWrap/>
		<Invert/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.MipMap" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<None/>
		<Nearest/>
		<Linear/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.Filter" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<Nearest/>
		<Linear/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.Wrap" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<Clamp/>
		<Repeat/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.Operation" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<Add/>
		<Sub/>
		<ReverseSub/>
		<Min/>
		<Max/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="h3d.mat.TextureFlags" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data">
		<Target><haxe_doc>Allocate a texture that will be used as render target.</haxe_doc></Target>
		<Cube><haxe_doc>Allocate a cube texture. Might be restricted to power of two textures only.</haxe_doc></Cube>
		<MipMapped><haxe_doc>Activates Mip Mapping for this texture. Might not be available for target textures.</haxe_doc></MipMapped>
		<ManualMipMapGen><haxe_doc>By default, textures created with MipMapped will have their mipmaps generated when you upload the mipmap level 0. This flag disables this and manually upload mipmaps instead.</haxe_doc></ManualMipMapGen>
		<IsNPOT><haxe_doc>This is a not power of two texture. Automatically set when having width or height being not power of two.</haxe_doc></IsNPOT>
		<NoAlloc><haxe_doc>Don't initialy allocate the texture memory.</haxe_doc></NoAlloc>
		<Dynamic><haxe_doc>Inform that we will often perform upload operations on this texture</haxe_doc></Dynamic>
		<AlphaPremultiplied><haxe_doc>Assumes that the color value of the texture is premultiplied by the alpha component.</haxe_doc></AlphaPremultiplied>
		<WasCleared><haxe_doc>Tells if the target texture has been cleared (reserved for internal engine usage).</haxe_doc></WasCleared>
		<Loading><haxe_doc>The texture is being currently loaded. Set onLoaded to get event when loading is complete.</haxe_doc></Loading>
		<Serialize><haxe_doc>Allow texture data serialization when found in a scene (for user generated textures)</haxe_doc></Serialize>
		<IsArray><haxe_doc>Tells if it's a texture array</haxe_doc></IsArray>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<typedef path="h3d.mat.TextureFormat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Data.hx" module="h3d.mat.Data"><e path="hxd.PixelFormat"/></typedef>
	<class path="h3d.mat.Defaults" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Defaults.hx">
		<defaultKillAlphaThreshold public="1" expr="0.5" line="5" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
		</defaultKillAlphaThreshold>
		<loadingTextureColor public="1" expr="0xFFFF00FF" line="6" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xFFFF00FF</e></m></meta>
		</loadingTextureColor>
		<shadowShader public="1" get="accessor" set="accessor" static="1">
			<c path="hxsl.Shader"/>
			<meta><m n=":isVar"/></meta>
		</shadowShader>
		<get_shadowShader set="method" line="11" static="1"><f a=""><c path="hxsl.Shader"/></f></get_shadowShader>
		<set_shadowShader set="method" line="20" static="1"><f a="s">
	<c path="hxsl.Shader"/>
	<c path="hxsl.Shader"/>
</f></set_shadowShader>
		<makeVolumeDecal public="1" set="dynamic" line="24" static="1"><f a="bounds">
	<c path="h3d.col.Bounds"/>
	<c path="hxsl.Shader"/>
</f></makeVolumeDecal>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="h3d.mat.DepthFormat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/DepthBuffer.hx" module="h3d.mat.DepthBuffer">
		<Depth16/>
		<Depth24/>
		<Depth24Stencil8/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="h3d.mat.DepthBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/DepthBuffer.hx">
		<getDefault public="1" set="method" line="55" static="1">
			<f a=""><c path="h3d.mat.DepthBuffer"/></f>
			<haxe_doc>This will return the default depth buffer, which is automatically resized to the screen size.</haxe_doc>
		</getDefault>
		<b>
			<t path="h3d.impl.DepthBuffer"/>
			<meta><m n=":allow"><e>h3d.impl.MemoryManager</e></m></meta>
		</b>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<format public="1" set="null"><e path="h3d.mat.DepthFormat"/></format>
		<hasStencil public="1" set="method" line="30"><f a=""><x path="Bool"/></f></hasStencil>
		<alloc set="method" line="37"><f a=""><x path="Void"/></f></alloc>
		<dispose public="1" set="method" line="41"><f a=""><x path="Void"/></f></dispose>
		<isDisposed public="1" set="method" line="48"><f a=""><x path="Bool"/></f></isDisposed>
		<new public="1" set="method" line="23">
			<f a="width:height:?format">
				<x path="Int"/>
				<x path="Int"/>
				<e path="h3d.mat.DepthFormat"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new depth buffer, it can be attached to one or several render target Texture by setting their `depthBuffer` property.</haxe_doc>
		</new>
		<haxe_doc>Depth buffer are used to store per pixel depth information when rendering a scene (also called Z-buffer)</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="h3d.mat._Material.DefaultKind" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Material.hx" private="1" module="h3d.mat.Material">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="h3d.mat._Material.DefaultKind_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Material.hx" private="1" module="h3d.mat.Material" extern="1">
	<Opaque public="1" get="inline" set="null" expr="cast &quot;Opaque&quot;" line="4" static="1">
		<x path="h3d.mat._Material.DefaultKind"/>
		<meta>
			<m n=":value"><e>cast "Opaque"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Opaque>
	<Alpha public="1" get="inline" set="null" expr="cast &quot;Alpha&quot;" line="5" static="1">
		<x path="h3d.mat._Material.DefaultKind"/>
		<meta>
			<m n=":value"><e>cast "Alpha"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Alpha>
	<AlphaKill public="1" get="inline" set="null" expr="cast &quot;AlphaKill&quot;" line="6" static="1">
		<x path="h3d.mat._Material.DefaultKind"/>
		<meta>
			<m n=":value"><e>cast "AlphaKill"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AlphaKill>
	<Add public="1" get="inline" set="null" expr="cast &quot;Add&quot;" line="7" static="1">
		<x path="h3d.mat._Material.DefaultKind"/>
		<meta>
			<m n=":value"><e>cast "Add"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Add>
	<SoftAdd public="1" get="inline" set="null" expr="cast &quot;SoftAdd&quot;" line="8" static="1">
		<x path="h3d.mat._Material.DefaultKind"/>
		<meta>
			<m n=":value"><e>cast "SoftAdd"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SoftAdd>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="h3d.mat._Material.DefaultKind_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Material.hx" private="1" module="h3d.mat.Material" extern="1">
		<Opaque public="1" get="inline" set="null" expr="cast &quot;Opaque&quot;" line="4" static="1">
			<x path="h3d.mat._Material.DefaultKind"/>
			<meta>
				<m n=":value"><e>cast "Opaque"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Opaque>
		<Alpha public="1" get="inline" set="null" expr="cast &quot;Alpha&quot;" line="5" static="1">
			<x path="h3d.mat._Material.DefaultKind"/>
			<meta>
				<m n=":value"><e>cast "Alpha"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Alpha>
		<AlphaKill public="1" get="inline" set="null" expr="cast &quot;AlphaKill&quot;" line="6" static="1">
			<x path="h3d.mat._Material.DefaultKind"/>
			<meta>
				<m n=":value"><e>cast "AlphaKill"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AlphaKill>
		<Add public="1" get="inline" set="null" expr="cast &quot;Add&quot;" line="7" static="1">
			<x path="h3d.mat._Material.DefaultKind"/>
			<meta>
				<m n=":value"><e>cast "Add"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Add>
		<SoftAdd public="1" get="inline" set="null" expr="cast &quot;SoftAdd&quot;" line="8" static="1">
			<x path="h3d.mat._Material.DefaultKind"/>
			<meta>
				<m n=":value"><e>cast "SoftAdd"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SoftAdd>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="h3d.mat._Material.DefaultProps" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Material.hx" private="1" module="h3d.mat.Material"><a>
	<shadows><x path="Bool"/></shadows>
	<light><x path="Bool"/></light>
	<kind><x path="h3d.mat._Material.DefaultKind"/></kind>
	<culling><x path="Bool"/></culling>
</a></typedef>
	<class path="h3d.mat.Material" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Material.hx">
		<extends path="h3d.mat.BaseMaterial"/>
		<create public="1" set="method" line="337" static="1"><f a="?tex">
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Material"/>
</f></create>
		<mshader><c path="h3d.shader.BaseMesh"/></mshader>
		<normalShader><c path="h3d.shader.NormalMap"/></normalShader>
		<model public="1"><c path="hxd.res.Resource"/></model>
		<shadows public="1" get="accessor" set="accessor"><x path="Bool"/></shadows>
		<castShadows public="1" set="accessor"><x path="Bool"/></castShadows>
		<receiveShadows public="1" set="accessor"><x path="Bool"/></receiveShadows>
		<staticShadows public="1" set="accessor"><x path="Bool"/></staticShadows>
		<textureShader public="1" set="null"><c path="h3d.shader.Texture"/></textureShader>
		<specularShader public="1" set="null"><c path="h3d.shader.SpecularTexture"/></specularShader>
		<texture public="1" get="accessor" set="accessor"><c path="h3d.mat.Texture"/></texture>
		<specularTexture public="1" get="accessor" set="accessor"><c path="h3d.mat.Texture"/></specularTexture>
		<normalMap public="1" get="accessor" set="accessor"><c path="h3d.mat.Texture"/></normalMap>
		<color public="1" get="accessor" set="accessor"><c path="h3d.Vector"/></color>
		<specularAmount public="1" get="accessor" set="accessor"><x path="Float"/></specularAmount>
		<specularPower public="1" get="accessor" set="accessor"><x path="Float"/></specularPower>
		<blendMode public="1" set="accessor"><t path="h3d.mat.BlendMode"/></blendMode>
		<get_specularPower get="inline" set="null" line="48"><f a=""><x path="Float"/></f></get_specularPower>
		<set_specularPower get="inline" set="null" line="52"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_specularPower>
		<get_specularAmount get="inline" set="null" line="56"><f a=""><x path="Float"/></f></get_specularAmount>
		<set_specularAmount get="inline" set="null" line="60"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_specularAmount>
		<get_color get="inline" set="null" line="64"><f a=""><t path="hxsl.Vec"/></f></get_color>
		<set_color get="inline" set="null" line="68"><f a="v">
	<t path="hxsl.Vec"/>
	<t path="hxsl.Vec"/>
</f></set_color>
		<get_shadows get="inline" set="null" line="72"><f a=""><x path="Bool"/></f></get_shadows>
		<set_shadows get="inline" set="null" line="76"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_shadows>
		<set_castShadows set="method" line="82"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_castShadows>
		<set_receiveShadows set="method" line="94"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_receiveShadows>
		<set_staticShadows set="method" line="107"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_staticShadows>
		<clone public="1" set="method" line="113" override="1"><f a="?m">
	<c path="h3d.mat.BaseMaterial"/>
	<c path="h3d.mat.BaseMaterial"/>
</f></clone>
		<set_blendMode set="method" line="131"><f a="v">
	<t path="h3d.mat.BlendMode"/>
	<t path="h3d.mat.BlendMode"/>
</f></set_blendMode>
		<get_specularTexture set="method" line="149"><f a=""><x path="Null"><c path="h3d.mat.Texture"/></x></f></get_specularTexture>
		<get_texture set="method" line="153"><f a=""><x path="Null"><c path="h3d.mat.Texture"/></x></f></get_texture>
		<set_texture set="method" line="157"><f a="t">
	<t path="hxsl.Sampler2D"/>
	<t path="hxsl.Sampler2D"/>
</f></set_texture>
		<get_normalMap set="method" line="173"><f a=""><x path="Null"><c path="h3d.mat.Texture"/></x></f></get_normalMap>
		<set_normalMap set="method" line="177"><f a="t">
	<t path="hxsl.Sampler2D"/>
	<t path="hxsl.Sampler2D"/>
</f></set_normalMap>
		<set_specularTexture set="method" line="196"><f a="t">
	<t path="hxsl.Sampler2D"/>
	<t path="hxsl.Sampler2D"/>
</f></set_specularTexture>
		<getDefaultModelProps public="1" set="method" line="218"><f a=""><x path="Any"/></f></getDefaultModelProps>
		<getDefaultProps public="1" set="method" line="236" override="1"><f a="?type">
	<c path="String"/>
	<x path="Any"/>
</f></getDefaultProps>
		<refreshProps public="1" set="method" line="264" override="1"><f a=""><x path="Void"/></f></refreshProps>
		<new set="method" line="41"><f a="?texture">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.mat.MaterialDatabase" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/MaterialDatabase.hx">
		<db expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<a><v><d/></v></a>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</db>
		<getFilePath set="method" line="10"><f a="model">
	<c path="hxd.res.Resource"/>
	<c path="String"/>
</f></getFilePath>
		<getModelData public="1" set="method" line="14"><f a="model">
	<c path="hxd.res.Resource"/>
	<a/>
</f></getModelData>
		<saveData set="method" line="26"><f a="model:data">
	<c path="hxd.res.Resource"/>
	<d/>
	<x path="Void"/>
</f></saveData>
		<loadMatProps public="1" set="method" line="41"><f a="material:setup">
	<c path="h3d.mat.Material"/>
	<c path="h3d.mat.MaterialSetup"/>
	<x path="Any"/>
</f></loadMatProps>
		<saveMatProps public="1" set="method" line="51"><f a="material:setup">
	<c path="h3d.mat.Material"/>
	<c path="h3d.mat.MaterialSetup"/>
	<x path="Void"/>
</f></saveMatProps>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.mat.MaterialSetup" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/MaterialSetup.hx">
		<current public="1" expr="new MaterialSetup(&quot;Default&quot;)" line="47" static="1">
			<c path="h3d.mat.MaterialSetup"/>
			<meta><m n=":value"><e>new MaterialSetup("Default")</e></m></meta>
		</current>
		<name public="1" set="null"><c path="String"/></name>
		<database><c path="h3d.mat.MaterialDatabase"/></database>
		<emptyMat><c path="h3d.mat.Material"/></emptyMat>
		<createRenderer public="1" set="method" line="15"><f a=""><c path="h3d.scene.Renderer"/></f></createRenderer>
		<createLightSystem public="1" set="method" line="19"><f a=""><c path="h3d.scene.LightSystem"/></f></createLightSystem>
		<createMaterial public="1" set="method" line="23"><f a=""><c path="h3d.mat.Material"/></f></createMaterial>
		<getDefaults public="1" set="method" line="27"><f a="?kind">
	<c path="String"/>
	<x path="Any"/>
</f></getDefaults>
		<loadMaterialProps public="1" set="method" line="32"><f a="material">
	<c path="h3d.mat.Material"/>
	<x path="Any"/>
</f></loadMaterialProps>
		<saveMaterialProps public="1" set="method" line="36"><f a="material">
	<c path="h3d.mat.Material"/>
	<x path="Void"/>
</f></saveMaterialProps>
		<customMeshInit public="1" set="method" line="44"><f a="mesh">
	<c path="h3d.scene.Mesh"/>
	<x path="Void"/>
</f></customMeshInit>
		<new public="1" set="method" line="9"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.mat.Pass" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Pass.hx">
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<getCulling public="1" get="inline" set="null" line="31" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getCulling>
		<culling_bits public="1" get="inline" set="null" expr="2" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</culling_bits>
		<culling_offset public="1" get="inline" set="null" expr="0" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</culling_offset>
		<culling_mask public="1" get="inline" set="null" expr="3" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</culling_mask>
		<getDepthWrite public="1" get="inline" set="null" line="32" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getDepthWrite>
		<depthWrite_bits public="1" get="inline" set="null" expr="1" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</depthWrite_bits>
		<depthWrite_offset public="1" get="inline" set="null" expr="2" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</depthWrite_offset>
		<depthWrite_mask public="1" get="inline" set="null" expr="4" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</depthWrite_mask>
		<getDepthTest public="1" get="inline" set="null" line="33" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getDepthTest>
		<depthTest_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</depthTest_bits>
		<depthTest_offset public="1" get="inline" set="null" expr="3" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</depthTest_offset>
		<depthTest_mask public="1" get="inline" set="null" expr="56" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>56</e></m></meta>
		</depthTest_mask>
		<getBlendSrc public="1" get="inline" set="null" line="34" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBlendSrc>
		<blendSrc_bits public="1" get="inline" set="null" expr="4" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</blendSrc_bits>
		<blendSrc_offset public="1" get="inline" set="null" expr="6" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</blendSrc_offset>
		<blendSrc_mask public="1" get="inline" set="null" expr="960" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>960</e></m></meta>
		</blendSrc_mask>
		<getBlendDst public="1" get="inline" set="null" line="35" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBlendDst>
		<blendDst_bits public="1" get="inline" set="null" expr="4" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</blendDst_bits>
		<blendDst_offset public="1" get="inline" set="null" expr="10" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</blendDst_offset>
		<blendDst_mask public="1" get="inline" set="null" expr="15360" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15360</e></m></meta>
		</blendDst_mask>
		<getBlendAlphaSrc public="1" get="inline" set="null" line="36" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBlendAlphaSrc>
		<blendAlphaSrc_bits public="1" get="inline" set="null" expr="4" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</blendAlphaSrc_bits>
		<blendAlphaSrc_offset public="1" get="inline" set="null" expr="14" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14</e></m></meta>
		</blendAlphaSrc_offset>
		<blendAlphaSrc_mask public="1" get="inline" set="null" expr="245760" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>245760</e></m></meta>
		</blendAlphaSrc_mask>
		<getBlendAlphaDst public="1" get="inline" set="null" line="37" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBlendAlphaDst>
		<blendAlphaDst_bits public="1" get="inline" set="null" expr="4" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</blendAlphaDst_bits>
		<blendAlphaDst_offset public="1" get="inline" set="null" expr="18" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</blendAlphaDst_offset>
		<blendAlphaDst_mask public="1" get="inline" set="null" expr="3932160" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3932160</e></m></meta>
		</blendAlphaDst_mask>
		<getBlendOp public="1" get="inline" set="null" line="38" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBlendOp>
		<blendOp_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</blendOp_bits>
		<blendOp_offset public="1" get="inline" set="null" expr="22" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>22</e></m></meta>
		</blendOp_offset>
		<blendOp_mask public="1" get="inline" set="null" expr="29360128" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>29360128</e></m></meta>
		</blendOp_mask>
		<getBlendAlphaOp public="1" get="inline" set="null" line="39" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBlendAlphaOp>
		<blendAlphaOp_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</blendAlphaOp_bits>
		<blendAlphaOp_offset public="1" get="inline" set="null" expr="25" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>25</e></m></meta>
		</blendAlphaOp_offset>
		<blendAlphaOp_mask public="1" get="inline" set="null" expr="234881024" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>234881024</e></m></meta>
		</blendAlphaOp_mask>
		<getWireframe public="1" get="inline" set="null" line="40" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getWireframe>
		<wireframe_bits public="1" get="inline" set="null" expr="1" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</wireframe_bits>
		<wireframe_offset public="1" get="inline" set="null" expr="28" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>28</e></m></meta>
		</wireframe_offset>
		<wireframe_mask public="1" get="inline" set="null" expr="268435456" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>268435456</e></m></meta>
		</wireframe_mask>
		<getReserved public="1" get="inline" set="null" line="46" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getReserved>
		<reserved_bits public="1" get="inline" set="null" expr="1" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</reserved_bits>
		<reserved_offset public="1" get="inline" set="null" expr="29" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>29</e></m></meta>
		</reserved_offset>
		<reserved_mask public="1" get="inline" set="null" expr="536870912" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>536870912</e></m></meta>
		</reserved_mask>
		<name public="1" set="null">
			<c path="String"/>
			<meta><m n=":s"/></meta>
		</name>
		<passId><x path="Int"/></passId>
		<bits expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":s"/>
			</meta>
		</bits>
		<parentPass>
			<c path="h3d.mat.Pass"/>
			<meta><m n=":s"/></meta>
		</parentPass>
		<parentShaders><c path="hxsl.ShaderList"/></parentShaders>
		<shaders><c path="hxsl.ShaderList"/></shaders>
		<nextPass>
			<c path="h3d.mat.Pass"/>
			<meta><m n=":s"/></meta>
		</nextPass>
		<enableLights public="1">
			<x path="Bool"/>
			<meta><m n=":s"/></meta>
		</enableLights>
		<dynamicParameters public="1">
			<x path="Bool"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>Inform the pass system that the parameters will be modified in object draw() command,
		so they will be manually uploaded by calling RenderContext.uploadParams.</haxe_doc>
		</dynamicParameters>
		<isStatic public="1">
			<x path="Bool"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>Mark the pass as static, this will allow some renderers or shadows to filter it
		when rendering static/dynamic parts.</haxe_doc>
		</isStatic>
		<culling public="1" set="accessor">
			<e path="h3d.mat.Face"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</culling>
		<depthWrite public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</depthWrite>
		<depthTest public="1" set="accessor">
			<e path="h3d.mat.Compare"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</depthTest>
		<blendSrc public="1" set="accessor">
			<e path="h3d.mat.Blend"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</blendSrc>
		<blendDst public="1" set="accessor">
			<e path="h3d.mat.Blend"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</blendDst>
		<blendAlphaSrc public="1" set="accessor">
			<e path="h3d.mat.Blend"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</blendAlphaSrc>
		<blendAlphaDst public="1" set="accessor">
			<e path="h3d.mat.Blend"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</blendAlphaDst>
		<blendOp public="1" set="accessor">
			<e path="h3d.mat.Operation"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</blendOp>
		<blendAlphaOp public="1" set="accessor">
			<e path="h3d.mat.Operation"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</blendAlphaOp>
		<wireframe public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":bits"><e>bits</e></m></meta>
		</wireframe>
		<colorMask public="1"><x path="Int"/></colorMask>
		<stencil public="1">
			<c path="h3d.mat.Stencil"/>
			<meta><m n=":s"/></meta>
		</stencil>
		<reserved set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":bits"><e>bits</e></m>
				<m n=":noCompletion"/>
			</meta>
		</reserved>
		<load public="1" set="method" line="59"><f a="p">
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></load>
		<setPassName public="1" set="method" line="81"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></setPassName>
		<blend public="1" get="inline" set="null" line="86"><f a="src:dst">
	<e path="h3d.mat.Blend"/>
	<e path="h3d.mat.Blend"/>
	<x path="Void"/>
</f></blend>
		<setBlendMode public="1" set="method" line="93"><f a="b">
	<t path="h3d.mat.BlendMode"/>
	<x path="Void"/>
</f></setBlendMode>
		<depth public="1" set="method" line="155"><f a="write:test">
	<x path="Bool"/>
	<e path="h3d.mat.Compare"/>
	<x path="Void"/>
</f></depth>
		<setColorMask public="1" set="method" line="160"><f a="r:g:b:a">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setColorMask>
		<setColorChannel public="1" set="method" line="164"><f a="c">
	<e path="hxsl.Channel"/>
	<x path="Void"/>
</f></setColorChannel>
		<addShader public="1" params="T" set="method" line="174"><f a="s">
	<c path="addShader.T"/>
	<c path="addShader.T"/>
</f></addShader>
		<addShaderAtIndex params="T" set="method" line="184">
			<f a="s:index">
				<c path="addShaderAtIndex.T"/>
				<x path="Int"/>
				<c path="addShaderAtIndex.T"/>
			</f>
			<haxe_doc>Can be used for internal usage</haxe_doc>
		</addShaderAtIndex>
		<getShaderIndex set="method" line="199"><f a="s">
	<c path="hxsl.Shader"/>
	<x path="Int"/>
</f></getShaderIndex>
		<removeShader public="1" set="method" line="210"><f a="s">
	<c path="hxsl.Shader"/>
	<x path="Bool"/>
</f></removeShader>
		<getShader public="1" params="T" set="method" line="226"><f a="t">
	<x path="Class"><c path="getShader.T"/></x>
	<c path="getShader.T"/>
</f></getShader>
		<getShaderByName public="1" set="method" line="237"><f a="name">
	<c path="String"/>
	<c path="hxsl.Shader"/>
</f></getShaderByName>
		<getShaders public="1" get="inline" set="null" line="247"><f a=""><c path="hxsl._ShaderList.ShaderIterator"/></f></getShaders>
		<getShadersRec set="method" line="251"><f a=""><c path="hxsl.ShaderList"/></f></getShadersRec>
		<clone public="1" set="method" line="268"><f a=""><c path="h3d.mat.Pass"/></f></clone>
		<getDebugShaderCode public="1" set="method" line="277">
			<f a="scene:?toHxsl" v=":true">
				<c path="h3d.scene.Scene"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ toHxsl : true }</e></m></meta>
		</getDebugShaderCode>
		<set_culling set="method" line="31"><f a="v">
	<e path="h3d.mat.Face"/>
	<e path="h3d.mat.Face"/>
</f></set_culling>
		<set_depthWrite set="method" line="32"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_depthWrite>
		<set_depthTest set="method" line="33"><f a="v">
	<e path="h3d.mat.Compare"/>
	<e path="h3d.mat.Compare"/>
</f></set_depthTest>
		<set_blendSrc set="method" line="34"><f a="v">
	<e path="h3d.mat.Blend"/>
	<e path="h3d.mat.Blend"/>
</f></set_blendSrc>
		<set_blendDst set="method" line="35"><f a="v">
	<e path="h3d.mat.Blend"/>
	<e path="h3d.mat.Blend"/>
</f></set_blendDst>
		<set_blendAlphaSrc set="method" line="36"><f a="v">
	<e path="h3d.mat.Blend"/>
	<e path="h3d.mat.Blend"/>
</f></set_blendAlphaSrc>
		<set_blendAlphaDst set="method" line="37"><f a="v">
	<e path="h3d.mat.Blend"/>
	<e path="h3d.mat.Blend"/>
</f></set_blendAlphaDst>
		<set_blendOp set="method" line="38"><f a="v">
	<e path="h3d.mat.Operation"/>
	<e path="h3d.mat.Operation"/>
</f></set_blendOp>
		<set_blendAlphaOp set="method" line="39"><f a="v">
	<e path="h3d.mat.Operation"/>
	<e path="h3d.mat.Operation"/>
</f></set_blendAlphaOp>
		<set_wireframe set="method" line="40"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_wireframe>
		<set_reserved set="method" line="46"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_reserved>
		<loadBits set="method" line="6"><f a="bits">
	<x path="Int"/>
	<x path="Void"/>
</f></loadBits>
		<new public="1" set="method" line="48"><f a="name:?shaders:?parent">
	<c path="String"/>
	<c path="hxsl.ShaderList"/>
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.mat.BaseMaterial</e></m>
			<m n=":build"><e>hxd.impl.BitsBuilder.build()</e></m>
		</meta>
	</class>
	<class path="h3d.mat.Stencil" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Stencil.hx">
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<getReadMask public="1" get="inline" set="null" line="13" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getReadMask>
		<readMask_bits public="1" get="inline" set="null" expr="8" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</readMask_bits>
		<readMask_offset public="1" get="inline" set="null" expr="0" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</readMask_offset>
		<readMask_mask public="1" get="inline" set="null" expr="255" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>255</e></m></meta>
		</readMask_mask>
		<getWriteMask public="1" get="inline" set="null" line="14" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getWriteMask>
		<writeMask_bits public="1" get="inline" set="null" expr="8" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</writeMask_bits>
		<writeMask_offset public="1" get="inline" set="null" expr="8" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</writeMask_offset>
		<writeMask_mask public="1" get="inline" set="null" expr="65280" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>65280</e></m></meta>
		</writeMask_mask>
		<getReference public="1" get="inline" set="null" line="15" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getReference>
		<reference_bits public="1" get="inline" set="null" expr="8" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</reference_bits>
		<reference_offset public="1" get="inline" set="null" expr="16" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</reference_offset>
		<reference_mask public="1" get="inline" set="null" expr="16711680" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16711680</e></m></meta>
		</reference_mask>
		<getFrontTest public="1" get="inline" set="null" line="17" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getFrontTest>
		<frontTest_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</frontTest_bits>
		<frontTest_offset public="1" get="inline" set="null" expr="0" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</frontTest_offset>
		<frontTest_mask public="1" get="inline" set="null" expr="7" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</frontTest_mask>
		<getFrontPass public="1" get="inline" set="null" line="18" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getFrontPass>
		<frontPass_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</frontPass_bits>
		<frontPass_offset public="1" get="inline" set="null" expr="3" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</frontPass_offset>
		<frontPass_mask public="1" get="inline" set="null" expr="56" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>56</e></m></meta>
		</frontPass_mask>
		<getFrontSTfail public="1" get="inline" set="null" line="19" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getFrontSTfail>
		<frontSTfail_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</frontSTfail_bits>
		<frontSTfail_offset public="1" get="inline" set="null" expr="6" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</frontSTfail_offset>
		<frontSTfail_mask public="1" get="inline" set="null" expr="448" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>448</e></m></meta>
		</frontSTfail_mask>
		<getFrontDPfail public="1" get="inline" set="null" line="20" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getFrontDPfail>
		<frontDPfail_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</frontDPfail_bits>
		<frontDPfail_offset public="1" get="inline" set="null" expr="9" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</frontDPfail_offset>
		<frontDPfail_mask public="1" get="inline" set="null" expr="3584" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3584</e></m></meta>
		</frontDPfail_mask>
		<getBackTest public="1" get="inline" set="null" line="22" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBackTest>
		<backTest_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</backTest_bits>
		<backTest_offset public="1" get="inline" set="null" expr="12" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</backTest_offset>
		<backTest_mask public="1" get="inline" set="null" expr="28672" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>28672</e></m></meta>
		</backTest_mask>
		<getBackPass public="1" get="inline" set="null" line="23" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBackPass>
		<backPass_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</backPass_bits>
		<backPass_offset public="1" get="inline" set="null" expr="15" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</backPass_offset>
		<backPass_mask public="1" get="inline" set="null" expr="229376" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>229376</e></m></meta>
		</backPass_mask>
		<getBackSTfail public="1" get="inline" set="null" line="24" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBackSTfail>
		<backSTfail_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</backSTfail_bits>
		<backSTfail_offset public="1" get="inline" set="null" expr="18" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</backSTfail_offset>
		<backSTfail_mask public="1" get="inline" set="null" expr="1835008" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1835008</e></m></meta>
		</backSTfail_mask>
		<getBackDPfail public="1" get="inline" set="null" line="25" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></getBackDPfail>
		<backDPfail_bits public="1" get="inline" set="null" expr="3" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</backDPfail_bits>
		<backDPfail_offset public="1" get="inline" set="null" expr="21" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>21</e></m></meta>
		</backDPfail_offset>
		<backDPfail_mask public="1" get="inline" set="null" expr="14680064" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14680064</e></m></meta>
		</backDPfail_mask>
		<maskBits expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":s"/>
			</meta>
		</maskBits>
		<opBits expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":s"/>
			</meta>
		</opBits>
		<readMask public="1" set="accessor">
			<x path="Int"/>
			<meta><m n=":bits">
	<e>maskBits</e>
	<e>8</e>
</m></meta>
		</readMask>
		<writeMask public="1" set="accessor">
			<x path="Int"/>
			<meta><m n=":bits">
	<e>maskBits</e>
	<e>8</e>
</m></meta>
		</writeMask>
		<reference public="1" set="accessor">
			<x path="Int"/>
			<meta><m n=":bits">
	<e>maskBits</e>
	<e>8</e>
</m></meta>
		</reference>
		<frontTest public="1" set="accessor">
			<e path="h3d.mat.Compare"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</frontTest>
		<frontPass public="1" set="accessor">
			<e path="h3d.mat.StencilOp"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</frontPass>
		<frontSTfail public="1" set="accessor">
			<e path="h3d.mat.StencilOp"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</frontSTfail>
		<frontDPfail public="1" set="accessor">
			<e path="h3d.mat.StencilOp"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</frontDPfail>
		<backTest public="1" set="accessor">
			<e path="h3d.mat.Compare"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</backTest>
		<backPass public="1" set="accessor">
			<e path="h3d.mat.StencilOp"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</backPass>
		<backSTfail public="1" set="accessor">
			<e path="h3d.mat.StencilOp"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</backSTfail>
		<backDPfail public="1" set="accessor">
			<e path="h3d.mat.StencilOp"/>
			<meta><m n=":bits"><e>opBits</e></m></meta>
		</backDPfail>
		<setFront public="1" set="method" line="32"><f a="stfail:dpfail:pass">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
	<x path="Void"/>
</f></setFront>
		<setBack public="1" set="method" line="38"><f a="stfail:dpfail:pass">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
	<x path="Void"/>
</f></setBack>
		<setOp public="1" set="method" line="44"><f a="stfail:dpfail:pass">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
	<x path="Void"/>
</f></setOp>
		<setFunc public="1" set="method" line="49">
			<f a="f:?reference:?readMask:?writeMask" v=":0:0xFF:0xFF">
				<e path="h3d.mat.Compare"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ writeMask : 0xFF, readMask : 0xFF, reference : 0 }</e></m></meta>
		</setFunc>
		<clone public="1" set="method" line="56"><f a=""><c path="h3d.mat.Stencil"/></f></clone>
		<load public="1" set="method" line="63"><f a="s">
	<c path="h3d.mat.Stencil"/>
	<x path="Void"/>
</f></load>
		<set_readMask set="method" line="13"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_readMask>
		<set_writeMask set="method" line="14"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_writeMask>
		<set_reference set="method" line="15"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></set_reference>
		<set_frontTest set="method" line="17"><f a="v">
	<e path="h3d.mat.Compare"/>
	<e path="h3d.mat.Compare"/>
</f></set_frontTest>
		<set_frontPass set="method" line="18"><f a="v">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
</f></set_frontPass>
		<set_frontSTfail set="method" line="19"><f a="v">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
</f></set_frontSTfail>
		<set_frontDPfail set="method" line="20"><f a="v">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
</f></set_frontDPfail>
		<set_backTest set="method" line="22"><f a="v">
	<e path="h3d.mat.Compare"/>
	<e path="h3d.mat.Compare"/>
</f></set_backTest>
		<set_backPass set="method" line="23"><f a="v">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
</f></set_backPass>
		<set_backSTfail set="method" line="24"><f a="v">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
</f></set_backSTfail>
		<set_backDPfail set="method" line="25"><f a="v">
	<e path="h3d.mat.StencilOp"/>
	<e path="h3d.mat.StencilOp"/>
</f></set_backDPfail>
		<loadOpBits set="method" line="6"><f a="bits">
	<x path="Int"/>
	<x path="Void"/>
</f></loadOpBits>
		<loadMaskBits set="method" line="6"><f a="bits">
	<x path="Int"/>
	<x path="Void"/>
</f></loadMaskBits>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d.mat.Material</e></m>
			<m n=":build"><e>hxd.impl.BitsBuilder.build()</e></m>
		</meta>
	</class>
	<enum path="hxd.PixelFormat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/PixelFormat.hx">
		<ARGB/>
		<BGRA/>
		<RGBA/>
		<RGBA16F/>
		<RGBA32F/>
		<R8/>
		<R16F/>
		<R32F/>
		<RG8/>
		<RG16F/>
		<RG32F/>
		<RGB8/>
		<RGB16F/>
		<RGB32F/>
		<SRGB/>
		<SRGB_ALPHA/>
		<RGB10A2/>
		<RG11B10UF/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h3d.mat.Texture" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/Texture.hx">
		<UID expr="0" line="7" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UID>
		<nativeFormat public="1" set="null" expr="RGBA" line="18" static="1">
			<t path="h3d.mat.TextureFormat"/>
			<meta><m n=":value"><e>RGBA</e></m></meta>
			<haxe_doc>The default texture color format</haxe_doc>
		</nativeFormat>
		<fromBitmap public="1" set="method" line="368" static="1"><f a="bmp:?allocPos">
	<c path="hxd.BitmapData"/>
	<t path="h3d.impl.AllocPos"/>
	<c path="h3d.mat.Texture"/>
</f></fromBitmap>
		<fromPixels public="1" set="method" line="374" static="1"><f a="pixels:?allocPos">
	<c path="hxd.Pixels"/>
	<t path="h3d.impl.AllocPos"/>
	<c path="h3d.mat.Texture"/>
</f></fromPixels>
		<fromColor public="1" set="method" line="383" static="1">
			<f a="color:?alpha:?allocPos" v=":1.:">
				<x path="Int"/>
				<x path="Float"/>
				<t path="h3d.impl.AllocPos"/>
				<x path="Null"><c path="h3d.mat.Texture"/></x>
			</f>
			<meta><m n=":value"><e>{ alpha : 1. }</e></m></meta>
			<haxe_doc>Creates a 1x1 texture using the RGB color passed as parameter.</haxe_doc>
		</fromColor>
		<defaultCubeTexture public="1" set="method" line="401" static="1">
			<f a=""><c path="h3d.mat.Texture"/></f>
			<haxe_doc>Returns a default dummy 1x1 black cube texture</haxe_doc>
		</defaultCubeTexture>
		<genChecker public="1" set="method" line="416" static="1">
			<f a="size">
				<x path="Int"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<haxe_doc>Returns a checker texture of size x size, than can be repeated</haxe_doc>
		</genChecker>
		<checkerTextureKeys expr="new Map&lt;Int,{ }&gt;()" line="432" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<a/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,{ }>()]]></e></m></meta>
		</checkerTextureKeys>
		<noiseTextureKeys expr="new Map&lt;Int,{ }&gt;()" line="433" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<a/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,{ }>()]]></e></m></meta>
		</noiseTextureKeys>
		<genNoise public="1" set="method" line="435" static="1"><f a="size">
	<x path="Int"/>
	<c path="h3d.mat.Texture"/>
</f></genNoise>
		<allocNoise set="method" line="451" static="1"><f a="t:size">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></allocNoise>
		<allocChecker set="method" line="462" static="1"><f a="t:size">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></allocChecker>
		<t><t path="h3d.impl.Texture"/></t>
		<mem><c path="h3d.impl.MemoryManager"/></mem>
		<id public="1" set="null"><x path="Int"/></id>
		<name public="1" set="null"><c path="String"/></name>
		<width public="1" set="null"><x path="Int"/></width>
		<height public="1" set="null"><x path="Int"/></height>
		<flags public="1" set="null"><x path="haxe.EnumFlags"><e path="h3d.mat.TextureFlags"/></x></flags>
		<format public="1" set="null"><t path="h3d.mat.TextureFormat"/></format>
		<lastFrame><x path="Int"/></lastFrame>
		<bits><x path="Int"/></bits>
		<waitLoads><c path="Array"><f a=""><x path="Void"/></f></c></waitLoads>
		<mipMap public="1" set="accessor"><e path="h3d.mat.MipMap"/></mipMap>
		<filter public="1" set="accessor"><e path="h3d.mat.Filter"/></filter>
		<wrap public="1" set="accessor"><e path="h3d.mat.Wrap"/></wrap>
		<layerCount public="1" get="accessor" set="null"><x path="Int"/></layerCount>
		<realloc public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>If this callback is set, the texture can be re-allocated when the 3D context has been lost or when
		it's been free because of lack of memory.</haxe_doc>
		</realloc>
		<depthBuffer public="1">
			<c path="h3d.mat.DepthBuffer"/>
			<haxe_doc>When the texture is used as render target, tells which depth buffer will be used.
		If set to null, depth testing is disabled.</haxe_doc>
		</depthBuffer>
		<get_layerCount set="method" line="88"><f a=""><x path="Int"/></f></get_layerCount>
		<alloc public="1" set="method" line="92"><f a=""><x path="Void"/></f></alloc>
		<isSRGB public="1" set="method" line="97"><f a=""><x path="Bool"/></f></isSRGB>
		<checkAlloc set="method" line="101"><f a=""><x path="Void"/></f></checkAlloc>
		<clone public="1" set="method" line="108"><f a="?allocPos">
	<t path="h3d.impl.AllocPos"/>
	<c path="h3d.mat.Texture"/>
</f></clone>
		<preventAutoDispose public="1" set="method" line="133">
			<f a=""><x path="Void"/></f>
			<haxe_doc>In case of out of GPU memory, textures that hasn't been used for a long time will be disposed.
		Calling this will make this texture not considered for auto disposal.</haxe_doc>
		</preventAutoDispose>
		<waitLoad public="1" set="method" line="142">
			<f a="f">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>Some textures might take some time to load. You can check flags.has(Loading)
		or add a waitLoad callback which will get called either immediately if the texture is already loaded
		or when loading is complete.</haxe_doc>
		</waitLoad>
		<toString set="method" line="151"><f a=""><c path="String"/></f></toString>
		<setName public="1" set="method" line="162"><f a="n">
	<c path="String"/>
	<x path="Void"/>
</f></setName>
		<set_mipMap set="method" line="166"><f a="m">
	<e path="h3d.mat.MipMap"/>
	<e path="h3d.mat.MipMap"/>
</f></set_mipMap>
		<set_filter set="method" line="171"><f a="f">
	<e path="h3d.mat.Filter"/>
	<e path="h3d.mat.Filter"/>
</f></set_filter>
		<set_wrap set="method" line="176"><f a="w">
	<e path="h3d.mat.Wrap"/>
	<e path="h3d.mat.Wrap"/>
</f></set_wrap>
		<isDisposed public="1" get="inline" set="null" line="181"><f a=""><x path="Bool"/></f></isDisposed>
		<resize public="1" set="method" line="185"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<clear public="1" set="method" line="203">
			<f a="color:?alpha:?layer" v=":1.:-1">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ layer : -1, alpha : 1. }</e></m></meta>
		</clear>
		<checkSize get="inline" set="null" line="249"><f a="width:height:mip">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></checkSize>
		<checkMipMapGen set="method" line="254"><f a="mipLevel:layer">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></checkMipMapGen>
		<uploadBitmap public="1" set="method" line="259">
			<f a="bmp:?mipLevel:?layer" v=":0:0">
				<c path="hxd.BitmapData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ layer : 0, mipLevel : 0 }</e></m></meta>
		</uploadBitmap>
		<uploadPixels public="1" set="method" line="267">
			<f a="pixels:?mipLevel:?layer" v=":0:0">
				<c path="hxd.Pixels"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ layer : 0, mipLevel : 0 }</e></m></meta>
		</uploadPixels>
		<dispose public="1" set="method" line="275"><f a=""><x path="Void"/></f></dispose>
		<swapTexture public="1" set="method" line="289">
			<f a="t">
				<c path="h3d.mat.Texture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Swap two textures, this is an immediate operation.
		BEWARE : if the texture is a cached image (hxd.res.Image), the swap will affect the cache!</haxe_doc>
		</swapTexture>
		<capturePixels public="1" set="method" line="303">
			<f a="?face:?mipLevel:?region" v="0:0:">
				<x path="Int"/>
				<x path="Int"/>
				<c path="h2d.col.IBounds"/>
				<c path="hxd.Pixels"/>
			</f>
			<meta><m n=":value"><e>{ mipLevel : 0, face : 0 }</e></m></meta>
			<haxe_doc>Downloads the current texture data from the GPU.
		Beware, this is a very slow operation that shouldn't be done during rendering.</haxe_doc>
		</capturePixels>
		<new public="1" set="method" line="53"><f a="w:h:?flags:?format:?allocPos">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><e path="h3d.mat.TextureFlags"/></c>
	<t path="h3d.mat.TextureFormat"/>
	<t path="h3d.impl.AllocPos"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>h3d</e></m>
		</meta>
	</class>
	<class path="h3d.mat.TextureArray" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/mat/TextureArray.hx">
		<extends path="h3d.mat.Texture"/>
		<layers><x path="Int"/></layers>
		<get_layerCount set="method" line="15" override="1"><f a=""><x path="Int"/></f></get_layerCount>
		<clone public="1" set="method" line="19" override="1"><f a="?allocPos">
	<t path="h3d.impl.AllocPos"/>
	<c path="h3d.mat.TextureArray"/>
</f></clone>
		<toString set="method" line="28" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="8"><f a="w:h:layers:?flags:?format:?allocPos">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><e path="h3d.mat.TextureFlags"/></c>
	<t path="h3d.mat.TextureFormat"/>
	<t path="h3d.impl.AllocPos"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.pass.Base" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Base.hx">
		<ctx><c path="h3d.scene.RenderContext"/></ctx>
		<name public="1" set="null"><c path="String"/></name>
		<compileShader public="1" set="method" line="12"><f a="p">
	<c path="h3d.mat.Pass"/>
	<c path="hxsl.RuntimeShader"/>
</f></compileShader>
		<setContext public="1" set="method" line="17"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></setContext>
		<dispose public="1" set="method" line="21"><f a=""><x path="Void"/></f></dispose>
		<draw public="1" set="method" line="24"><f a="passes">
	<c path="h3d.pass.Object"/>
	<c path="h3d.pass.Object"/>
</f></draw>
		<new public="1" set="method" line="8"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.pass.ScreenFx" params="T" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/ScreenFx.hx">
		<shader public="1"><c path="h3d.pass.ScreenFx.T"/></shader>
		<pass public="1"><c path="h3d.mat.Pass"/></pass>
		<primitive public="1"><c path="h3d.prim.Primitive"/></primitive>
		<manager><c path="h3d.pass.ShaderManager"/></manager>
		<_engine><c path="h3d.Engine"/></_engine>
		<engine get="accessor" set="null"><c path="h3d.Engine"/></engine>
		<shaders><c path="hxsl.ShaderList"/></shaders>
		<buffers><c path="h3d.shader.Buffers"/></buffers>
		<get_engine set="method" line="23"><f a=""><c path="h3d.Engine"/></f></get_engine>
		<copy set="method" line="28"><f a="src:dst">
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></copy>
		<setGlobals public="1" set="method" line="32"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></setGlobals>
		<addShader public="1" params="T" set="method" line="37"><f a="s">
	<c path="addShader.T"/>
	<c path="addShader.T"/>
</f></addShader>
		<removeShader public="1" set="method" line="42"><f a="s">
	<c path="hxsl.Shader"/>
	<x path="Bool"/>
</f></removeShader>
		<getShader public="1" params="T" set="method" line="56"><f a="cl">
	<x path="Class"><c path="getShader.T"/></x>
	<c path="getShader.T"/>
</f></getShader>
		<render public="1" set="method" line="64"><f a=""><x path="Void"/></f></render>
		<dispose public="1" set="method" line="83"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="14"><f a="shader:?output">
	<c path="h3d.pass.ScreenFx.T"/>
	<c path="Array"><e path="hxsl.Output"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass.Blur" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Blur.hx">
		<extends path="h3d.pass.ScreenFx"><c path="h3d.shader.Blur"/></extends>
		<cubeDir expr="[h3d.Matrix.L([0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 0]), h3d.Matrix.L([0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0]), h3d.Matrix.L([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0])]">
			<c path="Array"><c path="h3d.Matrix"/></c>
			<meta><m n=":value"><e>[h3d.Matrix.L([0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 0]), h3d.Matrix.L([0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0]), h3d.Matrix.L([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0])]</e></m></meta>
		</cubeDir>
		<radius public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>How far in pixels the blur will go.</haxe_doc>
		</radius>
		<gain public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>How much the blur increases or decreases the color amount (default = 1)</haxe_doc>
		</gain>
		<linear public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>Set linear blur instead of gaussian (default = 0).</haxe_doc>
		</linear>
		<quality public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>Adjust how much quality/speed tradeoff we want (default = 1)</haxe_doc>
		</quality>
		<values><c path="Array"><x path="Float"/></c></values>
		<offsets><c path="Array"><x path="Float"/></c></offsets>
		<set_radius set="method" line="44"><f a="r">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radius>
		<set_quality set="method" line="51"><f a="q">
	<x path="Float"/>
	<x path="Float"/>
</f></set_quality>
		<set_gain set="method" line="58"><f a="s">
	<x path="Float"/>
	<x path="Float"/>
</f></set_gain>
		<set_linear set="method" line="65"><f a="b">
	<x path="Float"/>
	<x path="Float"/>
</f></set_linear>
		<gauss set="method" line="72"><f a="x:s">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></gauss>
		<calcValues set="method" line="79"><f a=""><x path="Void"/></f></calcValues>
		<getKernelSize public="1" set="method" line="121"><f a=""><x path="Int"/></f></getKernelSize>
		<apply public="1" set="method" line="126"><f a="ctx:src:?output">
	<c path="h3d.impl.RenderContext"/>
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></apply>
		<new public="1" set="method" line="36">
			<f a="?radius:?gain:?linear:?quality" v="1.:1.:0.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ quality : 1., linear : 0., gain : 1., radius : 1. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n="ignore"><e>"shader"</e></m>
		</meta>
	</class>
	<class path="hxsl.Shader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Shader.hx">
		<priority public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</priority>
		<shader><c path="hxsl.SharedShader"/></shader>
		<instance><c path="hxsl.ShaderInstance"/></instance>
		<constBits><x path="Int"/></constBits>
		<constModified><x path="Bool"/></constModified>
		<initialize set="method" line="17"><f a=""><x path="Void"/></f></initialize>
		<setPriority public="1" set="method" line="40">
			<f a="v">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Shader priority should only be changed *before* the shader is added to a material.</haxe_doc>
		</setPriority>
		<getParamValue public="1" set="method" line="44"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="49"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<updateConstants public="1" set="method" line="54"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<updateConstantsFinal set="method" line="58"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstantsFinal>
		<clone public="1" set="method" line="100"><f a=""><c path="hxsl.Shader"/></f></clone>
		<toString public="1" set="method" line="104"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.ScreenShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/ScreenShader.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey23:h3d.shader.ScreenShadery4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-233R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini330y3:maxi396y4:filey77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FScreenShader.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i336R16i361R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i336R16i348R17R18gR19r17R20jR21:1:1oR0y5:colorR9i-230y6:parentoR0y6:outputR9i-228R5jR10:4:0R11jR4:13:1aoR0y8:positionR9i-229R25r22R5r23R11jR4:5:2i4r16gr21hgR5r23R11r17ggoR14oR15i351R16i361R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y10:pixelColorR9i-231R5r23R11r31gggoR14oR15i367R16i390R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i367R16i379R17R18gR19r37R20jR21:1:1oR0y12:calculatedUVR9i-232R5r23R11r37ggoR14oR15i382R16i390R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y2:uvR9i-226R25oR0y5:inputR9i-224R5jR10:1:0R11jR4:13:1aoR0R27R9i-225R25r46R5r47R11jR4:5:2i2r16gr45hgR5r47R11r44ggghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-234R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i420R16i504R17R18gR19r3R20jR21:4:1aoR14oR15i426R16i498R17R18gR19r26R20jR21:5:3r18oR14oR15i426R16i441R17R18gR19r26R20jR21:1:1r25goR14oR15i444R16i498R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i444R16i448R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i449R16i465R17R18gR19jR4:3:0R20jR21:9:2oR14oR15i449R16i463R17R18gR19r50R20jR21:1:1r49gajy14:hxsl.Component:0:0hgoR14oR15i467R16i491R17R18gR19r83R20jR21:5:3jR23:1:0oR14oR15i467R16i483R17R18gR19r83R20jR21:9:2oR14oR15i467R16i481R17R18gR19r50R20jR21:1:1r49gajR34:1:0hgoR14oR15i486R16i491R17R18gR19r83R20jR21:1:1oR0y5:flipYR9i-227R5jR10:2:0R11r83gggoR14oR15i493R16i494R17R18gR19r83R20jR21:0:1jy10:hxsl.Const:3:1zgoR14oR15i496R16i497R17R18gR19r83R20jR21:0:1jR36:3:1i1ghgghgR12ahghy4:varsar46r103r22r32r40r5r58hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey23:h3d.shader.ScreenShadery4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-233R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini330y3:maxi396y4:filey77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FScreenShader.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i336R16i361R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i336R16i348R17R18gR19r17R20jR21:1:1oR0y5:colorR9i-230y6:parentoR0y6:outputR9i-228R5jR10:4:0R11jR4:13:1aoR0y8:positionR9i-229R25r22R5r23R11jR4:5:2i4r16gr21hgR5r23R11r17ggoR14oR15i351R16i361R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y10:pixelColorR9i-231R5r23R11r31gggoR14oR15i367R16i390R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i367R16i379R17R18gR19r37R20jR21:1:1oR0y12:calculatedUVR9i-232R5r23R11r37ggoR14oR15i382R16i390R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y2:uvR9i-226R25oR0y5:inputR9i-224R5jR10:1:0R11jR4:13:1aoR0R27R9i-225R25r46R5r47R11jR4:5:2i2r16gr45hgR5r47R11r44ggghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-234R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i420R16i504R17R18gR19r3R20jR21:4:1aoR14oR15i426R16i498R17R18gR19r26R20jR21:5:3r18oR14oR15i426R16i441R17R18gR19r26R20jR21:1:1r25goR14oR15i444R16i498R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i444R16i448R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i449R16i465R17R18gR19jR4:3:0R20jR21:9:2oR14oR15i449R16i463R17R18gR19r50R20jR21:1:1r49gajy14:hxsl.Component:0:0hgoR14oR15i467R16i491R17R18gR19r83R20jR21:5:3jR23:1:0oR14oR15i467R16i483R17R18gR19r83R20jR21:9:2oR14oR15i467R16i481R17R18gR19r50R20jR21:1:1r49gajR34:1:0hgoR14oR15i486R16i491R17R18gR19r83R20jR21:1:1oR0y5:flipYR9i-227R5jR10:2:0R11r83gggoR14oR15i493R16i494R17R18gR19r83R20jR21:0:1jy10:hxsl.Const:3:1zgoR14oR15i496R16i497R17R18gR19r83R20jR21:0:1jR36:3:1i1ghgghgR12ahghy4:varsar46r103r22r32r40r5r58hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<flipY public="1" get="accessor" set="accessor"><x path="Float"/></flipY>
		<flipY__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</flipY__>
		<get_flipY get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_flipY>
		<set_flipY get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_flipY>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":src"><e>{
	@input var input:{ var position : Vec2; var uv : Vec2};
	@param var flipY:Float;
	var output:{ var position : Vec4; var color : Vec4};
	var pixelColor:Vec4;
	var calculatedUV:Vec2;
	function __init__() {
		output.color = pixelColor;
		calculatedUV = input.uv;
	};
	function vertex() {
		output.position = vec4(input.position.x, input.position.y * flipY, 0, 1);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.pass._Border.BorderShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Border.hx" private="1" module="h3d.pass.Border">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;oy4:namey29:h3d.pass._Border.BorderShadery4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-245R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini330y3:maxi396y4:filey77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FScreenShader.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i336R16i361R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i336R16i348R17R18gR19r17R20jR21:1:1oR0y5:colorR9i-241y6:parentoR0y6:outputR9i-239R5jR10:4:0R11jR4:13:1aoR0y8:positionR9i-240R25r22R5r23R11jR4:5:2i4r16gr21hgR5r23R11r17ggoR14oR15i351R16i361R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y10:pixelColorR9i-242R5r23R11r31gggoR14oR15i367R16i390R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i367R16i379R17R18gR19r37R20jR21:1:1oR0y12:calculatedUVR9i-243R5r23R11r37ggoR14oR15i382R16i390R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y2:uvR9i-237R25oR0y5:inputR9i-235R5jR10:1:0R11jR4:13:1aoR0R27R9i-236R25r46R5r47R11jR4:5:2i2r16gr45hgR5r47R11r44ggghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-246R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i420R16i504R17R18gR19r3R20jR21:4:1aoR14oR15i426R16i498R17R18gR19r26R20jR21:5:3r18oR14oR15i426R16i441R17R18gR19r26R20jR21:1:1r25goR14oR15i444R16i498R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i444R16i448R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i449R16i465R17R18gR19jR4:3:0R20jR21:9:2oR14oR15i449R16i463R17R18gR19r50R20jR21:1:1r49gajy14:hxsl.Component:0:0hgoR14oR15i467R16i491R17R18gR19r83R20jR21:5:3jR23:1:0oR14oR15i467R16i483R17R18gR19r83R20jR21:9:2oR14oR15i467R16i481R17R18gR19r50R20jR21:1:1r49gajR34:1:0hgoR14oR15i486R16i491R17R18gR19r83R20jR21:1:1oR0y5:flipYR9i-238R5jR10:2:0R11r83gggoR14oR15i493R16i494R17R18gR19r83R20jR21:0:1jy10:hxsl.Const:3:1zgoR14oR15i496R16i497R17R18gR19r83R20jR21:0:1jR36:3:1i1ghgghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-247R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i158R16i188R17y69:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fpass%2FBorder.hxgR19r3R20jR21:4:1aoR14oR15i164R16i182R17R38gR19r31R20jR21:5:3r18oR14oR15i164R16i174R17R38gR19r31R20jR21:1:1r32goR14oR15i177R16i182R17R38gR19jR4:5:2i4r16R20jR21:1:1oR0R24R9i-244R5r104R11r136ggghgR12ahghy4:varsar46r103r22r32r40r137r5r58r121hg&quot;" line="4" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey29:h3d.pass._Border.BorderShadery4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-245R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini330y3:maxi396y4:filey77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FScreenShader.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i336R16i361R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i336R16i348R17R18gR19r17R20jR21:1:1oR0y5:colorR9i-241y6:parentoR0y6:outputR9i-239R5jR10:4:0R11jR4:13:1aoR0y8:positionR9i-240R25r22R5r23R11jR4:5:2i4r16gr21hgR5r23R11r17ggoR14oR15i351R16i361R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y10:pixelColorR9i-242R5r23R11r31gggoR14oR15i367R16i390R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i367R16i379R17R18gR19r37R20jR21:1:1oR0y12:calculatedUVR9i-243R5r23R11r37ggoR14oR15i382R16i390R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y2:uvR9i-237R25oR0y5:inputR9i-235R5jR10:1:0R11jR4:13:1aoR0R27R9i-236R25r46R5r47R11jR4:5:2i2r16gr45hgR5r47R11r44ggghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-246R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i420R16i504R17R18gR19r3R20jR21:4:1aoR14oR15i426R16i498R17R18gR19r26R20jR21:5:3r18oR14oR15i426R16i441R17R18gR19r26R20jR21:1:1r25goR14oR15i444R16i498R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i444R16i448R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i449R16i465R17R18gR19jR4:3:0R20jR21:9:2oR14oR15i449R16i463R17R18gR19r50R20jR21:1:1r49gajy14:hxsl.Component:0:0hgoR14oR15i467R16i491R17R18gR19r83R20jR21:5:3jR23:1:0oR14oR15i467R16i483R17R18gR19r83R20jR21:9:2oR14oR15i467R16i481R17R18gR19r50R20jR21:1:1r49gajR34:1:0hgoR14oR15i486R16i491R17R18gR19r83R20jR21:1:1oR0y5:flipYR9i-238R5jR10:2:0R11r83gggoR14oR15i493R16i494R17R18gR19r83R20jR21:0:1jy10:hxsl.Const:3:1zgoR14oR15i496R16i497R17R18gR19r83R20jR21:0:1jR36:3:1i1ghgghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-247R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i158R16i188R17y69:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fpass%2FBorder.hxgR19r3R20jR21:4:1aoR14oR15i164R16i182R17R38gR19r31R20jR21:5:3r18oR14oR15i164R16i174R17R38gR19r31R20jR21:1:1r32goR14oR15i177R16i182R17R38gR19jR4:5:2i4r16R20jR21:1:1oR0R24R9i-244R5r104R11r136ggghgR12ahghy4:varsar46r103r22r32r40r137r5r58r121hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<color public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></color>
		<color__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</color__>
		<get_color get="inline" set="null" line="4">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_color>
		<set_color get="inline" set="null" line="4">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_color>
		<updateConstants public="1" set="method" line="4" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="4" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="4" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="4" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var color:Vec4;
	function fragment() {
		pixelColor = color;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.pass.Border" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Border.hx">
		<extends path="h3d.pass.ScreenFx"><c path="h3d.pass._Border.BorderShader"/></extends>
		<dispose public="1" set="method" line="49" override="1"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="17">
			<f a="width:height:?size" v="::1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ size : 1 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass._Copy.CopyShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Copy.hx" private="1" module="h3d.pass.Copy">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;oy4:namey25:h3d.pass._Copy.CopyShadery4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-318R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini330y3:maxi396y4:filey77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FScreenShader.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i336R16i361R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i336R16i348R17R18gR19r17R20jR21:1:1oR0y5:colorR9i-314y6:parentoR0y6:outputR9i-312R5jR10:4:0R11jR4:13:1aoR0y8:positionR9i-313R25r22R5r23R11jR4:5:2i4r16gr21hgR5r23R11r17ggoR14oR15i351R16i361R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y10:pixelColorR9i-315R5r23R11r31gggoR14oR15i367R16i390R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i367R16i379R17R18gR19r37R20jR21:1:1oR0y12:calculatedUVR9i-316R5r23R11r37ggoR14oR15i382R16i390R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y2:uvR9i-310R25oR0y5:inputR9i-308R5jR10:1:0R11jR4:13:1aoR0R27R9i-309R25r46R5r47R11jR4:5:2i2r16gr45hgR5r47R11r44ggghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-319R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i420R16i504R17R18gR19r3R20jR21:4:1aoR14oR15i426R16i498R17R18gR19r26R20jR21:5:3r18oR14oR15i426R16i441R17R18gR19r26R20jR21:1:1r25goR14oR15i444R16i498R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i444R16i448R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i449R16i465R17R18gR19jR4:3:0R20jR21:9:2oR14oR15i449R16i463R17R18gR19r50R20jR21:1:1r49gajy14:hxsl.Component:0:0hgoR14oR15i467R16i491R17R18gR19r83R20jR21:5:3jR23:1:0oR14oR15i467R16i483R17R18gR19r83R20jR21:9:2oR14oR15i467R16i481R17R18gR19r50R20jR21:1:1r49gajR34:1:0hgoR14oR15i486R16i491R17R18gR19r83R20jR21:1:1oR0y5:flipYR9i-311R5jR10:2:0R11r83gggoR14oR15i493R16i494R17R18gR19r83R20jR21:0:1jy10:hxsl.Const:3:1zgoR14oR15i496R16i497R17R18gR19r83R20jR21:0:1jR36:3:1i1ghgghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-320R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i358R16i408R17y67:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fpass%2FCopy.hxgR19r3R20jR21:4:1aoR14oR15i364R16i402R17R38gR19r31R20jR21:5:3r18oR14oR15i364R16i374R17R38gR19r31R20jR21:1:1r32goR14oR15i377R16i402R17R38gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i377R16i384R17R38gR19jR4:14:1aoR3r136R12aoR0y1:_R11jR4:10:0goR0R30R11jR4:5:2i2r16ghghR20jR21:2:1jR33:33:0gaoR14oR15i377R16i384R17R38gR19r143R20jR21:1:1oR0y7:textureR9i-317R5r104R11r143ggoR14oR15i389R16i401R17R38gR19r37R20jR21:1:1r40ghgghgR12ahghy4:varsar46r103r22r32r40r152r5r58r121hg&quot;" line="17" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey25:h3d.pass._Copy.CopyShadery4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-318R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini330y3:maxi396y4:filey77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FScreenShader.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i336R16i361R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i336R16i348R17R18gR19r17R20jR21:1:1oR0y5:colorR9i-314y6:parentoR0y6:outputR9i-312R5jR10:4:0R11jR4:13:1aoR0y8:positionR9i-313R25r22R5r23R11jR4:5:2i4r16gr21hgR5r23R11r17ggoR14oR15i351R16i361R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y10:pixelColorR9i-315R5r23R11r31gggoR14oR15i367R16i390R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i367R16i379R17R18gR19r37R20jR21:1:1oR0y12:calculatedUVR9i-316R5r23R11r37ggoR14oR15i382R16i390R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y2:uvR9i-310R25oR0y5:inputR9i-308R5jR10:1:0R11jR4:13:1aoR0R27R9i-309R25r46R5r47R11jR4:5:2i2r16gr45hgR5r47R11r44ggghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-319R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i420R16i504R17R18gR19r3R20jR21:4:1aoR14oR15i426R16i498R17R18gR19r26R20jR21:5:3r18oR14oR15i426R16i441R17R18gR19r26R20jR21:1:1r25goR14oR15i444R16i498R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i444R16i448R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i449R16i465R17R18gR19jR4:3:0R20jR21:9:2oR14oR15i449R16i463R17R18gR19r50R20jR21:1:1r49gajy14:hxsl.Component:0:0hgoR14oR15i467R16i491R17R18gR19r83R20jR21:5:3jR23:1:0oR14oR15i467R16i483R17R18gR19r83R20jR21:9:2oR14oR15i467R16i481R17R18gR19r50R20jR21:1:1r49gajR34:1:0hgoR14oR15i486R16i491R17R18gR19r83R20jR21:1:1oR0y5:flipYR9i-311R5jR10:2:0R11r83gggoR14oR15i493R16i494R17R18gR19r83R20jR21:0:1jy10:hxsl.Const:3:1zgoR14oR15i496R16i497R17R18gR19r83R20jR21:0:1jR36:3:1i1ghgghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-320R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i358R16i408R17y67:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fpass%2FCopy.hxgR19r3R20jR21:4:1aoR14oR15i364R16i402R17R38gR19r31R20jR21:5:3r18oR14oR15i364R16i374R17R38gR19r31R20jR21:1:1r32goR14oR15i377R16i402R17R38gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i377R16i384R17R38gR19jR4:14:1aoR3r136R12aoR0y1:_R11jR4:10:0goR0R30R11jR4:5:2i2r16ghghR20jR21:2:1jR33:33:0gaoR14oR15i377R16i384R17R38gR19r143R20jR21:1:1oR0y7:textureR9i-317R5r104R11r143ggoR14oR15i389R16i401R17R38gR19r37R20jR21:1:1r40ghgghgR12ahghy4:varsar46r103r22r32r40r152r5r58r121hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture>
		<texture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="17">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="17">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<updateConstants public="1" set="method" line="17" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="17" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="17" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="17" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var texture:Sampler2D;
	function fragment() {
		pixelColor = texture.get(calculatedUV);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.pass.Copy" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Copy.hx">
		<extends path="h3d.pass.ScreenFx"><c path="h3d.pass._Copy.CopyShader"/></extends>
		<run public="1" set="method" line="55" static="1"><f a="from:to:?blend:?pass">
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Texture"/>
	<t path="h3d.mat.BlendMode"/>
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></run>
		<apply public="1" set="method" line="31"><f a="from:to:?blend:?customPass:?layer">
	<t path="hxsl.Sampler2D"/>
	<c path="h3d.mat.Texture"/>
	<t path="h3d.mat.BlendMode"/>
	<c path="h3d.mat.Pass"/>
	<x path="Int"/>
	<x path="Void"/>
</f></apply>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass._CubeCopy.CubeCopyShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/CubeCopy.hx" private="1" module="h3d.pass.CubeCopy">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;oy4:namey33:h3d.pass._CubeCopy.CubeCopyShadery4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-369R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini330y3:maxi396y4:filey77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FScreenShader.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i336R16i361R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i336R16i348R17R18gR19r17R20jR21:1:1oR0y5:colorR9i-364y6:parentoR0y6:outputR9i-362R5jR10:4:0R11jR4:13:1aoR0y8:positionR9i-363R25r22R5r23R11jR4:5:2i4r16gr21hgR5r23R11r17ggoR14oR15i351R16i361R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y10:pixelColorR9i-365R5r23R11r31gggoR14oR15i367R16i390R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i367R16i379R17R18gR19r37R20jR21:1:1oR0y12:calculatedUVR9i-366R5r23R11r37ggoR14oR15i382R16i390R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y2:uvR9i-360R25oR0y5:inputR9i-358R5jR10:1:0R11jR4:13:1aoR0R27R9i-359R25r46R5r47R11jR4:5:2i2r16gr45hgR5r47R11r44ggghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-370R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i420R16i504R17R18gR19r3R20jR21:4:1aoR14oR15i426R16i498R17R18gR19r26R20jR21:5:3r18oR14oR15i426R16i441R17R18gR19r26R20jR21:1:1r25goR14oR15i444R16i498R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i444R16i448R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i449R16i465R17R18gR19jR4:3:0R20jR21:9:2oR14oR15i449R16i463R17R18gR19r50R20jR21:1:1r49gajy14:hxsl.Component:0:0hgoR14oR15i467R16i491R17R18gR19r83R20jR21:5:3jR23:1:0oR14oR15i467R16i483R17R18gR19r83R20jR21:9:2oR14oR15i467R16i481R17R18gR19r50R20jR21:1:1r49gajR34:1:0hgoR14oR15i486R16i491R17R18gR19r83R20jR21:1:1oR0y5:flipYR9i-361R5jR10:2:0R11r83gggoR14oR15i493R16i494R17R18gR19r83R20jR21:0:1jy10:hxsl.Const:3:1zgoR14oR15i496R16i497R17R18gR19r83R20jR21:0:1jR36:3:1i1ghgghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-371R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i193R16i298R17y71:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fpass%2FCubeCopy.hxgR19r3R20jR21:4:1aoR14oR15i199R16i233R17R38gR19r3R20jR21:7:2oR0R30R9i-372R5r23R11r37goR14oR15i208R16i232R17R38gR19r37R20jR21:5:3jR23:3:0oR14oR15i208R16i226R17R38gR19r37R20jR21:5:3r92oR14oR15i208R16i220R17R38gR19r37R20jR21:1:1r40goR14oR15i223R16i226R17R38gR19r83R20jR21:0:1jR36:3:1d2ggoR14oR15i229R16i232R17R38gR19r83R20jR21:0:1jR36:3:1d1gggoR14oR15i238R16i292R17R38gR19r31R20jR21:5:3r18oR14oR15i238R16i248R17R38gR19r31R20jR21:1:1r32goR14oR15i251R16i292R17R38gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i251R16i258R17R38gR19jR4:14:1aoR3r158R12aoR0y1:_R11jR4:12:0goR0y6:normalR11jR4:5:2i3r16ghghR20jR21:2:1jR33:33:0gaoR14oR15i251R16i258R17R38gR19r165R20jR21:1:1oR0y7:textureR9i-367R5r104R11r165ggoR14oR15i263R16i291R17R38gR19r167R20jR21:8:2oR14oR15i263R16i272R17R38gR19jR4:14:1aoR3r167R12aoR0y5:valueR11r167ghghR20jR21:2:1jR33:31:0gaoR14oR15i273R16i290R17R38gR19r167R20jR21:5:3r92oR14oR15i273R16i284R17R38gR19jR4:5:2i3r16R20jR21:8:2oR14oR15i273R16i277R17R38gR19jR4:14:1ahR20jR21:2:1jR33:39:0gaoR14oR15i278R16i280R17R38gR19r37R20jR21:1:1r131goR14oR15i282R16i283R17R38gR19r83R20jR21:0:1jR36:3:1i1ghgoR14oR15i287R16i290R17R38gR19jR4:6:0R20jR21:1:1oR0y3:matR9i-368R5r104R11r210ggghghgghgR12ahghy4:varsar46r103r22r32r40r174r211r5r58r121hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey33:h3d.pass._CubeCopy.CubeCopyShadery4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-369R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini330y3:maxi396y4:filey77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FScreenShader.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i336R16i361R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i336R16i348R17R18gR19r17R20jR21:1:1oR0y5:colorR9i-364y6:parentoR0y6:outputR9i-362R5jR10:4:0R11jR4:13:1aoR0y8:positionR9i-363R25r22R5r23R11jR4:5:2i4r16gr21hgR5r23R11r17ggoR14oR15i351R16i361R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y10:pixelColorR9i-365R5r23R11r31gggoR14oR15i367R16i390R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i367R16i379R17R18gR19r37R20jR21:1:1oR0y12:calculatedUVR9i-366R5r23R11r37ggoR14oR15i382R16i390R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y2:uvR9i-360R25oR0y5:inputR9i-358R5jR10:1:0R11jR4:13:1aoR0R27R9i-359R25r46R5r47R11jR4:5:2i2r16gr45hgR5r47R11r44ggghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-370R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i420R16i504R17R18gR19r3R20jR21:4:1aoR14oR15i426R16i498R17R18gR19r26R20jR21:5:3r18oR14oR15i426R16i441R17R18gR19r26R20jR21:1:1r25goR14oR15i444R16i498R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i444R16i448R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i449R16i465R17R18gR19jR4:3:0R20jR21:9:2oR14oR15i449R16i463R17R18gR19r50R20jR21:1:1r49gajy14:hxsl.Component:0:0hgoR14oR15i467R16i491R17R18gR19r83R20jR21:5:3jR23:1:0oR14oR15i467R16i483R17R18gR19r83R20jR21:9:2oR14oR15i467R16i481R17R18gR19r50R20jR21:1:1r49gajR34:1:0hgoR14oR15i486R16i491R17R18gR19r83R20jR21:1:1oR0y5:flipYR9i-361R5jR10:2:0R11r83gggoR14oR15i493R16i494R17R18gR19r83R20jR21:0:1jy10:hxsl.Const:3:1zgoR14oR15i496R16i497R17R18gR19r83R20jR21:0:1jR36:3:1i1ghgghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-371R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i193R16i298R17y71:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fpass%2FCubeCopy.hxgR19r3R20jR21:4:1aoR14oR15i199R16i233R17R38gR19r3R20jR21:7:2oR0R30R9i-372R5r23R11r37goR14oR15i208R16i232R17R38gR19r37R20jR21:5:3jR23:3:0oR14oR15i208R16i226R17R38gR19r37R20jR21:5:3r92oR14oR15i208R16i220R17R38gR19r37R20jR21:1:1r40goR14oR15i223R16i226R17R38gR19r83R20jR21:0:1jR36:3:1d2ggoR14oR15i229R16i232R17R38gR19r83R20jR21:0:1jR36:3:1d1gggoR14oR15i238R16i292R17R38gR19r31R20jR21:5:3r18oR14oR15i238R16i248R17R38gR19r31R20jR21:1:1r32goR14oR15i251R16i292R17R38gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i251R16i258R17R38gR19jR4:14:1aoR3r158R12aoR0y1:_R11jR4:12:0goR0y6:normalR11jR4:5:2i3r16ghghR20jR21:2:1jR33:33:0gaoR14oR15i251R16i258R17R38gR19r165R20jR21:1:1oR0y7:textureR9i-367R5r104R11r165ggoR14oR15i263R16i291R17R38gR19r167R20jR21:8:2oR14oR15i263R16i272R17R38gR19jR4:14:1aoR3r167R12aoR0y5:valueR11r167ghghR20jR21:2:1jR33:31:0gaoR14oR15i273R16i290R17R38gR19r167R20jR21:5:3r92oR14oR15i273R16i284R17R38gR19jR4:5:2i3r16R20jR21:8:2oR14oR15i273R16i277R17R38gR19jR4:14:1ahR20jR21:2:1jR33:39:0gaoR14oR15i278R16i280R17R38gR19r37R20jR21:1:1r131goR14oR15i282R16i283R17R38gR19r83R20jR21:0:1jR36:3:1i1ghgoR14oR15i287R16i290R17R38gR19jR4:6:0R20jR21:1:1oR0y3:matR9i-368R5r104R11r210ggghghgghgR12ahghy4:varsar46r103r22r32r40r174r211r5r58r121hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.SamplerCube"/></texture>
		<texture__>
			<t path="hxsl.SamplerCube"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.SamplerCube"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.SamplerCube"/>
				<t path="hxsl.SamplerCube"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<mat public="1" get="accessor" set="accessor"><t path="hxsl.Matrix"/></mat>
		<mat__ expr="new hxsl.Types.Matrix()">
			<t path="hxsl.Matrix"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Matrix()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</mat__>
		<get_mat get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_mat>
		<set_mat get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Matrix"/>
				<t path="hxsl.Matrix"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_mat>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var texture:SamplerCube;
	@param var mat:Mat3;
	function fragment() {
		var uv = calculatedUV * 2.0 - 1.0;
		pixelColor = texture.get(normalize(vec3(uv, 1) * mat));
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.pass.CubeCopy" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/CubeCopy.hx">
		<extends path="h3d.pass.ScreenFx"><c path="h3d.pass._CubeCopy.CubeCopyShader"/></extends>
		<run public="1" set="method" line="55" static="1"><f a="from:to:?blend:?pass">
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Texture"/>
	<t path="h3d.mat.BlendMode"/>
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></run>
		<cubeDir expr="[h3d.Matrix.L([0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 0]), h3d.Matrix.L([0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0]), h3d.Matrix.L([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0])]">
			<c path="Array"><c path="h3d.Matrix"/></c>
			<meta><m n=":value"><e>[h3d.Matrix.L([0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 0]), h3d.Matrix.L([0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0]), h3d.Matrix.L([1, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0]), h3d.Matrix.L([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0])]</e></m></meta>
		</cubeDir>
		<apply public="1" set="method" line="28"><f a="from:to:?blend:?customPass">
	<t path="hxsl.SamplerCube"/>
	<c path="h3d.mat.Texture"/>
	<t path="h3d.mat.BlendMode"/>
	<c path="h3d.mat.Pass"/>
	<x path="Void"/>
</f></apply>
		<new public="1" set="method" line="24"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass.Default" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Default.hx">
		<extends path="h3d.pass.Base"/>
		<manager><c path="h3d.pass.ShaderManager"/></manager>
		<globals get="accessor" set="null"><c path="hxsl.Globals"/></globals>
		<cachedBuffer><c path="h3d.shader.Buffers"/></cachedBuffer>
		<shaderCount expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</shaderCount>
		<textureCount expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</textureCount>
		<shaderIdMap><c path="Array"><x path="Int"/></c></shaderIdMap>
		<textureIdMap><c path="Array"><x path="Int"/></c></textureIdMap>
		<sortPasses expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</sortPasses>
		<logEnable get="accessor" set="null"><x path="Bool"/></logEnable>
		<get_globals get="inline" set="null" line="17"><f a=""><c path="hxsl.Globals"/></f></get_globals>
		<cameraView get="accessor" set="accessor">
			<c path="h3d.Matrix"/>
			<meta><m n="global"><e>"camera.view"</e></m></meta>
		</cameraView>
		<cameraNear get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="global"><e>"camera.zNear"</e></m></meta>
		</cameraNear>
		<cameraFar get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="global"><e>"camera.zFar"</e></m></meta>
		</cameraFar>
		<cameraProj get="accessor" set="accessor">
			<c path="h3d.Matrix"/>
			<meta><m n="global"><e>"camera.proj"</e></m></meta>
		</cameraProj>
		<cameraPos get="accessor" set="accessor">
			<c path="h3d.Vector"/>
			<meta><m n="global"><e>"camera.position"</e></m></meta>
		</cameraPos>
		<cameraProjDiag get="accessor" set="accessor">
			<c path="h3d.Vector"/>
			<meta><m n="global"><e>"camera.projDiag"</e></m></meta>
		</cameraProjDiag>
		<cameraProjFlip get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="global"><e>"camera.projFlip"</e></m></meta>
		</cameraProjFlip>
		<cameraViewProj get="accessor" set="accessor">
			<c path="h3d.Matrix"/>
			<meta><m n="global"><e>"camera.viewProj"</e></m></meta>
		</cameraViewProj>
		<cameraInverseViewProj get="accessor" set="accessor">
			<c path="h3d.Matrix"/>
			<meta><m n="global"><e>"camera.inverseViewProj"</e></m></meta>
		</cameraInverseViewProj>
		<globalTime get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n="global"><e>"global.time"</e></m></meta>
		</globalTime>
		<pixelSize get="accessor" set="accessor">
			<c path="h3d.Vector"/>
			<meta><m n="global"><e>"global.pixelSize"</e></m></meta>
		</pixelSize>
		<globalModelView get="accessor" set="accessor">
			<c path="h3d.Matrix"/>
			<meta><m n="global"><e>"global.modelView"</e></m></meta>
		</globalModelView>
		<globalModelViewInverse get="accessor" set="accessor">
			<c path="h3d.Matrix"/>
			<meta><m n="global"><e>"global.modelViewInverse"</e></m></meta>
		</globalModelViewInverse>
		<get_logEnable get="inline" set="null" line="41"><f a=""><x path="Bool"/></f></get_logEnable>
		<getOutputs set="method" line="49"><f a=""><c path="Array"><e path="hxsl.Output"/></c></f></getOutputs>
		<compileShader public="1" set="method" line="53" override="1"><f a="p">
	<c path="h3d.mat.Pass"/>
	<c path="hxsl.RuntimeShader"/>
</f></compileShader>
		<processShaders set="method" line="60"><f a="p:shaders">
	<c path="h3d.pass.Object"/>
	<c path="hxsl.ShaderList"/>
	<c path="hxsl.ShaderList"/>
</f></processShaders>
		<setupShaders set="method" line="70">
			<f a="passes">
				<c path="h3d.pass.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>h3d.scene</e></m></meta>
		</setupShaders>
		<uploadParams set="method" line="96"><f a=""><x path="Void"/></f></uploadParams>
		<log get="inline" set="null" line="102"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></log>
		<drawObject set="method" line="106"><f a="p">
	<c path="h3d.pass.Object"/>
	<x path="Void"/>
</f></drawObject>
		<draw public="1" set="method" line="113" override="1">
			<f a="passes">
				<c path="h3d.pass.Object"/>
				<c path="h3d.pass.Object"/>
			</f>
			<meta><m n=":access"><e>h3d.scene</e></m></meta>
		</draw>
		<cameraView_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Matrix"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraView_id>
		<get_cameraView get="inline" set="null" line="19"><f a=""><c path="h3d.Matrix"/></f></get_cameraView>
		<set_cameraView get="inline" set="null" line="19"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_cameraView>
		<cameraNear_id>
			<x path="hxsl.GlobalSlot"><x path="Float"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraNear_id>
		<get_cameraNear get="inline" set="null" line="20"><f a=""><x path="Float"/></f></get_cameraNear>
		<set_cameraNear get="inline" set="null" line="20"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_cameraNear>
		<cameraFar_id>
			<x path="hxsl.GlobalSlot"><x path="Float"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraFar_id>
		<get_cameraFar get="inline" set="null" line="21"><f a=""><x path="Float"/></f></get_cameraFar>
		<set_cameraFar get="inline" set="null" line="21"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_cameraFar>
		<cameraProj_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Matrix"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraProj_id>
		<get_cameraProj get="inline" set="null" line="22"><f a=""><c path="h3d.Matrix"/></f></get_cameraProj>
		<set_cameraProj get="inline" set="null" line="22"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_cameraProj>
		<cameraPos_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Vector"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraPos_id>
		<get_cameraPos get="inline" set="null" line="23"><f a=""><c path="h3d.Vector"/></f></get_cameraPos>
		<set_cameraPos get="inline" set="null" line="23"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></set_cameraPos>
		<cameraProjDiag_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Vector"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraProjDiag_id>
		<get_cameraProjDiag get="inline" set="null" line="24"><f a=""><c path="h3d.Vector"/></f></get_cameraProjDiag>
		<set_cameraProjDiag get="inline" set="null" line="24"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></set_cameraProjDiag>
		<cameraProjFlip_id>
			<x path="hxsl.GlobalSlot"><x path="Float"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraProjFlip_id>
		<get_cameraProjFlip get="inline" set="null" line="25"><f a=""><x path="Float"/></f></get_cameraProjFlip>
		<set_cameraProjFlip get="inline" set="null" line="25"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_cameraProjFlip>
		<cameraViewProj_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Matrix"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraViewProj_id>
		<get_cameraViewProj get="inline" set="null" line="26"><f a=""><c path="h3d.Matrix"/></f></get_cameraViewProj>
		<set_cameraViewProj get="inline" set="null" line="26"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_cameraViewProj>
		<cameraInverseViewProj_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Matrix"/></x>
			<meta><m n=":noCompletion"/></meta>
		</cameraInverseViewProj_id>
		<get_cameraInverseViewProj get="inline" set="null" line="27"><f a=""><c path="h3d.Matrix"/></f></get_cameraInverseViewProj>
		<set_cameraInverseViewProj get="inline" set="null" line="27"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_cameraInverseViewProj>
		<globalTime_id>
			<x path="hxsl.GlobalSlot"><x path="Float"/></x>
			<meta><m n=":noCompletion"/></meta>
		</globalTime_id>
		<get_globalTime get="inline" set="null" line="28"><f a=""><x path="Float"/></f></get_globalTime>
		<set_globalTime get="inline" set="null" line="28"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_globalTime>
		<pixelSize_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Vector"/></x>
			<meta><m n=":noCompletion"/></meta>
		</pixelSize_id>
		<get_pixelSize get="inline" set="null" line="29"><f a=""><c path="h3d.Vector"/></f></get_pixelSize>
		<set_pixelSize get="inline" set="null" line="29"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></set_pixelSize>
		<globalModelView_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Matrix"/></x>
			<meta><m n=":noCompletion"/></meta>
		</globalModelView_id>
		<get_globalModelView get="inline" set="null" line="30"><f a=""><c path="h3d.Matrix"/></f></get_globalModelView>
		<set_globalModelView get="inline" set="null" line="30"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_globalModelView>
		<globalModelViewInverse_id>
			<x path="hxsl.GlobalSlot"><c path="h3d.Matrix"/></x>
			<meta><m n=":noCompletion"/></meta>
		</globalModelViewInverse_id>
		<get_globalModelViewInverse get="inline" set="null" line="31"><f a=""><c path="h3d.Matrix"/></f></get_globalModelViewInverse>
		<set_globalModelViewInverse get="inline" set="null" line="31"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_globalModelViewInverse>
		<initGlobals set="method" line="3"><f a=""><x path="Void"/></f></initGlobals>
		<setGlobals set="method" line="3"><f a=""><x path="Void"/></f></setGlobals>
		<new public="1" set="method" line="33"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>hxsl.Macros.buildGlobals()</e></m>
			<m n=":access"><e>h3d.mat.Pass</e></m>
		</meta>
	</class>
	<class path="h3d.pass.Shadows" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Shadows.hx">
		<extends path="h3d.pass.Default"/>
		<lightCamera><c path="h3d.Camera"/></lightCamera>
		<format><e path="hxd.PixelFormat"/></format>
		<staticTexture><c path="h3d.mat.Texture"/></staticTexture>
		<light><c path="h3d.scene.Light"/></light>
		<mode public="1" set="accessor" expr="None">
			<e path="h3d.pass.RenderMode"/>
			<meta><m n=":value"><e>None</e></m></meta>
		</mode>
		<size public="1" set="accessor" expr="1024">
			<x path="Int"/>
			<meta><m n=":value"><e>1024</e></m></meta>
		</size>
		<shader public="1" set="null"><c path="hxsl.Shader"/></shader>
		<blur public="1"><c path="h3d.pass.Blur"/></blur>
		<power public="1" expr="30.0">
			<x path="Float"/>
			<meta><m n=":value"><e>30.0</e></m></meta>
		</power>
		<bias public="1" expr="0.01">
			<x path="Float"/>
			<meta><m n=":value"><e>0.01</e></m></meta>
		</bias>
		<set_mode set="method" line="34"><f a="m">
	<e path="h3d.pass.RenderMode"/>
	<e path="h3d.pass.RenderMode"/>
</f></set_mode>
		<set_size set="method" line="39"><f a="s">
	<x path="Int"/>
	<x path="Int"/>
</f></set_size>
		<dispose public="1" set="method" line="47" override="1"><f a=""><x path="Void"/></f></dispose>
		<getShadowProj public="1" set="method" line="54"><f a=""><c path="h3d.Matrix"/></f></getShadowProj>
		<getShadowTex public="1" set="method" line="58"><f a=""><t path="hxsl.ChannelTextureType"/></f></getShadowTex>
		<isUsingWorldDist set="method" line="62"><f a=""><x path="Bool"/></f></isUsingWorldDist>
		<getOutputs set="method" line="66" override="1"><f a=""><c path="Array"><e path="hxsl.Output"/></c></f></getOutputs>
		<loadStaticData public="1" set="method" line="75"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></loadStaticData>
		<saveStaticData public="1" set="method" line="79"><f a=""><c path="haxe.io.Bytes"/></f></saveStaticData>
		<computeStatic public="1" set="method" line="83"><f a="passes">
	<c path="h3d.pass.Object"/>
	<x path="Void"/>
</f></computeStatic>
		<filterPasses set="method" line="87"><f a="passes">
	<c path="h3d.pass.Object"/>
	<c path="h3d.pass.Object"/>
</f></filterPasses>
		<new public="1" set="method" line="24"><f a="light">
	<c path="h3d.scene.Light"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.pass.DirShadowMap" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/DirShadowMap.hx">
		<extends path="h3d.pass.Shadows"/>
		<customDepth><x path="Bool"/></customDepth>
		<depth><c path="h3d.mat.DepthBuffer"/></depth>
		<dshader><c path="h3d.shader.DirShadow"/></dshader>
		<border><c path="h3d.pass.Border"/></border>
		<mergePass expr="new h3d.pass.ScreenFx(new h3d.shader.MinMaxShader())">
			<c path="h3d.pass.ScreenFx"><c path="h3d.shader.MinMaxShader"/></c>
			<meta><m n=":value"><e>new h3d.pass.ScreenFx(new h3d.shader.MinMaxShader())</e></m></meta>
		</mergePass>
		<set_mode set="method" line="21" override="1"><f a="m">
	<e path="h3d.pass.RenderMode"/>
	<e path="h3d.pass.RenderMode"/>
</f></set_mode>
		<set_size set="method" line="26" override="1"><f a="s">
	<x path="Int"/>
	<x path="Int"/>
</f></set_size>
		<dispose public="1" set="method" line="34" override="1"><f a=""><x path="Void"/></f></dispose>
		<getShadowTex public="1" set="method" line="39" override="1"><f a=""><t path="hxsl.ChannelTextureType"/></f></getShadowTex>
		<calcShadowBounds public="1" set="dynamic" line="43"><f a="camera">
	<c path="h3d.Camera"/>
	<x path="Void"/>
</f></calcShadowBounds>
		<setGlobals set="method" line="102" override="1"><f a=""><x path="Void"/></f></setGlobals>
		<syncShader set="method" line="112"><f a="texture">
	<t path="hxsl.ChannelTextureType"/>
	<x path="Void"/>
</f></syncShader>
		<saveStaticData public="1" set="method" line="120" override="1"><f a=""><c path="haxe.io.Bytes"/></f></saveStaticData>
		<loadStaticData public="1" set="method" line="145" override="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></loadStaticData>
		<draw public="1" set="method" line="174" override="1"><f a="passes">
	<c path="h3d.pass.Object"/>
	<c path="h3d.pass.Object"/>
</f></draw>
		<computeStatic public="1" set="method" line="240" override="1"><f a="passes">
	<c path="h3d.pass.Object"/>
	<x path="Void"/>
</f></computeStatic>
		<new public="1" set="method" line="11"><f a="light">
	<c path="h3d.scene.Light"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.pass.DefaultShadowMap" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/DefaultShadowMap.hx">
		<extends path="h3d.pass.DirShadowMap"/>
		<shadowMapId><x path="Int"/></shadowMapId>
		<shadowProjId><x path="Int"/></shadowProjId>
		<shadowColorId><x path="Int"/></shadowColorId>
		<shadowPowerId><x path="Int"/></shadowPowerId>
		<shadowBiasId><x path="Int"/></shadowBiasId>
		<color public="1"><c path="h3d.Vector"/></color>
		<draw public="1" set="method" line="27" override="1"><f a="passes">
	<c path="h3d.pass.Object"/>
	<c path="h3d.pass.Object"/>
</f></draw>
		<new public="1" set="method" line="13">
			<f a="?size:?format" v="1024:">
				<x path="Int"/>
				<e path="hxd.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ size : 1024 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass._HardwarePick.FixedColor" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/HardwarePick.hx" private="1" module="h3d.pass.HardwarePick">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey33:h3d.pass._HardwarePick.FixedColory4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:0:0y3:refoR0y6:vertexy2:idi-6R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini237y3:maxi360y4:filey75:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fpass%2FHardwarePick.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i243R16i354R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i243R16i258R17R18gR19r17R20jR21:1:1oR0y8:positionR9i-4y6:parentoR0y6:outputR9i-3R5jR10:4:0R11jR4:13:1ar21oR0y7:colorIDR9i-5R25r22R5r23R11jR4:5:2i4r16ghgR5r23R11r17ggoR14oR15i261R16i354R17R18gR19jR4:5:2i4r16R20jR21:5:3jR23:1:0oR14oR15i261R16i326R17R18gR19jR4:5:2i4r16R20jR21:3:1oR14oR15i262R16i325R17R18gR19r35R20jR21:5:3jR23:0:0oR14oR15i262R16i277R17R18gR19r17R20jR21:1:1r21goR14oR15i280R16i325R17R18gR19jR4:5:2i4r16R20jR21:5:3r32oR14oR15i280R16i305R17R18gR19r44R20jR21:8:2oR14oR15i280R16i284R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i285R16i296R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i285R16i293R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y8:viewportR9i-2R5jR10:2:0R11r59ggajy14:hxsl.Component:0:0jR30:1:0hgoR14oR15i298R16i300R17R18gR19jR4:3:0R20jR21:0:1jy10:hxsl.Const:3:1d0goR14oR15i302R16i304R17R18gR19r69R20jR21:0:1jR31:3:1d0ghgoR14oR15i308R16i325R17R18gR19r69R20jR21:9:2oR14oR15i308R16i323R17R18gR19r17R20jR21:1:1r21gajR30:3:0hggggoR14oR15i329R16i354R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i329R16i333R17R18gR19r50R20jR21:2:1r51gaoR14oR15i334R16i345R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i334R16i342R17R18gR19r59R20jR21:1:1r60gajR30:2:0r83hgoR14oR15i347R16i349R17R18gR19r69R20jR21:0:1jR31:3:1d1goR14oR15i351R16i353R17R18gR19r69R20jR21:0:1jR31:3:1d1ghggghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-7R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i384R16i420R17R18gR19r3R20jR21:4:1aoR14oR15i390R16i414R17R18gR19r26R20jR21:5:3r18oR14oR15i390R16i404R17R18gR19r26R20jR21:1:1r25goR14oR15i407R16i414R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0R27R9i-1R5r61R11r134ggghgR12ahghy4:varsar135r60r22r5r119hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey33:h3d.pass._HardwarePick.FixedColory4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:0:0y3:refoR0y6:vertexy2:idi-6R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini237y3:maxi360y4:filey75:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fpass%2FHardwarePick.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i243R16i354R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i243R16i258R17R18gR19r17R20jR21:1:1oR0y8:positionR9i-4y6:parentoR0y6:outputR9i-3R5jR10:4:0R11jR4:13:1ar21oR0y7:colorIDR9i-5R25r22R5r23R11jR4:5:2i4r16ghgR5r23R11r17ggoR14oR15i261R16i354R17R18gR19jR4:5:2i4r16R20jR21:5:3jR23:1:0oR14oR15i261R16i326R17R18gR19jR4:5:2i4r16R20jR21:3:1oR14oR15i262R16i325R17R18gR19r35R20jR21:5:3jR23:0:0oR14oR15i262R16i277R17R18gR19r17R20jR21:1:1r21goR14oR15i280R16i325R17R18gR19jR4:5:2i4r16R20jR21:5:3r32oR14oR15i280R16i305R17R18gR19r44R20jR21:8:2oR14oR15i280R16i284R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i285R16i296R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i285R16i293R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y8:viewportR9i-2R5jR10:2:0R11r59ggajy14:hxsl.Component:0:0jR30:1:0hgoR14oR15i298R16i300R17R18gR19jR4:3:0R20jR21:0:1jy10:hxsl.Const:3:1d0goR14oR15i302R16i304R17R18gR19r69R20jR21:0:1jR31:3:1d0ghgoR14oR15i308R16i325R17R18gR19r69R20jR21:9:2oR14oR15i308R16i323R17R18gR19r17R20jR21:1:1r21gajR30:3:0hggggoR14oR15i329R16i354R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i329R16i333R17R18gR19r50R20jR21:2:1r51gaoR14oR15i334R16i345R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i334R16i342R17R18gR19r59R20jR21:1:1r60gajR30:2:0r83hgoR14oR15i347R16i349R17R18gR19r69R20jR21:0:1jR31:3:1d1goR14oR15i351R16i353R17R18gR19r69R20jR21:0:1jR31:3:1d1ghggghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-7R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i384R16i420R17R18gR19r3R20jR21:4:1aoR14oR15i390R16i414R17R18gR19r26R20jR21:5:3r18oR14oR15i390R16i404R17R18gR19r26R20jR21:1:1r25goR14oR15i407R16i414R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0R27R9i-1R5r61R11r134ggghgR12ahghy4:varsar135r60r22r5r119hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<colorID public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></colorID>
		<colorID__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</colorID__>
		<get_colorID get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_colorID>
		<set_colorID get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_colorID>
		<viewport public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></viewport>
		<viewport__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</viewport__>
		<get_viewport get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_viewport>
		<set_viewport get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_viewport>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var colorID:Vec4;
	@param var viewport:Vec4;
	var output:{ var position : Vec4; var colorID : Vec4};
	function vertex() {
		output.position = (output.position + vec4(viewport.xy, 0., 0.) * output.position.w) * vec4(viewport.zw, 1., 1.);
	};
	function fragment() {
		output.colorID = colorID;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.pass.HardwarePick" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/HardwarePick.hx">
		<extends path="h3d.pass.Default"/>
		<pickX public="1"><x path="Float"/></pickX>
		<pickY public="1"><x path="Float"/></pickY>
		<fixedColor expr="new FixedColor()">
			<c path="h3d.pass._HardwarePick.FixedColor"/>
			<meta><m n=":value"><e>new FixedColor()</e></m></meta>
		</fixedColor>
		<colorID><x path="Int"/></colorID>
		<texOut><c path="h3d.mat.Texture"/></texOut>
		<material><c path="h3d.mat.Pass"/></material>
		<pickedIndex public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</pickedIndex>
		<dispose public="1" set="method" line="45" override="1"><f a=""><x path="Void"/></f></dispose>
		<getOutputs set="method" line="53" override="1"><f a=""><c path="Array"><e path="hxsl.Output"/></c></f></getOutputs>
		<drawObject set="method" line="57" override="1"><f a="p">
	<c path="h3d.pass.Object"/>
	<x path="Void"/>
</f></drawObject>
		<nextID get="inline" set="null" line="62"><f a=""><x path="Void"/></f></nextID>
		<draw public="1" set="method" line="66" override="1"><f a="passes">
	<c path="h3d.pass.Object"/>
	<c path="h3d.pass.Object"/>
</f></draw>
		<new public="1" set="method" line="33"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass.Object" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Object.hx">
		<pass public="1"><c path="h3d.mat.Pass"/></pass>
		<obj public="1"><c path="h3d.scene.Object"/></obj>
		<index public="1"><x path="Int"/></index>
		<next public="1"><c path="h3d.pass.Object"/></next>
		<nextAlloc public="1"><c path="h3d.pass.Object"/></nextAlloc>
		<shaders public="1"><c path="hxsl.ShaderList"/></shaders>
		<shader public="1"><c path="hxsl.RuntimeShader"/></shader>
		<depth public="1"><x path="Float"/></depth>
		<texture public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</texture>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.pass.ShaderManager" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/ShaderManager.hx">
		<STRICT public="1" expr="true" line="5" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</STRICT>
		<globals public="1"><c path="hxsl.Globals"/></globals>
		<shaderCache><c path="hxsl.Cache"/></shaderCache>
		<currentOutput><c path="hxsl.ShaderList"/></currentOutput>
		<setOutput public="1" set="method" line="21"><f a="?output">
	<c path="Array"><e path="hxsl.Output"/></c>
	<x path="Void"/>
</f></setOutput>
		<fillRec set="method" line="27">
			<f a="v:type:out:pos">
				<d/>
				<e path="hxsl.Type"/>
				<t path="h3d.shader.ShaderBufferData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</fillRec>
		<shaderInfo set="method" line="154"><f a="shaders:path">
	<c path="hxsl.ShaderList"/>
	<c path="String"/>
	<c path="String"/>
</f></shaderInfo>
		<getParamValue public="1" get="inline" set="null" line="166">
			<f a="p:shaders:?opt" v="::false">
				<c path="hxsl.AllocParam"/>
				<c path="hxsl.ShaderList"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":value"><e>{ opt : false }</e></m></meta>
		</getParamValue>
		<fillGlobals public="1" set="method" line="182"><f a="buf:s">
	<c path="h3d.shader.Buffers"/>
	<c path="hxsl.RuntimeShader"/>
	<x path="Void"/>
</f></fillGlobals>
		<fillParams public="1" set="method" line="203"><f a="buf:s:shaders">
	<c path="h3d.shader.Buffers"/>
	<c path="hxsl.RuntimeShader"/>
	<c path="hxsl.ShaderList"/>
	<x path="Void"/>
</f></fillParams>
		<compileShaders public="1" set="method" line="237"><f a="shaders">
	<c path="hxsl.ShaderList"/>
	<c path="hxsl.RuntimeShader"/>
</f></compileShaders>
		<new public="1" set="method" line="11"><f a="?output">
	<c path="Array"><e path="hxsl.Output"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="h3d.pass.RenderMode" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/pass/Shadows.hx" module="h3d.pass.Shadows">
		<None/>
		<Static/>
		<Dynamic/>
		<Mixed/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h3d.prim.BigPrimitive" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/prim/BigPrimitive.hx">
		<extends path="h3d.prim.Primitive"/>
		<PREV_BUFFER static="1"><x path="hxd.FloatBuffer"/></PREV_BUFFER>
		<PREV_INDEX static="1"><x path="hxd.IndexBuffer"/></PREV_INDEX>
		<isRaw><x path="Bool"/></isRaw>
		<stride><x path="Int"/></stride>
		<buffers><c path="Array"><c path="h3d.Buffer"/></c></buffers>
		<allIndexes><c path="Array"><c path="h3d.Indexes"/></c></allIndexes>
		<tmpBuf><x path="hxd.FloatBuffer"/></tmpBuf>
		<tmpIdx><x path="hxd.IndexBuffer"/></tmpIdx>
		<bounds><c path="h3d.col.Bounds"/></bounds>
		<bufPos expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bufPos>
		<idxPos expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</idxPos>
		<startIndex expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</startIndex>
		<flushing><x path="Bool"/></flushing>
		<hasTangents public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hasTangents>
		<isStatic public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</isStatic>
		<begin public="1" set="method" line="46">
			<f a="vcount:icount">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Call begin() before starting to add vertexes/indexes to the primitive.
		The count value is the number of vertexes you will add, it will automatically flush() if it doesn't fit into the current buffer.</haxe_doc>
		</begin>
		<addPoint public="1" get="inline" set="null" line="81">
			<f a="x:y:z">
				<t path="hxd.impl.Float32"/>
				<t path="hxd.impl.Float32"/>
				<t path="hxd.impl.Float32"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This is similar to addVertexValue for X Y and Z, but will also update the bounds if you wish to have them calculated.</haxe_doc>
		</addPoint>
		<addBounds public="1" get="inline" set="null" line="88"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addBounds>
		<addVertexValue public="1" get="inline" set="null" line="92"><f a="v">
	<t path="hxd.impl.Float32"/>
	<x path="Void"/>
</f></addVertexValue>
		<addIndex public="1" get="inline" set="null" line="96"><f a="i">
	<x path="Int"/>
	<x path="Void"/>
</f></addIndex>
		<triCount public="1" set="method" line="100" override="1"><f a=""><x path="Int"/></f></triCount>
		<vertexCount public="1" set="method" line="108" override="1"><f a=""><x path="Int"/></f></vertexCount>
		<flush public="1" set="method" line="120">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Flush the current buffer.
		It is required to call begin() after a flush()</haxe_doc>
		</flush>
		<render public="1" set="method" line="142" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<getBounds public="1" set="method" line="148" override="1"><f a=""><c path="h3d.col.Bounds"/></f></getBounds>
		<dispose public="1" set="method" line="152" override="1"><f a=""><x path="Void"/></f></dispose>
		<clear public="1" set="method" line="156"><f a=""><x path="Void"/></f></clear>
		<add public="1" set="method" line="178">
			<f a="buf:idx:?dx:?dy:?dz:?rotation:?scale:?stride" v="::0.:0.:0.:0.:1.:-1">
				<x path="hxd.FloatBuffer"/>
				<x path="hxd.IndexBuffer"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ stride : -1, scale : 1., rotation : 0., dz : 0., dy : 0., dx : 0. }</e></m></meta>
			<haxe_doc>Adds a complete object to the primitive, with custom position,scale,rotation.
		See addSub for complete documentation.</haxe_doc>
		</add>
		<addSub public="1" set="method" line="190">
			<f a="buf:idx:startVert:startTri:nvert:triCount:?dx:?dy:?dz:?rotation:?scale:?stride:?deltaU:?deltaV:?color:?mat" v="::::::0.:0.:0.:0.:1.:-1:0.:0.:1.:null">
				<x path="hxd.FloatBuffer"/>
				<x path="hxd.IndexBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h3d.Matrix"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ mat : null, color : 1., deltaV : 0., deltaU : 0., stride : -1, scale : 1., rotation : 0., dz : 0., dy : 0., dx : 0. }</e></m>
				<m n=":noDebug"/>
			</meta>
			<haxe_doc>Adds a buffer to the primitive, with custom position,scale,rotation.
		The buffer can have more stride than the BigPrimitive, but not less.
		It is assumed that the buffer contains [X,Y,Z,NX,NY,NZ,U,V,R,G,B] (depending on his stride) so the different offsets are applied to the corresponding components.
		If hasTangent=true, we have [TX,TY,TZ] just after normal.
		However if the stride is 5, we assume [X,Y,Z,U,V]
		If mat is not null, it overrides dx, dy, dz, rotation, scale</haxe_doc>
		</addSub>
		<new public="1" set="method" line="30">
			<f a="stride:?isRaw:?pos" v=":false:">
				<x path="Int"/>
				<x path="Bool"/>
				<t path="h3d.impl.AllocPos"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ isRaw : false }</e></m></meta>
		</new>
		<haxe_doc>Vertex buffers are limited to 65K vertexes because of the 16-bits limitation of the index buffers.
	BigPrimitive allows you to easily create large buffers by spliting the buffers.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.prim.MeshPrimitive" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/prim/MeshPrimitive.hx">
		<extends path="h3d.prim.Primitive"/>
		<bufferCache><t path="Map">
	<x path="Int"/>
	<c path="h3d.BufferOffset"/>
</t></bufferCache>
		<prevNames><c path="Array"><c path="String"/></c></prevNames>
		<prevBuffers><c path="h3d.BufferOffset"/></prevBuffers>
		<allocBuffer set="method" line="9"><f a="engine:name">
	<c path="h3d.Engine"/>
	<c path="String"/>
	<x path="Null"><c path="h3d.BufferOffset"/></x>
</f></allocBuffer>
		<hasBuffer public="1" set="method" line="13"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasBuffer>
		<addBuffer set="method" line="19">
			<f a="name:buf:?offset" v="::0">
				<c path="String"/>
				<c path="h3d.Buffer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0 }</e></m></meta>
		</addBuffer>
		<dispose public="1" set="method" line="28" override="1"><f a=""><x path="Void"/></f></dispose>
		<getBuffers set="method" line="37"><f a="engine">
	<c path="h3d.Engine"/>
	<c path="h3d.BufferOffset"/>
</f></getBuffers>
		<render public="1" set="method" line="64" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
	</class>
	<class path="h3d.prim.HMDModel" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/prim/HMDModel.hx">
		<extends path="h3d.prim.MeshPrimitive"/>
		<data><c path="hxd.fmt.hmd.Geometry"/></data>
		<dataPosition><x path="Int"/></dataPosition>
		<indexCount><x path="Int"/></indexCount>
		<indexesTriPos><c path="Array"><x path="Int"/></c></indexesTriPos>
		<lib><c path="hxd.fmt.hmd.Library"/></lib>
		<curMaterial><x path="Int"/></curMaterial>
		<collider><c path="h3d.col.Collider"/></collider>
		<normalsRecomputed><c path="String"/></normalsRecomputed>
		<bufferAliases expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<a>
					<realName><c path="String"/></realName>
					<offset><x path="Int"/></offset>
				</a>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</bufferAliases>
		<triCount public="1" set="method" line="21" override="1"><f a=""><x path="Int"/></f></triCount>
		<vertexCount public="1" set="method" line="25" override="1"><f a=""><x path="Int"/></f></vertexCount>
		<getBounds public="1" set="method" line="29" override="1"><f a=""><c path="h3d.col.Bounds"/></f></getBounds>
		<selectMaterial public="1" set="method" line="33" override="1"><f a="i">
	<x path="Int"/>
	<x path="Void"/>
</f></selectMaterial>
		<getDataBuffers public="1" set="method" line="37"><f a="fmt:?defaults:?material">
	<c path="Array"><c path="hxd.fmt.hmd.GeometryFormat"/></c>
	<c path="Array"><c path="h3d.Vector"/></c>
	<x path="Int"/>
	<c path="hxd.fmt.hmd.GeometryBuffer"/>
</f></getDataBuffers>
		<loadSkin public="1" set="method" line="41"><f a="skin">
	<c path="h3d.anim.Skin"/>
	<x path="Void"/>
</f></loadSkin>
		<addAlias public="1" set="method" line="45">
			<f a="name:realName:?offset" v="::0">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0 }</e></m></meta>
		</addAlias>
		<alloc public="1" set="method" line="49" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<recomputeNormals public="1" set="method" line="95"><f a="?name">
	<c path="String"/>
	<x path="Void"/>
</f></recomputeNormals>
		<render public="1" set="method" line="139" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<initCollider set="method" line="150"><f a="poly">
	<c path="h3d.col.PolygonBuffer"/>
	<x path="Void"/>
</f></initCollider>
		<getCollider public="1" set="method" line="159" override="1"><f a=""><c path="h3d.col.Collider"/></f></getCollider>
		<new public="1" set="method" line="15"><f a="data:dataPos:lib">
	<c path="hxd.fmt.hmd.Geometry"/>
	<x path="Int"/>
	<c path="hxd.fmt.hmd.Library"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.prim.ModelCache" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/prim/ModelCache.hx">
		<models><t path="Map">
	<c path="String"/>
	<c path="hxd.fmt.hmd.Library"/>
</t></models>
		<textures><t path="Map">
	<c path="String"/>
	<c path="h3d.mat.Texture"/>
</t></textures>
		<anims><t path="Map">
	<c path="String"/>
	<c path="h3d.anim.Animation"/>
</t></anims>
		<dispose public="1" set="method" line="15"><f a=""><x path="Void"/></f></dispose>
		<loadLibrary public="1" set="method" line="23"><f a="res">
	<c path="hxd.res.Model"/>
	<c path="hxd.fmt.hmd.Library"/>
</f></loadLibrary>
		<loadModel public="1" set="method" line="43"><f a="res">
	<c path="hxd.res.Model"/>
	<c path="h3d.scene.Object"/>
</f></loadModel>
		<loadTexture public="1" set="method" line="47"><f a="model:texturePath">
	<c path="hxd.res.Model"/>
	<c path="String"/>
	<c path="h3d.mat.Texture"/>
</f></loadTexture>
		<loadAnimation public="1" set="method" line="87"><f a="anim:?name">
	<c path="hxd.res.Model"/>
	<c path="String"/>
	<c path="h3d.anim.Animation"/>
</f></loadAnimation>
		<initAnimation set="method" line="98"><f a="anim:name">
	<c path="hxd.res.Model"/>
	<c path="String"/>
	<c path="h3d.anim.Animation"/>
</f></initAnimation>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.prim.Plane2D" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/prim/Plane2D.hx">
		<extends path="h3d.prim.Primitive"/>
		<get public="1" set="method" line="46" static="1"><f a=""><x path="Null"><d/></x></f></get>
		<triCount public="1" set="method" line="8" override="1"><f a=""><x path="Int"/></f></triCount>
		<vertexCount public="1" set="method" line="12" override="1"><f a=""><x path="Int"/></f></vertexCount>
		<alloc public="1" set="method" line="16" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<render public="1" set="method" line="41" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<new set="method" line="5"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="h3d.prim.PlaneFront" params="" file="./h3d/prim/PlanePrim.hx" module="h3d.prim.PlanePrim">
		<X/>
		<Y/>
		<Z/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h3d.prim.PlanePrim" params="" file="./h3d/prim/PlanePrim.hx">
		<extends path="h3d.prim.Primitive"/>
		<width public="1" set="null"><x path="Float"/></width>
		<height public="1" set="null"><x path="Float"/></height>
		<ox public="1" set="null"><x path="Float"/></ox>
		<oy public="1" set="null"><x path="Float"/></oy>
		<u0 public="1" set="null"><x path="Float"/></u0>
		<u1 public="1" set="null"><x path="Float"/></u1>
		<v0 public="1" set="null"><x path="Float"/></v0>
		<v1 public="1" set="null"><x path="Float"/></v1>
		<front public="1" set="null"><e path="h3d.prim.PlaneFront"/></front>
		<buf><x path="hxd.FloatBuffer"/></buf>
		<bounds><c path="h3d.col.Bounds"/></bounds>
		<setOrigin public="1" set="method" line="43"><f a="ox:oy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setOrigin>
		<setSize public="1" set="method" line="53"><f a="width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setSize>
		<setUV public="1" set="method" line="63"><f a="u0:v0:u1:v1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setUV>
		<setSizeUV public="1" set="method" line="75"><f a="width:height:u0:v0:u1:v1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setSizeUV>
		<set public="1" set="method" line="89"><f a="width:height:u0:v0:u1:v1:ox:oy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></set>
		<setFront public="1" set="method" line="102"><f a="front">
	<e path="h3d.prim.PlaneFront"/>
	<x path="Void"/>
</f></setFront>
		<invalidate set="method" line="108"><f a=""><x path="Void"/></f></invalidate>
		<triCount public="1" set="method" line="138" override="1"><f a=""><x path="Int"/></f></triCount>
		<vertexCount public="1" set="method" line="143" override="1"><f a=""><x path="Int"/></f></vertexCount>
		<alloc public="1" set="method" line="148" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<refill set="method" line="155"><f a=""><x path="Void"/></f></refill>
		<render public="1" set="method" line="210" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<getBounds public="1" set="method" line="215" override="1"><f a=""><c path="h3d.col.Bounds"/></f></getBounds>
		<new public="1" set="method" line="29">
			<f a="w:h:?ox:?oy:?u0:?v0:?u1:?v1:?front" v="::0:0:0:0:1:1:Z">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<e path="h3d.prim.PlaneFront"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ front : Z, v1 : 1, u1 : 1, v0 : 0, u0 : 0, oy : 0, ox : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.prim.Polygon" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/prim/Polygon.hx">
		<extends path="h3d.prim.MeshPrimitive"/>
		<points public="1"><c path="Array"><c path="h3d.col.Point"/></c></points>
		<normals public="1"><c path="Array"><c path="h3d.col.Point"/></c></normals>
		<tangents public="1"><c path="Array"><c path="h3d.col.Point"/></c></tangents>
		<uvs public="1"><c path="Array"><c path="h3d.prim.UV"/></c></uvs>
		<idx public="1"><x path="hxd.IndexBuffer"/></idx>
		<colors public="1"><c path="Array"><c path="h3d.col.Point"/></c></colors>
		<scaled expr="1.">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1.</e></m>
				<m n=":s"/>
			</meta>
		</scaled>
		<translatedX expr="0.">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.</e></m>
				<m n=":s"/>
			</meta>
		</translatedX>
		<translatedY expr="0.">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.</e></m>
				<m n=":s"/>
			</meta>
		</translatedY>
		<translatedZ expr="0.">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.</e></m>
				<m n=":s"/>
			</meta>
		</translatedZ>
		<getBounds public="1" set="method" line="22" override="1"><f a=""><c path="h3d.col.Bounds"/></f></getBounds>
		<alloc public="1" set="method" line="29" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<unindex public="1" set="method" line="99"><f a=""><x path="Void"/></f></unindex>
		<translate public="1" set="method" line="134"><f a="dx:dy:dz">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<scale public="1" set="method" line="145"><f a="s">
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<addNormals public="1" set="method" line="154"><f a=""><x path="Void"/></f></addNormals>
		<addTangents public="1" set="method" line="186"><f a=""><x path="Void"/></f></addTangents>
		<addUVs public="1" set="method" line="233"><f a=""><x path="Void"/></f></addUVs>
		<uvScale public="1" set="method" line="239"><f a="su:sv">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uvScale>
		<triCount public="1" set="method" line="251" override="1"><f a=""><x path="Int"/></f></triCount>
		<vertexCount public="1" set="method" line="258" override="1"><f a=""><x path="Int"/></f></vertexCount>
		<getCollider public="1" set="method" line="262" override="1"><f a=""><c path="h3d.col.Collider"/></f></getCollider>
		<render public="1" set="method" line="278" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<new public="1" set="method" line="17"><f a="points:?idx">
	<c path="Array"><c path="h3d.col.Point"/></c>
	<x path="hxd.IndexBuffer"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.prim.RawPrimitive" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/prim/RawPrimitive.hx">
		<extends path="h3d.prim.Primitive"/>
		<vcount><x path="Int"/></vcount>
		<tcount><x path="Int"/></tcount>
		<bounds><c path="h3d.col.Bounds"/></bounds>
		<onContextLost public="1"><f a=""><a>
	<vbuf><x path="hxd.FloatBuffer"/></vbuf>
	<stride><x path="Int"/></stride>
	<quads>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</quads>
	<ibuf>
		<x path="Null"><x path="hxd.IndexBuffer"/></x>
		<meta><m n=":optional"/></meta>
	</ibuf>
</a></f></onContextLost>
		<alloc public="1" set="method" line="17" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<getBounds public="1" set="method" line="34" override="1"><f a=""><c path="h3d.col.Bounds"/></f></getBounds>
		<triCount public="1" set="method" line="39" override="1"><f a=""><x path="Int"/></f></triCount>
		<vertexCount public="1" set="method" line="43" override="1"><f a=""><x path="Int"/></f></vertexCount>
		<new public="1" set="method" line="10">
			<f a="inf:?persist" v=":false">
				<a>
					<vbuf><x path="hxd.FloatBuffer"/></vbuf>
					<stride><x path="Int"/></stride>
					<quads>
						<x path="Null"><x path="Bool"/></x>
						<meta><m n=":optional"/></meta>
					</quads>
					<ibuf>
						<x path="Null"><x path="hxd.IndexBuffer"/></x>
						<meta><m n=":optional"/></meta>
					</ibuf>
					<bounds>
						<x path="Null"><c path="h3d.col.Bounds"/></x>
						<meta><m n=":optional"/></meta>
					</bounds>
				</a>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ persist : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.prim.UV" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/prim/UV.hx">
		<u public="1"><x path="Float"/></u>
		<v public="1"><x path="Float"/></v>
		<clone public="1" set="method" line="13"><f a=""><c path="h3d.prim.UV"/></f></clone>
		<toString set="method" line="17"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="8"><f a="u:v">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Object" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Object.hx">
		<implements path="hxd.impl._Serializable.NoSerializeSupport"/>
		<ROT2RAD get="inline" set="null" expr="-0.017453292519943295769236907684886" line="34" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>-0.017453292519943295769236907684886</e></m></meta>
		</ROT2RAD>
		<flags>
			<x path="h3d.scene.ObjectFlags"/>
			<meta><m n=":s"/></meta>
		</flags>
		<children><c path="Array"><c path="h3d.scene.Object"/></c></children>
		<parent public="1" set="null">
			<c path="h3d.scene.Object"/>
			<haxe_doc>The parent object in the scene tree.</haxe_doc>
		</parent>
		<numChildren public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>How many immediate children this object has.</haxe_doc>
		</numChildren>
		<name public="1">
			<x path="Null"><c path="String"/></x>
			<meta><m n=":s"/></meta>
			<haxe_doc>The name of the object, can be used to retrieve an object within a tree by using `getObjectByName` (default null)</haxe_doc>
		</name>
		<x public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>The x position of the object relative to its parent.</haxe_doc>
		</x>
		<y public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>The y position of the object relative to its parent.</haxe_doc>
		</y>
		<z public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>The z position of the object relative to its parent.</haxe_doc>
		</z>
		<scaleX public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>The amount of scaling along the X axis of this object (default 1.0)</haxe_doc>
		</scaleX>
		<scaleY public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>The amount of scaling along the Y axis of this object (default 1.0)</haxe_doc>
		</scaleY>
		<scaleZ public="1" set="accessor">
			<x path="Float"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>The amount of scaling along the Z axis of this object (default 1.0)</haxe_doc>
		</scaleZ>
		<visible public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Is the object and its children are displayed on screen (default true).</haxe_doc>
		</visible>
		<allocated get="accessor" set="accessor"><x path="Bool"/></allocated>
		<follow public="1" set="accessor">
			<c path="h3d.scene.Object"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>Follow a given object or joint as if it was our parent. Ignore defaultTransform when set.</haxe_doc>
		</follow>
		<followPositionOnly public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When follow is set, only follow the position and ignore both scale and rotation.</haxe_doc>
		</followPositionOnly>
		<defaultTransform public="1" set="accessor">
			<c path="h3d.Matrix"/>
			<haxe_doc>This is an additional optional transformation that is performed before other local transformations.
		It is used by the animation system.</haxe_doc>
		</defaultTransform>
		<currentAnimation public="1" set="null">
			<c path="h3d.anim.Animation"/>
			<meta><m n=":s"/></meta>
		</currentAnimation>
		<culled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Inform that the object is not to be displayed and his animation doesn't have to be sync. Unlike visible, this doesn't apply to children unless inheritCulled is set to true.</haxe_doc>
		</culled>
		<alwaysSync public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When an object is not visible or culled, its animation does not get synchronized unless you set alwaysSync=true</haxe_doc>
		</alwaysSync>
		<inheritCulled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When enabled, the culled flag is inherited by children objects.</haxe_doc>
		</inheritCulled>
		<ignoreBounds public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When enabled, the object bounds are ignored when using getBounds()</haxe_doc>
		</ignoreBounds>
		<ignoreCollide public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When enabled, the object is ignored when using getCollider()</haxe_doc>
		</ignoreCollide>
		<allowSerialize public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When enabled, the object can be serialized (default : true)</haxe_doc>
		</allowSerialize>
		<ignoreParentTransform public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When enabled, the object will not follow its parent transform</haxe_doc>
		</ignoreParentTransform>
		<lightCameraCenter public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>When selecting the lights to apply to this object, we will use the camera target as reference
		instead of the object absolute position. This is useful for very large objects so they can get good lighting.</haxe_doc>
		</lightCameraCenter>
		<absPos><c path="h3d.Matrix"/></absPos>
		<invPos><c path="h3d.Matrix"/></invPos>
		<qRot><c path="h3d.Quat"/></qRot>
		<posChanged get="accessor" set="accessor"><x path="Bool"/></posChanged>
		<lastFrame><x path="Int"/></lastFrame>
		<get_visible get="inline" set="null" line="172"><f a=""><x path="Bool"/></f></get_visible>
		<get_allocated get="inline" set="null" line="173"><f a=""><x path="Bool"/></f></get_allocated>
		<get_posChanged get="inline" set="null" line="174"><f a=""><x path="Bool"/></f></get_posChanged>
		<get_culled get="inline" set="null" line="175"><f a=""><x path="Bool"/></f></get_culled>
		<get_followPositionOnly get="inline" set="null" line="176"><f a=""><x path="Bool"/></f></get_followPositionOnly>
		<get_lightCameraCenter get="inline" set="null" line="177"><f a=""><x path="Bool"/></f></get_lightCameraCenter>
		<get_alwaysSync get="inline" set="null" line="178"><f a=""><x path="Bool"/></f></get_alwaysSync>
		<get_inheritCulled get="inline" set="null" line="179"><f a=""><x path="Bool"/></f></get_inheritCulled>
		<get_ignoreBounds get="inline" set="null" line="180"><f a=""><x path="Bool"/></f></get_ignoreBounds>
		<get_ignoreCollide get="inline" set="null" line="181"><f a=""><x path="Bool"/></f></get_ignoreCollide>
		<get_allowSerialize get="inline" set="null" line="182"><f a=""><x path="Bool"/></f></get_allowSerialize>
		<get_ignoreParentTransform get="inline" set="null" line="183"><f a=""><x path="Bool"/></f></get_ignoreParentTransform>
		<set_posChanged get="inline" set="null" line="184"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_posChanged>
		<set_culled get="inline" set="null" line="185"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_culled>
		<set_visible get="inline" set="null" line="186"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<set_allocated get="inline" set="null" line="187"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allocated>
		<set_followPositionOnly get="inline" set="null" line="188"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_followPositionOnly>
		<set_lightCameraCenter get="inline" set="null" line="189"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_lightCameraCenter>
		<set_alwaysSync get="inline" set="null" line="190"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_alwaysSync>
		<set_ignoreBounds get="inline" set="null" line="191"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignoreBounds>
		<set_inheritCulled get="inline" set="null" line="192"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_inheritCulled>
		<set_ignoreCollide get="inline" set="null" line="193"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignoreCollide>
		<set_allowSerialize get="inline" set="null" line="194"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowSerialize>
		<set_ignoreParentTransform get="inline" set="null" line="195"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignoreParentTransform>
		<playAnimation public="1" set="method" line="200">
			<f a="a">
				<c path="h3d.anim.Animation"/>
				<c path="h3d.anim.Animation"/>
			</f>
			<haxe_doc>Create an animation instance bound to the object, set it as currentAnimation and play it.</haxe_doc>
		</playAnimation>
		<switchToAnimation public="1" set="method" line="207">
			<f a="a">
				<c path="h3d.anim.Animation"/>
				<c path="h3d.anim.Animation"/>
			</f>
			<haxe_doc>Change the current animation. This animation should be an instance that was previously created by playAnimation.</haxe_doc>
		</switchToAnimation>
		<stopAnimation public="1" set="method" line="214">
			<f a="?recursive" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ recursive : false }</e></m></meta>
			<haxe_doc>Stop the current animation. If recursive is set to true, all children will also stop their animation</haxe_doc>
		</stopAnimation>
		<applyAnimationTransform public="1" set="method" line="229">
			<f a="?recursive" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ recursive : true }</e></m></meta>
			<haxe_doc>When an object is loaded, its position scale and rotation will always be set to the default values (0 for position/rotation and 1 for scale).
		If it's part of a group/scene or if it's animated, then its position/rotation/scale will be stored into the defaultTransform matrix.
		Calling this function will reset the defaultTransform to null and instead initialize x/y/z/rotation/scale properties.
		This will not change the actual position of the object but allows you to move the object more freely on your own.
		Do not use on an object that is currently being animated, since it will set again defaultTransform and apply twice the transformation.</haxe_doc>
		</applyAnimationTransform>
		<getObjectsCount public="1" set="method" line="249">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Return the total number of children, recursively.</haxe_doc>
		</getObjectsCount>
		<getMaterialByName public="1" set="method" line="259">
			<f a="name">
				<c path="String"/>
				<c path="h3d.mat.Material"/>
			</f>
			<haxe_doc>Search for a material recursively by name, return it or null if not found.</haxe_doc>
		</getMaterialByName>
		<find public="1" params="T" set="method" line="270">
			<f a="f">
				<f a="">
					<c path="h3d.scene.Object"/>
					<x path="Null"><c path="find.T"/></x>
				</f>
				<x path="Null"><c path="find.T"/></x>
			</f>
			<haxe_doc>Find a single object in the tree by calling `f` on each and returning the first not-null value returned, or null if not found.</haxe_doc>
		</find>
		<findAll public="1" params="T" set="method" line="284">
			<f a="f:?arr">
				<f a="">
					<c path="h3d.scene.Object"/>
					<x path="Null"><c path="findAll.T"/></x>
				</f>
				<c path="Array"><c path="findAll.T"/></c>
				<c path="Array"><c path="findAll.T"/></c>
			</f>
			<haxe_doc>Find several objects in the tree by calling `f` on each and returning all the not-null values returned.</haxe_doc>
		</findAll>
		<getMaterials public="1" set="method" line="297">
			<f a="?a">
				<c path="Array"><c path="h3d.mat.Material"/></c>
				<x path="Null"><c path="Array"><c path="h3d.mat.Material"/></c></x>
			</f>
			<haxe_doc>Return all materials in the tree.</haxe_doc>
		</getMaterials>
		<localToGlobal public="1" set="method" line="307">
			<f a="?pt">
				<c path="h3d.Vector"/>
				<x path="Null"><c path="h3d.Vector"/></x>
			</f>
			<haxe_doc>Convert a local position (or [0,0] if pt is null) relative to the object origin into an absolute global position, applying all the inherited transforms.</haxe_doc>
		</localToGlobal>
		<globalToLocal public="1" set="method" line="317">
			<f a="pt">
				<c path="h3d.Vector"/>
				<c path="h3d.Vector"/>
			</f>
			<haxe_doc>Convert an absolute global position into a local position relative to the object origin, applying all the inherited transforms.</haxe_doc>
		</globalToLocal>
		<getInvPos public="1" set="method" line="325">
			<f a=""><c path="h3d.Matrix"/></f>
			<haxe_doc>Returns the updated inverse position matrix. Please note that this is not a copy and should not be modified.</haxe_doc>
		</getInvPos>
		<getBounds final="1" public="1" set="method" line="339">
			<f a="?b">
				<c path="h3d.col.Bounds"/>
				<c path="h3d.col.Bounds"/>
			</f>
			<meta><m n=":final"/></meta>
			<haxe_doc>Return the bounds of this object and all its children, in absolute global coordinates.</haxe_doc>
		</getBounds>
		<getBoundsRec set="method" line="347"><f a="b">
	<c path="h3d.col.Bounds"/>
	<c path="h3d.col.Bounds"/>
</f></getBoundsRec>
		<getMeshes public="1" set="method" line="362">
			<f a="?out">
				<c path="Array"><c path="h3d.scene.Mesh"/></c>
				<x path="Null"><c path="Array"><c path="h3d.scene.Mesh"/></c></x>
			</f>
			<haxe_doc>Return all meshes part of this tree</haxe_doc>
		</getMeshes>
		<getMeshByName public="1" set="method" line="374">
			<f a="name">
				<c path="String"/>
				<c path="h3d.scene.Mesh"/>
			</f>
			<haxe_doc>Search for an mesh recursively by name, return null if not found.</haxe_doc>
		</getMeshByName>
		<getObjectByName public="1" set="method" line="381">
			<f a="name">
				<c path="String"/>
				<c path="h3d.scene.Object"/>
			</f>
			<haxe_doc>Search for an object recursively by name, return null if not found.</haxe_doc>
		</getObjectByName>
		<clone public="1" set="method" line="394">
			<f a="?o">
				<c path="h3d.scene.Object"/>
				<c path="h3d.scene.Object"/>
			</f>
			<haxe_doc>Make a copy of the object and all its children.</haxe_doc>
		</clone>
		<addChild public="1" set="method" line="423">
			<f a="o">
				<c path="h3d.scene.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Add a child object at the end of the children list.</haxe_doc>
		</addChild>
		<addChildAt public="1" set="method" line="430">
			<f a="o:pos">
				<c path="h3d.scene.Object"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Insert a child object at the specified position of the children list.</haxe_doc>
		</addChildAt>
		<iterVisibleMeshes public="1" set="method" line="462">
			<f a="callb">
				<f a="">
					<c path="h3d.scene.Mesh"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Iterate on all mesh that are currently visible and not culled in the tree. Call `callb` for each mesh found.</haxe_doc>
		</iterVisibleMeshes>
		<onParentChanged set="method" line="473"><f a=""><x path="Void"/></f></onParentChanged>
		<onAdd set="method" line="479"><f a=""><x path="Void"/></f></onAdd>
		<onRemove set="method" line="486"><f a=""><x path="Void"/></f></onRemove>
		<removeChild public="1" set="method" line="495">
			<f a="o">
				<c path="h3d.scene.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Remove the given object from our immediate children list if it's part of it.</haxe_doc>
		</removeChild>
		<removeChildren public="1" set="method" line="506">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Remove all children from our immediate children list</haxe_doc>
		</removeChildren>
		<remove public="1" get="inline" set="null" line="515">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Same as parent.removeChild(this), but does nothing if parent is null.
		In order to capture add/removal from scene, you can override onAdd/onRemove/onParentChanged</haxe_doc>
		</remove>
		<getScene public="1" set="method" line="522">
			<f a=""><c path="h3d.scene.Scene"/></f>
			<haxe_doc>Return the Scene this object is part of, or null if not added to a Scene.</haxe_doc>
		</getScene>
		<getAbsPos public="1" set="method" line="531">
			<f a=""><c path="h3d.Matrix"/></f>
			<haxe_doc>Returns the updated absolute position matrix. Please note that this is not a copy so it should not be modified.</haxe_doc>
		</getAbsPos>
		<isMesh public="1" get="inline" set="null" line="539">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Tell if the object is a Mesh.</haxe_doc>
		</isMesh>
		<toMesh public="1" set="method" line="546">
			<f a=""><c path="h3d.scene.Mesh"/></f>
			<haxe_doc>If the object is a Mesh, return the corresponding Mesh. If not, throw an exception.</haxe_doc>
		</toMesh>
		<getCollider final="1" public="1" set="method" line="557">
			<f a=""><c path="h3d.col.Collider"/></f>
			<meta><m n=":final"/></meta>
			<haxe_doc>Build and return the global absolute recursive collider for the object.
		Returns null if no collider was found or if ignoreCollide was set to true.</haxe_doc>
		</getCollider>
		<getGlobalCollider public="1" set="method" line="584">
			<f a=""><c path="h3d.col.Collider"/></f>
			<haxe_doc>Same as getLocalCollider, but returns an absolute collider instead of a local one.</haxe_doc>
		</getGlobalCollider>
		<getLocalCollider public="1" set="method" line="595">
			<f a=""><c path="h3d.col.Collider"/></f>
			<haxe_doc>Build and returns the local relative not-recursive collider for the object, or null if this object does not have a collider.
		Does not check for ignoreCollide.</haxe_doc>
		</getLocalCollider>
		<draw set="method" line="599"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<set_follow set="method" line="602"><f a="v">
	<c path="h3d.scene.Object"/>
	<c path="h3d.scene.Object"/>
</f></set_follow>
		<calcAbsPos set="method" line="607"><f a=""><x path="Void"/></f></calcAbsPos>
		<sync set="method" line="639"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<syncRec set="method" line="642"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></syncRec>
		<syncPos set="method" line="681"><f a=""><x path="Void"/></f></syncPos>
		<emit set="method" line="691"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></emit>
		<emitRec set="method" line="694"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></emitRec>
		<set_x get="inline" set="null" line="713"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y get="inline" set="null" line="719"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_z get="inline" set="null" line="725"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_z>
		<set_scaleX get="inline" set="null" line="731"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
		<set_scaleY get="inline" set="null" line="737"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
		<set_scaleZ get="inline" set="null" line="743"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleZ>
		<set_defaultTransform get="inline" set="null" line="749"><f a="v">
	<c path="h3d.Matrix"/>
	<c path="h3d.Matrix"/>
</f></set_defaultTransform>
		<setPosition public="1" get="inline" set="null" line="758">
			<f a="x:y:z">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the position of the object relative to its parent.</haxe_doc>
		</setPosition>
		<setTransform public="1" set="method" line="768">
			<f a="mat">
				<c path="h3d.Matrix"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the position, scale and rotation of the object relative to its parent based on the specified transform matrix.</haxe_doc>
		</setTransform>
		<rotate public="1" set="method" line="784">
			<f a="rx:ry:rz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Rotate around the current rotation axis by the specified angles (in radian).</haxe_doc>
		</rotate>
		<setRotation public="1" set="method" line="794">
			<f a="rx:ry:rz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the rotation using the specified angles (in radian).</haxe_doc>
		</setRotation>
		<setRotationAxis public="1" set="method" line="802">
			<f a="ax:ay:az:angle">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the rotation using the specified axis and angle of rotation around it (in radian).</haxe_doc>
		</setRotationAxis>
		<setDirection public="1" set="method" line="810">
			<f a="v">
				<c path="h3d.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the rotation using the specified look at direction</haxe_doc>
		</setDirection>
		<getDirection public="1" set="method" line="818">
			<f a=""><c path="h3d.Vector"/></f>
			<haxe_doc>Return the direction in which the object rotation is currently oriented to</haxe_doc>
		</getDirection>
		<getRotationQuat public="1" set="method" line="826">
			<f a=""><c path="h3d.Quat"/></f>
			<haxe_doc>Return the quaternion representing the current object rotation.
		Dot not modify as it's not a copy.</haxe_doc>
		</getRotationQuat>
		<setRotationQuat public="1" set="method" line="834">
			<f a="q">
				<c path="h3d.Quat"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the quaternion representing the current object rotation.
		Dot not modify the value afterwards as no copy is made.</haxe_doc>
		</setRotationQuat>
		<scale public="1" get="inline" set="null" line="842">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scale uniformly the object by the given factor.</haxe_doc>
		</scale>
		<setScale public="1" get="inline" set="null" line="852">
			<f a="v">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the uniform scale for the object.</haxe_doc>
		</setScale>
		<toString public="1" set="method" line="862">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return both class name and object name if any.</haxe_doc>
		</toString>
		<getChildAt public="1" get="inline" set="null" line="869">
			<f a="n">
				<x path="Int"/>
				<c path="h3d.scene.Object"/>
			</f>
			<haxe_doc>Return the `n`th element among our immediate children list, or null if there is no.</haxe_doc>
		</getChildAt>
		<getChildIndex public="1" set="method" line="876">
			<f a="o">
				<c path="h3d.scene.Object"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Return the index of the object `o` within our immediate children list, or `-1` if it is not part of our children list.</haxe_doc>
		</getChildIndex>
		<get_numChildren get="inline" set="null" line="883"><f a=""><x path="Int"/></f></get_numChildren>
		<iterator public="1" get="inline" set="null" line="890">
			<f a=""><c path="hxd.impl.ArrayIterator_h3d_scene_Object"/></f>
			<haxe_doc>Return an iterator over this object immediate children</haxe_doc>
		</iterator>
		<dispose public="1" set="method" line="897">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Free the GPU memory for this object and its children</haxe_doc>
		</dispose>
		<new public="1" set="method" line="159">
			<f a="?parent">
				<c path="h3d.scene.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new empty object, and adds it to the parent object if not null.</haxe_doc>
		</new>
		<haxe_doc>h3d.scene.Object is the base 3D class that all scene tree elements inherit from.
	It can be used to create a virtual container that does not display anything but can contain other objects
	so the various transforms are inherited to its children.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Axes" params="" file="./h3d/scene/Axes.hx">
		<extends path="h3d.scene.Object"/>
		<new public="1" set="method" line="6"><f a="?parent">
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.scene.Mesh" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Mesh.hx">
		<extends path="h3d.scene.Object"/>
		<primitive public="1">
			<c path="h3d.prim.Primitive"/>
			<haxe_doc>The primitive of the mesh: the list of vertexes and indices necessary to display the mesh.</haxe_doc>
		</primitive>
		<material public="1">
			<c path="h3d.mat.Material"/>
			<haxe_doc>The material of the mesh: the properties used to display it (texture, color, shaders, etc.)</haxe_doc>
		</material>
		<getMeshMaterials public="1" set="method" line="36">
			<f a=""><c path="Array"><c path="h3d.mat.Material"/></c></f>
			<haxe_doc>Return all materials for the current object.</haxe_doc>
		</getMeshMaterials>
		<getBoundsRec set="method" line="40" override="1"><f a="b">
	<c path="h3d.col.Bounds"/>
	<c path="h3d.col.Bounds"/>
</f></getBoundsRec>
		<clone public="1" set="method" line="50" override="1"><f a="?o">
	<c path="h3d.scene.Object"/>
	<c path="h3d.scene.Object"/>
</f></clone>
		<getLocalCollider public="1" set="method" line="58" override="1"><f a=""><c path="h3d.col.Collider"/></f></getLocalCollider>
		<draw set="method" line="62" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<emit set="method" line="66" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></emit>
		<getMaterialByName public="1" set="method" line="70" override="1"><f a="name">
	<c path="String"/>
	<c path="h3d.mat.Material"/>
</f></getMaterialByName>
		<getMaterials public="1" set="method" line="76" override="1"><f a="?a">
	<c path="Array"><c path="h3d.mat.Material"/></c>
	<x path="Null"><c path="Array"><c path="h3d.mat.Material"/></c></x>
</f></getMaterials>
		<dispose public="1" set="method" line="82" override="1"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="23">
			<f a="primitive:?material:?parent">
				<c path="h3d.prim.Primitive"/>
				<c path="h3d.mat.Material"/>
				<c path="h3d.scene.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new mesh with given primitive, material and parent object.
		If material is not specified, a new default material is created for the current renderer.</haxe_doc>
		</new>
		<haxe_doc>h3d.scene.Mesh is the base class for all 3D objects displayed on screen.
	Unlike Object base class, all properties of Mesh only apply to the current object and are not inherited by its children.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Graphics" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Graphics.hx">
		<extends path="h3d.scene.Mesh"/>
		<bprim><c path="h3d.prim.BigPrimitive"/></bprim>
		<curX expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</curX>
		<curY expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</curY>
		<curZ expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</curZ>
		<curR expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</curR>
		<curG><x path="Float"/></curG>
		<curB><x path="Float"/></curB>
		<curA><x path="Float"/></curA>
		<lineSize expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</lineSize>
		<lineShader><c path="h3d.shader.LineShader"/></lineShader>
		<tmpPoints><c path="Array"><c path="h3d.scene._Graphics.GPoint"/></c></tmpPoints>
		<is3D public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Setting is3D to true will switch from a screen space line (constant size whatever the distance) to a world space line</haxe_doc>
		</is3D>
		<onRemove set="method" line="58" override="1"><f a=""><x path="Void"/></f></onRemove>
		<set_is3D set="method" line="63"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_is3D>
		<flushLine set="method" line="76"><f a=""><x path="Void"/></f></flushLine>
		<flush set="method" line="185"><f a=""><x path="Void"/></f></flush>
		<sync set="method" line="194" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<draw set="method" line="200" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<clear public="1" set="method" line="206"><f a=""><x path="Void"/></f></clear>
		<lineStyle public="1" set="method" line="211">
			<f a="?size:?color:?alpha" v="0.:0:1.">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1., color : 0, size : 0. }</e></m></meta>
		</lineStyle>
		<setColor public="1" set="method" line="220">
			<f a="color:?alpha" v=":1.">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1. }</e></m></meta>
		</setColor>
		<drawLine public="1" get="inline" set="null" line="227"><f a="p1:p2">
	<c path="h3d.col.Point"/>
	<c path="h3d.col.Point"/>
	<x path="Void"/>
</f></drawLine>
		<moveTo public="1" set="method" line="232"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<addVertex get="inline" set="null" line="243"><f a="x:y:z:r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addVertex>
		<lineTo public="1" set="method" line="247"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<new public="1" set="method" line="42"><f a="?parent">
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Box" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Box.hx">
		<extends path="h3d.scene.Graphics"/>
		<color public="1"><x path="Int"/></color>
		<bounds public="1"><c path="h3d.col.Bounds"/></bounds>
		<prevXMin expr="1e9">
			<x path="Float"/>
			<meta><m n=":value"><e>1e9</e></m></meta>
		</prevXMin>
		<prevYMin expr="1e9">
			<x path="Float"/>
			<meta><m n=":value"><e>1e9</e></m></meta>
		</prevYMin>
		<prevZMin expr="1e9">
			<x path="Float"/>
			<meta><m n=":value"><e>1e9</e></m></meta>
		</prevZMin>
		<prevXMax expr="-1e9">
			<x path="Float"/>
			<meta><m n=":value"><e>-1e9</e></m></meta>
		</prevXMax>
		<prevYMax expr="-1e9">
			<x path="Float"/>
			<meta><m n=":value"><e>-1e9</e></m></meta>
		</prevYMax>
		<prevZMax expr="-1e9">
			<x path="Float"/>
			<meta><m n=":value"><e>-1e9</e></m></meta>
		</prevZMax>
		<getLocalCollider public="1" set="method" line="21" override="1"><f a=""><c path="h3d.col.Collider"/></f></getLocalCollider>
		<sync set="method" line="25" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<new public="1" set="method" line="14">
			<f a="?color:?bounds:?depth:?parent" v="0xFFFF0000::true:">
				<x path="Int"/>
				<c path="h3d.col.Bounds"/>
				<x path="Bool"/>
				<c path="h3d.scene.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ depth : true, color : 0xFFFF0000 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="h3d.scene._DefaultRenderer.SMap" params="T" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/DefaultRenderer.hx" private="1" module="h3d.scene.DefaultRenderer"><t path="Map">
	<c path="String"/>
	<c path="h3d.scene._DefaultRenderer.SMap.T"/>
</t></typedef>
	<class path="h3d.scene.DepthPass" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/DefaultRenderer.hx" module="h3d.scene.DefaultRenderer">
		<extends path="h3d.pass.Default"/>
		<depthMapId><x path="Int"/></depthMapId>
		<enableSky public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</enableSky>
		<getOutputs set="method" line="15" override="1"><f a=""><c path="Array"><e path="hxsl.Output"/></c></f></getOutputs>
		<draw public="1" set="method" line="19" override="1"><f a="passes">
	<c path="h3d.pass.Object"/>
	<c path="h3d.pass.Object"/>
</f></draw>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.NormalPass" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/DefaultRenderer.hx" module="h3d.scene.DefaultRenderer">
		<extends path="h3d.pass.Default"/>
		<normalMapId><x path="Int"/></normalMapId>
		<getOutputs set="method" line="40" override="1"><f a=""><c path="Array"><e path="hxsl.Output"/></c></f></getOutputs>
		<draw public="1" set="method" line="44" override="1"><f a="passes">
	<c path="h3d.pass.Object"/>
	<c path="h3d.pass.Object"/>
</f></draw>
		<new public="1" set="method" line="35"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Renderer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Renderer.hx">
		<extends path="hxd.impl.AnyProps"/>
		<defaultPass><c path="h3d.pass.Base"/></defaultPass>
		<passObjects><t path="h3d.scene._Renderer.SMap"><c path="h3d.scene.PassObjects"/></t></passObjects>
		<allPasses><c path="Array"><c path="h3d.pass.Base"/></c></allPasses>
		<ctx><c path="h3d.scene.RenderContext"/></ctx>
		<hasSetTarget expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hasSetTarget>
		<effects public="1" expr="[]">
			<c path="Array"><c path="hxd.prefab.rfx.RendererFX"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</effects>
		<renderMode public="1" expr="Default">
			<e path="h3d.scene.RenderMode"/>
			<meta><m n=":value"><e>Default</e></m></meta>
		</renderMode>
		<dispose public="1" set="method" line="39"><f a=""><x path="Void"/></f></dispose>
		<getPass public="1" params="T" set="method" line="47"><f a="c">
	<x path="Class"><c path="getPass.T"/></x>
	<c path="getPass.T"/>
</f></getPass>
		<getPassByName public="1" set="method" line="54"><f a="name">
	<c path="String"/>
	<c path="h3d.pass.Base"/>
</f></getPassByName>
		<debugCompileShader public="1" set="method" line="61"><f a="pass">
	<c path="h3d.mat.Pass"/>
	<c path="hxsl.RuntimeShader"/>
</f></debugCompileShader>
		<hasFeature set="method" line="68"><f a="f">
	<e path="h3d.impl.Feature"/>
	<x path="Bool"/>
</f></hasFeature>
		<getDefaultLight params="T" set="method" line="72"><f a="l">
	<c path="getDefaultLight.T"/>
	<c path="getDefaultLight.T"/>
</f></getDefaultLight>
		<getLightSystem set="method" line="76"><f a=""><c path="h3d.scene.LightSystem"/></f></getLightSystem>
		<time set="method" line="80"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></time>
		<depthSort set="method" line="84">
			<f a="passes:?frontToBack" v=":false">
				<c path="h3d.pass.Object"/>
				<x path="Bool"/>
				<c path="h3d.pass.Object"/>
			</f>
			<meta>
				<m n=":value"><e>{ frontToBack : false }</e></m>
				<m n=":access"><e>h3d.scene.Object</e></m>
			</meta>
		</depthSort>
		<clear get="inline" set="null" line="100"><f a="?color:?depth:?stencil">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<allocTarget get="inline" set="null" line="104">
			<f a="name:?depth:?size:?format" v=":true:1.:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Float"/>
				<e path="hxd.PixelFormat"/>
				<c path="h3d.mat.Texture"/>
			</f>
			<meta><m n=":value"><e>{ size : 1., depth : true }</e></m></meta>
		</allocTarget>
		<copy set="method" line="108"><f a="from:to:?blend">
	<c path="h3d.mat.Texture"/>
	<c path="h3d.mat.Texture"/>
	<t path="h3d.mat.BlendMode"/>
	<x path="Void"/>
</f></copy>
		<setTarget set="method" line="112"><f a="tex">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></setTarget>
		<setTargets params="T" set="method" line="118"><f a="textures">
	<c path="Array"><c path="setTargets.T"/></c>
	<x path="Void"/>
</f></setTargets>
		<resetTarget set="method" line="124"><f a=""><x path="Void"/></f></resetTarget>
		<has set="method" line="131"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></has>
		<get set="method" line="135"><f a="name">
	<c path="String"/>
	<c path="h3d.pass.Object"/>
</f></get>
		<getSort set="method" line="142">
			<f a="name:?front2Back" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="h3d.pass.Object"/>
			</f>
			<meta><m n=":value"><e>{ front2Back : false }</e></m></meta>
		</getSort>
		<draw set="method" line="150"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></draw>
		<render set="method" line="154"><f a=""><x path="Void"/></f></render>
		<computeStatic set="method" line="158"><f a=""><x path="Void"/></f></computeStatic>
		<start public="1" set="method" line="162"><f a=""><x path="Void"/></f></start>
		<process public="1" set="method" line="165"><f a="passes">
	<c path="Array"><c path="h3d.scene.PassObjects"/></c>
	<x path="Void"/>
</f></process>
		<new public="1" set="method" line="33"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>hxd.prefab.rfx.RendererFX</e></m>
			<m n=":allow"><e>h3d.pass.Shadows</e></m>
		</meta>
	</class>
	<class path="h3d.scene.DefaultRenderer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/DefaultRenderer.hx">
		<extends path="h3d.scene.Renderer"/>
		<def get="accessor" set="null"><c path="h3d.pass.Base"/></def>
		<depth public="1" expr="new DepthPass()">
			<c path="h3d.pass.Base"/>
			<meta><m n=":value"><e>new DepthPass()</e></m></meta>
		</depth>
		<normal public="1" expr="new NormalPass()">
			<c path="h3d.pass.Base"/>
			<meta><m n=":value"><e>new NormalPass()</e></m></meta>
		</normal>
		<shadow public="1" expr="new h3d.pass.DefaultShadowMap(1024)">
			<c path="h3d.pass.DefaultShadowMap"/>
			<meta><m n=":value"><e>new h3d.pass.DefaultShadowMap(1024)</e></m></meta>
		</shadow>
		<get_def get="inline" set="null" line="69"><f a=""><c path="h3d.pass.Base"/></f></get_def>
		<renderPass set="method" line="72"><f a="p:passes">
	<c path="h3d.pass.Base"/>
	<c path="h3d.pass.Object"/>
	<x path="Void"/>
</f></renderPass>
		<render set="method" line="76" override="1"><f a=""><x path="Void"/></f></render>
		<new public="1" set="method" line="63"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene._Graphics.GPoint" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Graphics.hx" private="1" module="h3d.scene.Graphics">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<r public="1"><x path="Float"/></r>
		<g public="1"><x path="Float"/></g>
		<b public="1"><x path="Float"/></b>
		<a public="1"><x path="Float"/></a>
		<new public="1" set="method" line="12"><f a="x:y:z:r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Interactive" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Interactive.hx">
		<extends path="h3d.scene.Object"/>
		<implements path="hxd.Interactive"/>
		<shape public="1">
			<c path="h3d.col.Collider"/>
			<meta><m n=":s"/></meta>
		</shape>
		<preciseShape public="1">
			<x path="Null"><c path="h3d.col.Collider"/></x>
			<meta><m n=":s"/></meta>
			<haxe_doc>If several interactive conflicts, the preciseShape (if defined) can be used to distinguish between the two.</haxe_doc>
		</preciseShape>
		<priority public="1">
			<x path="Int"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>In case of conflicting shapes, usually the one in front of the camera is prioritized, unless you set an higher priority.</haxe_doc>
		</priority>
		<cursor public="1" set="accessor"><e path="hxd.Cursor"/></cursor>
		<cancelEvents public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":s"/>
			</meta>
			<haxe_doc>Set the default `cancel` mode (see `hxd.Event`), default to false.</haxe_doc>
		</cancelEvents>
		<propagateEvents public="1" expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":s"/>
			</meta>
			<haxe_doc>Set the default `propagate` mode (see `hxd.Event`), default to false.</haxe_doc>
		</propagateEvents>
		<enableRightButton public="1">
			<x path="Bool"/>
			<meta><m n=":s"/></meta>
		</enableRightButton>
		<bestMatch public="1">
			<x path="Bool"/>
			<meta><m n=":s"/></meta>
			<haxe_doc>Is it required to find the best hit point in a complex mesh or any hit possible point will be enough (default = false, faster).</haxe_doc>
		</bestMatch>
		<scene><c path="h3d.scene.Scene"/></scene>
		<mouseDownButton expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</mouseDownButton>
		<hitPoint expr="new h3d.Vector()">
			<c path="h3d.Vector"/>
			<meta>
				<m n=":value"><e>new h3d.Vector()</e></m>
				<m n=":allow"><e>h3d.scene.Scene</e></m>
			</meta>
		</hitPoint>
		<onAdd set="method" line="45" override="1"><f a=""><x path="Void"/></f></onAdd>
		<onRemove set="method" line="51" override="1"><f a=""><x path="Void"/></f></onRemove>
		<preventClick public="1" set="method" line="62">
			<f a=""><x path="Void"/></f>
			<haxe_doc>This can be called during or after a push event in order to prevent the release from triggering a click.</haxe_doc>
		</preventClick>
		<getInteractiveScene public="1" set="method" line="66">
			<f a=""><c path="hxd.InteractiveScene"/></f>
			<meta><m n=":noCompletion"/></meta>
		</getInteractiveScene>
		<handleEvent public="1" set="method" line="70">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</handleEvent>
		<set_cursor set="method" line="121"><f a="c">
	<e path="hxd.Cursor"/>
	<e path="hxd.Cursor"/>
</f></set_cursor>
		<focus public="1" set="method" line="128"><f a=""><x path="Void"/></f></focus>
		<blur public="1" set="method" line="134"><f a=""><x path="Void"/></f></blur>
		<isOver public="1" set="method" line="138"><f a=""><x path="Bool"/></f></isOver>
		<hasFocus public="1" set="method" line="142"><f a=""><x path="Bool"/></f></hasFocus>
		<onOver public="1" set="dynamic" line="147">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when mouse enters Interactive hitbox area.</haxe_doc>
		</onOver>
		<onOut public="1" set="dynamic" line="151">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when mouse exits Interactive hitbox area.</haxe_doc>
		</onOut>
		<onPush public="1" set="dynamic" line="155">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when Interactive is pressed by user.</haxe_doc>
		</onPush>
		<onRelease public="1" set="dynamic" line="166">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent on multiple conditions.
		A. Always sent if user releases mouse while it is inside Interactive hitbox area.
			This happends regardless if that Interactive was pressed prior or not.
		B. Sent before `onReleaseOutside` if this Interactive was pressed, but released outside it's bounds.
		For first case `event.kind` will be `ERelease`, for second case - `EReleaseOutside`.
		See `onClick` and `onReleaseOutside` functions for separate events that trigger only when user interacts with this particular Interactive.</haxe_doc>
		</onRelease>
		<onReleaseOutside public="1" set="dynamic" line="173">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when user presses Interactive, moves mouse outside and releases it.
		This event fired only on Interactive that user pressed, but released mouse after moving it outside of Interactive hitbox area.</haxe_doc>
		</onReleaseOutside>
		<onClick public="1" set="dynamic" line="180">
			<f a="e">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sent when Interactive is clicked by user.
		This event fired only on Interactive that user pressed and released when mouse is inside Interactive hitbox area.</haxe_doc>
		</onClick>
		<onMove public="1" set="dynamic" line="183"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onMove>
		<onWheel public="1" set="dynamic" line="186"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onWheel>
		<onFocus public="1" set="dynamic" line="189"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onFocus>
		<onFocusLost public="1" set="dynamic" line="192"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onFocusLost>
		<onKeyUp public="1" set="dynamic" line="195"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onKeyUp>
		<onKeyDown public="1" set="dynamic" line="198"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onKeyDown>
		<onCheck public="1" set="dynamic" line="201"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onCheck>
		<onTextInput public="1" set="dynamic" line="204"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onTextInput>
		<new public="1" set="method" line="39"><f a="shape:?parent">
	<c path="h3d.col.Collider"/>
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.scene.Light" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Light.hx">
		<extends path="h3d.scene.Object"/>
		<shader><c path="hxsl.Shader"/></shader>
		<objectDistance><x path="Float"/></objectDistance>
		<next public="1">
			<c path="h3d.scene.Light"/>
			<meta><m n=":noCompletion"/></meta>
		</next>
		<cullingDistance expr="1e10">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1e10</e></m>
				<m n=":s"/>
			</meta>
		</cullingDistance>
		<priority public="1" expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":s"/>
			</meta>
		</priority>
		<color public="1" get="accessor" set="accessor"><c path="h3d.Vector"/></color>
		<enableSpecular public="1" get="accessor" set="accessor"><x path="Bool"/></enableSpecular>
		<get_color set="method" line="20"><f a=""><c path="h3d.Vector"/></f></get_color>
		<set_color set="method" line="24"><f a="v">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
</f></set_color>
		<get_enableSpecular set="method" line="28"><f a=""><x path="Bool"/></f></get_enableSpecular>
		<set_enableSpecular set="method" line="32"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enableSpecular>
		<emit set="method" line="37" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></emit>
		<getShadowDirection set="method" line="41"><f a=""><c path="h3d.Vector"/></f></getShadowDirection>
		<new set="method" line="14"><f a="shader:?parent">
	<c path="hxsl.Shader"/>
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="h3d.scene.LightSystem" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/LightSystem.hx">
		<maxLightsPerObject public="1" expr="6">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</maxLightsPerObject>
		<globals><c path="hxsl.Globals"/></globals>
		<ambientShader><c path="hxsl.Shader"/></ambientShader>
		<lightCount><x path="Int"/></lightCount>
		<ctx><c path="h3d.scene.RenderContext"/></ctx>
		<shadowLight public="1"><c path="h3d.scene.Light"/></shadowLight>
		<ambientLight public="1"><c path="h3d.Vector"/></ambientLight>
		<perPixelLighting public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</perPixelLighting>
		<additiveLighting public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>In the additive lighting model (by default), the lights are added after the ambient.
		In the new non additive ligthning model, the lights will be modulated against the ambient, so an ambient of 1 will reduce lights intensities to 0.</haxe_doc>
		</additiveLighting>
		<get_additiveLighting set="method" line="29"><f a=""><x path="Bool"/></f></get_additiveLighting>
		<set_additiveLighting set="method" line="33"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_additiveLighting>
		<initLights public="1" set="method" line="37"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></initLights>
		<initGlobals public="1" set="method" line="78"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></initGlobals>
		<sortLight set="method" line="83"><f a="l1:l2">
	<c path="h3d.scene.Light"/>
	<c path="h3d.scene.Light"/>
	<x path="Int"/>
</f></sortLight>
		<computeLight public="1" set="method" line="89"><f a="obj:shaders">
	<c path="h3d.scene.Object"/>
	<c path="hxsl.ShaderList"/>
	<c path="hxsl.ShaderList"/>
</f></computeLight>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>h3d.scene.Light</e></m>
			<m n=":access"><e>h3d.scene.Object.absPos</e></m>
			<m n=":access"><e>h3d.scene.RenderContext.lights</e></m>
		</meta>
	</class>
	<class path="h3d.scene.MultiMaterial" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/MultiMaterial.hx">
		<extends path="h3d.scene.Mesh"/>
		<materials public="1"><c path="Array"><c path="h3d.mat.Material"/></c></materials>
		<getMeshMaterials public="1" set="method" line="12" override="1"><f a=""><c path="Array"><c path="h3d.mat.Material"/></c></f></getMeshMaterials>
		<clone public="1" set="method" line="16" override="1"><f a="?o">
	<c path="h3d.scene.Object"/>
	<c path="h3d.scene.MultiMaterial"/>
</f></clone>
		<emit set="method" line="26" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></emit>
		<getMaterialByName public="1" set="method" line="34" override="1"><f a="name">
	<c path="String"/>
	<c path="h3d.mat.Material"/>
</f></getMaterialByName>
		<getMaterials public="1" set="method" line="41" override="1"><f a="?a">
	<c path="Array"><c path="h3d.mat.Material"/></c>
	<x path="Null"><c path="Array"><c path="h3d.mat.Material"/></c></x>
</f></getMaterials>
		<draw set="method" line="51" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="7"><f a="prim:?mats:?parent">
	<c path="h3d.prim.Primitive"/>
	<c path="Array"><x path="Null"><c path="h3d.mat.Material"/></x></c>
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="h3d.scene.ObjectFlags" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Object.hx" module="h3d.scene.Object">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="h3d.scene._Object.ObjectFlags_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Object.hx" private="1" module="h3d.scene.Object">
	<FPosChanged public="1" get="inline" set="null" expr="cast 0x01" line="4" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x01</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FPosChanged>
	<FVisible public="1" get="inline" set="null" expr="cast 0x02" line="5" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x02</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FVisible>
	<FCulled public="1" get="inline" set="null" expr="cast 0x04" line="6" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x04</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FCulled>
	<FFollowPositionOnly public="1" get="inline" set="null" expr="cast 0x08" line="7" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x08</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FFollowPositionOnly>
	<FLightCameraCenter public="1" get="inline" set="null" expr="cast 0x10" line="8" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x10</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FLightCameraCenter>
	<FAllocated public="1" get="inline" set="null" expr="cast 0x20" line="9" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x20</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FAllocated>
	<FAlwaysSync public="1" get="inline" set="null" expr="cast 0x40" line="10" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x40</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FAlwaysSync>
	<FInheritCulled public="1" get="inline" set="null" expr="cast 0x80" line="11" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x80</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FInheritCulled>
	<FNoSerialize public="1" get="inline" set="null" expr="cast 0x100" line="12" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x100</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FNoSerialize>
	<FIgnoreBounds public="1" get="inline" set="null" expr="cast 0x200" line="13" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x200</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FIgnoreBounds>
	<FIgnoreCollide public="1" get="inline" set="null" expr="cast 0x400" line="14" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x400</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FIgnoreCollide>
	<FIgnoreParentTransform public="1" get="inline" set="null" expr="cast 0x800" line="15" static="1">
		<x path="h3d.scene.ObjectFlags"/>
		<meta>
			<m n=":value"><e>cast 0x800</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FIgnoreParentTransform>
	<_new public="1" get="inline" set="null" line="16" static="1">
		<f a=""><x path="h3d.scene.ObjectFlags"/></f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<toInt public="1" get="inline" set="null" line="19" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toInt>
	<has public="1" get="inline" set="null" line="20" static="1">
		<f a="this:f">
			<x path="Int"/>
			<x path="h3d.scene.ObjectFlags"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</has>
	<set public="1" get="inline" set="null" line="21" static="1">
		<f a="this:f:b">
			<x path="Int"/>
			<x path="h3d.scene.ObjectFlags"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="h3d.scene._Object.ObjectFlags_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Object.hx" private="1" module="h3d.scene.Object">
		<FPosChanged public="1" get="inline" set="null" expr="cast 0x01" line="4" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x01</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FPosChanged>
		<FVisible public="1" get="inline" set="null" expr="cast 0x02" line="5" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x02</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FVisible>
		<FCulled public="1" get="inline" set="null" expr="cast 0x04" line="6" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x04</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FCulled>
		<FFollowPositionOnly public="1" get="inline" set="null" expr="cast 0x08" line="7" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x08</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FFollowPositionOnly>
		<FLightCameraCenter public="1" get="inline" set="null" expr="cast 0x10" line="8" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x10</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FLightCameraCenter>
		<FAllocated public="1" get="inline" set="null" expr="cast 0x20" line="9" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x20</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FAllocated>
		<FAlwaysSync public="1" get="inline" set="null" expr="cast 0x40" line="10" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x40</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FAlwaysSync>
		<FInheritCulled public="1" get="inline" set="null" expr="cast 0x80" line="11" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x80</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FInheritCulled>
		<FNoSerialize public="1" get="inline" set="null" expr="cast 0x100" line="12" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x100</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FNoSerialize>
		<FIgnoreBounds public="1" get="inline" set="null" expr="cast 0x200" line="13" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x200</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FIgnoreBounds>
		<FIgnoreCollide public="1" get="inline" set="null" expr="cast 0x400" line="14" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x400</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FIgnoreCollide>
		<FIgnoreParentTransform public="1" get="inline" set="null" expr="cast 0x800" line="15" static="1">
			<x path="h3d.scene.ObjectFlags"/>
			<meta>
				<m n=":value"><e>cast 0x800</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FIgnoreParentTransform>
		<_new public="1" get="inline" set="null" line="16" static="1">
			<f a=""><x path="h3d.scene.ObjectFlags"/></f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<toInt public="1" get="inline" set="null" line="19" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toInt>
		<has public="1" get="inline" set="null" line="20" static="1">
			<f a="this:f">
				<x path="Int"/>
				<x path="h3d.scene.ObjectFlags"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</has>
		<set public="1" get="inline" set="null" line="21" static="1">
			<f a="this:f:b">
				<x path="Int"/>
				<x path="h3d.scene.ObjectFlags"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="h3d.scene._RenderContext.SharedGlobal" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/RenderContext.hx" private="1" module="h3d.scene.RenderContext">
		<gid public="1"><x path="Int"/></gid>
		<value public="1"><d/></value>
		<new public="1" set="method" line="7"><f a="gid:value">
	<x path="Int"/>
	<unknown/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.RenderContext" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/RenderContext.hx">
		<extends path="h3d.impl.RenderContext"/>
		<camera public="1"><c path="h3d.Camera"/></camera>
		<scene public="1"><c path="h3d.scene.Scene"/></scene>
		<drawPass public="1"><t path="h3d.pass._Object.ObjectPass"/></drawPass>
		<pbrLightPass public="1"><c path="h3d.mat.Pass"/></pbrLightPass>
		<computingStatic public="1"><x path="Bool"/></computingStatic>
		<sharedGlobals><c path="Array"><c path="h3d.scene._RenderContext.SharedGlobal"/></c></sharedGlobals>
		<lightSystem public="1"><c path="h3d.scene.LightSystem"/></lightSystem>
		<uploadParams public="1"><f a=""><x path="Void"/></f></uploadParams>
		<extraShaders public="1"><c path="hxsl.ShaderList"/></extraShaders>
		<visibleFlag public="1"><x path="Bool"/></visibleFlag>
		<pool><t path="h3d.pass._Object.ObjectPass"/></pool>
		<firstAlloc><t path="h3d.pass._Object.ObjectPass"/></firstAlloc>
		<cachedShaderList><c path="Array"><c path="hxsl.ShaderList"/></c></cachedShaderList>
		<cachedPos><x path="Int"/></cachedPos>
		<passes><t path="h3d.pass._Object.ObjectPass"/></passes>
		<lights><c path="h3d.scene.Light"/></lights>
		<emit public="1" get="inline" set="null" line="40">
			<f a="mat:obj:?index" v="::0">
				<c path="h3d.mat.Material"/>
				<c path="h3d.scene.Object"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ index : 0 }</e></m>
				<m n=":access"><e>h3d.mat.Pass</e></m>
			</meta>
		</emit>
		<start public="1" set="method" line="48"><f a=""><x path="Void"/></f></start>
		<nextPass public="1" get="inline" set="null" line="61"><f a=""><x path="Void"/></f></nextPass>
		<getGlobal public="1" set="method" line="66"><f a="name">
	<c path="String"/>
	<d/>
</f></getGlobal>
		<setGlobal public="1" get="inline" set="null" line="74"><f a="name:value">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></setGlobal>
		<setGlobalID public="1" set="method" line="78"><f a="gid:value">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></setGlobalID>
		<emitPass public="1" set="method" line="87"><f a="pass:obj">
	<c path="h3d.mat.Pass"/>
	<c path="h3d.scene.Object"/>
	<t path="h3d.pass._Object.ObjectPass"/>
</f></emitPass>
		<allocShaderList public="1" set="method" line="102"><f a="s:?next">
	<c path="hxsl.Shader"/>
	<c path="hxsl.ShaderList"/>
	<c path="hxsl.ShaderList"/>
</f></allocShaderList>
		<emitLight public="1" set="method" line="113"><f a="l">
	<c path="h3d.scene.Light"/>
	<x path="Void"/>
</f></emitLight>
		<done public="1" set="method" line="118"><f a=""><x path="Void"/></f></done>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.PassObjects" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Renderer.hx" module="h3d.scene.Renderer">
		<name public="1"><c path="String"/></name>
		<passes public="1"><c path="h3d.pass.Object"/></passes>
		<rendered public="1"><x path="Bool"/></rendered>
		<new public="1" set="method" line="7"><f a="name:passes">
	<c path="String"/>
	<c path="h3d.pass.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="h3d.scene._Renderer.SMap" params="T" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Renderer.hx" private="1" module="h3d.scene.Renderer"><t path="Map">
	<c path="String"/>
	<c path="h3d.scene._Renderer.SMap.T"/>
</t></typedef>
	<enum path="h3d.scene.RenderMode" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Renderer.hx" module="h3d.scene.Renderer">
		<Default/>
		<LightProbe/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="h3d.scene.S2DPlane" params="" file="./h3d/scene/S2DPlane.hx">
		<extends path="h3d.scene.Mesh"/>
		<root public="1"><c path="h3d.scene.S2DPlaneRoot"/></root>
		<immediateMode public="1"><x path="Bool"/></immediateMode>
		<_dirty><x path="Bool"/></_dirty>
		<_bounds><c path="h2d.col.Bounds"/></_bounds>
		<_autoresize><x path="Bool"/></_autoresize>
		<_texture><c path="h3d.mat.Texture"/></_texture>
		<_ppu><x path="Float"/></_ppu>
		<_plane><c path="h3d.scene._S2DPlane.DrawPrim"/></_plane>
		<filter public="1" get="accessor" set="accessor"><e path="h3d.mat.Filter"/></filter>
		<ppu public="1" get="accessor" set="accessor"><x path="Float"/></ppu>
		<get_ppu get="inline" set="null" line="27"><f a=""><x path="Float"/></f></get_ppu>
		<set_ppu get="inline" set="null" line="28"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_ppu>
		<get_filter get="inline" set="null" line="36"><f a=""><e path="h3d.mat.Filter"/></f></get_filter>
		<set_filter get="inline" set="null" line="37"><f a="v">
	<e path="h3d.mat.Filter"/>
	<e path="h3d.mat.Filter"/>
</f></set_filter>
		<invalidate public="1" get="inline" set="null" line="57"><f a=""><x path="Void"/></f></invalidate>
		<sync set="method" line="59" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<dispose public="1" set="method" line="83" override="1"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="43">
			<f a="parent:?immediateMode:?textureWidth:?textureHeight:?ppu:?autoresize" v=":false:512:512:1:false">
				<c path="h3d.scene.Object"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ autoresize : false, ppu : 1, textureHeight : 512, textureWidth : 512, immediateMode : false }</e></m></meta>
		</new>
	</class>
	<class path="h3d.scene.S2DPlaneRoot" params="" file="./h3d/scene/S2DPlane.hx" module="h3d.scene.S2DPlane">
		<extends path="h2d.Object"/>
		<plane><c path="h3d.scene.S2DPlane"/></plane>
		<contentChanged set="method" line="109" override="1"><f a="s">
	<c path="h2d.Object"/>
	<x path="Void"/>
</f></contentChanged>
		<drawRec set="method" line="114" override="1"><f a="ctx">
	<c path="h2d.RenderContext"/>
	<x path="Void"/>
</f></drawRec>
		<new set="method" line="102"><f a="plane">
	<c path="h3d.scene.S2DPlane"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>h3d.scene.S2DPlane</e></m>
			<m n=":allow"><e>h3d.scene.S2DPlane</e></m>
		</meta>
	</class>
	<class path="h3d.scene._S2DPlane.DrawPrim" params="" file="./h3d/scene/S2DPlane.hx" private="1" module="h3d.scene.S2DPlane">
		<extends path="h3d.prim.Primitive"/>
		<_b><c path="h3d.col.Bounds"/></_b>
		<_w><x path="Float"/></_w>
		<_h><x path="Float"/></_h>
		<_tx><x path="Int"/></_tx>
		<_ty><x path="Int"/></_ty>
		<_buf><x path="hxd.FloatBuffer"/></_buf>
		<ppu public="1"><x path="Float"/></ppu>
		<invalid public="1"><x path="Bool"/></invalid>
		<resize public="1" set="method" line="140"><f a="w:h:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<triCount public="1" set="method" line="163" override="1"><f a=""><x path="Int"/></f></triCount>
		<vertexCount public="1" set="method" line="167" override="1"><f a=""><x path="Int"/></f></vertexCount>
		<alloc public="1" set="method" line="171" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></alloc>
		<refill get="inline" set="null" line="179"><f a=""><x path="Void"/></f></refill>
		<render public="1" set="method" line="230" override="1"><f a="engine">
	<c path="h3d.Engine"/>
	<x path="Void"/>
</f></render>
		<getBounds public="1" set="method" line="235" override="1"><f a=""><c path="h3d.col.Bounds"/></f></getBounds>
		<new public="1" set="method" line="134"><f a="w:h:tx:ty:ppu">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Scene" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Scene.hx">
		<extends path="h3d.scene.Object"/>
		<implements path="hxd.InteractiveScene"/>
		<implements path="h3d.IDrawable"/>
		<camera public="1">
			<c path="h3d.Camera"/>
			<haxe_doc>The scene current camera.</haxe_doc>
		</camera>
		<lightSystem public="1">
			<c path="h3d.scene.LightSystem"/>
			<haxe_doc>The scene light system. Can be customized.</haxe_doc>
		</lightSystem>
		<renderer public="1" set="accessor">
			<c path="h3d.scene.Renderer"/>
			<haxe_doc>The scene renderer. Can be customized.</haxe_doc>
		</renderer>
		<ctx><c path="h3d.scene.RenderContext"/></ctx>
		<interactives><c path="Array"><c path="h3d.scene.Interactive"/></c></interactives>
		<events>
			<c path="hxd.SceneEvents"/>
			<meta><m n=":allow"><e>h3d.scene.Interactive</e></m></meta>
		</events>
		<hitInteractives><c path="Array"><c path="h3d.scene.Interactive"/></c></hitInteractives>
		<eventListeners><c path="Array"><f a="">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></c></eventListeners>
		<window><c path="hxd.Window"/></window>
		<setEvents public="1" set="method" line="53">
			<f a="events">
				<c path="hxd.SceneEvents"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</setEvents>
		<addEventListener public="1" set="method" line="60">
			<f a="f">
				<f a="">
					<c path="hxd.Event"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Add an event listener that will capture all events not caught by an h2d.Interactive</haxe_doc>
		</addEventListener>
		<removeEventListener public="1" set="method" line="67">
			<f a="f">
				<f a="">
					<c path="hxd.Event"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Remove a previously added event listener, return false it was not part of our event listeners.</haxe_doc>
		</removeEventListener>
		<dispatchListeners public="1" set="method" line="77">
			<f a="event">
				<c path="hxd.Event"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</dispatchListeners>
		<set_renderer set="method" line="84"><f a="r">
	<c path="h3d.scene.Renderer"/>
	<c path="h3d.scene.Renderer"/>
</f></set_renderer>
		<sortHitPointByCameraDistance set="method" line="90"><f a="i1:i2">
	<c path="h3d.scene.Interactive"/>
	<c path="h3d.scene.Interactive"/>
	<x path="Int"/>
</f></sortHitPointByCameraDistance>
		<dispatchEvent public="1" set="method" line="99">
			<f a="event:to">
				<c path="hxd.Event"/>
				<c path="hxd.Interactive"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</dispatchEvent>
		<isInteractiveVisible public="1" set="method" line="106">
			<f a="i">
				<c path="hxd.Interactive"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</isInteractiveVisible>
		<handleEvent public="1" set="method" line="116">
			<f a="event:last">
				<c path="hxd.Event"/>
				<c path="hxd.Interactive"/>
				<x path="Null"><c path="h3d.scene.Interactive"/></x>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</handleEvent>
		<clone public="1" set="method" line="231" override="1"><f a="?o">
	<c path="h3d.scene.Object"/>
	<c path="h3d.scene.Scene"/>
</f></clone>
		<dispose public="1" set="method" line="238" override="1"><f a=""><x path="Void"/></f></dispose>
		<addEventTarget set="method" line="249">
			<f a="i">
				<c path="h3d.scene.Interactive"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d</e></m></meta>
		</addEventTarget>
		<removeEventTarget set="method" line="254">
			<f a="i">
				<c path="h3d.scene.Interactive"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d</e></m></meta>
		</removeEventTarget>
		<setElapsedTime public="1" set="method" line="263">
			<f a="elapsedTime">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Before render() or sync() are called, allow to set how much time has elapsed (in seconds) since the last frame in order to update scene animations.
		This is managed automatically by hxd.App</haxe_doc>
		</setElapsedTime>
		<hardwarePass><c path="h3d.pass.HardwarePick"/></hardwarePass>
		<hardwarePick public="1" set="method" line="276">
			<f a="pixelX:pixelY">
				<x path="Float"/>
				<x path="Float"/>
				<c path="h3d.scene.Object"/>
			</f>
			<haxe_doc>Use GPU rendering to pick a model at the given pixel position.
		hardwarePick() will check all scene visible meshes bounds against a ray cast with current camera, then draw them into a 1x1 pixel texture with a specific shader.
		The texture will then be read and the color will identify the object that was rendered at this pixel.
		This is a very precise way of doing scene picking since it performs exactly the same transformations (skinning, custom shaders, etc.) but might be more costly than using CPU colliders.
		Please note that when done during/after rendering, this might clear the screen on some platforms so it should always be done before rendering.</haxe_doc>
		</hardwarePick>
		<syncOnly public="1" set="method" line="329">
			<f a="et">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Synchronize the scene without rendering, updating all objects and animations by the given amount of time, in seconds.</haxe_doc>
		</syncOnly>
		<computeStatic public="1" set="method" line="351">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Perform a rendering with `RendererContext.computingStatic=true`, allowing the computation of static shadow maps, etc.</haxe_doc>
		</computeStatic>
		<render public="1" set="method" line="365">
			<f a="engine">
				<c path="h3d.Engine"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":access"><e>h3d.mat.Pass</e></m>
				<m n=":access"><e>h3d.scene.RenderContext</e></m>
			</meta>
			<haxe_doc>Render the scene on screen. Internal usage only.</haxe_doc>
		</render>
		<serializeScene public="1" set="method" line="440">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Serialize the scene content as HSD bytes (see hxd.fmt.hsd package). Requires -lib hxbit</haxe_doc>
		</serializeScene>
		<new public="1" set="method" line="37">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Create a new scene. A default 3D scene is already available in `hxd.App.s3d`</haxe_doc>
		</new>
		<haxe_doc>h3d.scene.Scene is the root class for a 3D scene. All root objects are added to it before being drawn on screen.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Joint" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Skin.hx" module="h3d.scene.Skin">
		<extends path="h3d.scene.Object"/>
		<skin public="1">
			<c path="h3d.scene.Skin"/>
			<meta><m n=":s"/></meta>
		</skin>
		<index public="1">
			<x path="Int"/>
			<meta><m n=":s"/></meta>
		</index>
		<getObjectByName public="1" set="method" line="16" override="1"><f a="name">
	<c path="String"/>
	<c path="h3d.scene.Joint"/>
</f></getObjectByName>
		<syncPos set="method" line="36" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":access"><e>h3d.scene.Skin</e></m></meta>
		</syncPos>
		<new public="1" set="method" line="7"><f a="skin:j">
	<c path="h3d.scene.Skin"/>
	<c path="h3d.anim.Joint"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.Skin" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/scene/Skin.hx">
		<extends path="h3d.scene.MultiMaterial"/>
		<skinData><c path="h3d.anim.Skin"/></skinData>
		<currentRelPose><c path="Array"><c path="h3d.Matrix"/></c></currentRelPose>
		<currentAbsPose><c path="Array"><c path="h3d.Matrix"/></c></currentAbsPose>
		<currentPalette><c path="Array"><c path="h3d.Matrix"/></c></currentPalette>
		<splitPalette><c path="Array"><c path="Array"><c path="h3d.Matrix"/></c></c></splitPalette>
		<jointsUpdated><x path="Bool"/></jointsUpdated>
		<jointsAbsPosInv><c path="h3d.Matrix"/></jointsAbsPosInv>
		<paletteChanged><x path="Bool"/></paletteChanged>
		<skinShader><c path="h3d.shader.SkinBase"/></skinShader>
		<jointsGraphics><c path="h3d.scene.Graphics"/></jointsGraphics>
		<showJoints public="1"><x path="Bool"/></showJoints>
		<clone public="1" set="method" line="88" override="1"><f a="?o">
	<c path="h3d.scene.Object"/>
	<c path="h3d.scene.Skin"/>
</f></clone>
		<getBoundsRec set="method" line="96" override="1"><f a="b">
	<c path="h3d.col.Bounds"/>
	<c path="h3d.col.Bounds"/>
</f></getBoundsRec>
		<getObjectByName public="1" set="method" line="117" override="1"><f a="name">
	<c path="String"/>
	<c path="h3d.scene.Object"/>
</f></getObjectByName>
		<getLocalCollider public="1" set="method" line="132" override="1"><f a=""><c path="h3d.col.Collider"/></f></getLocalCollider>
		<getGlobalCollider public="1" set="method" line="137" override="1"><f a=""><c path="h3d.col.SkinCollider"/></f></getGlobalCollider>
		<calcAbsPos set="method" line="143" override="1"><f a=""><x path="Void"/></f></calcAbsPos>
		<getSkinData public="1" set="method" line="149"><f a=""><c path="h3d.anim.Skin"/></f></getSkinData>
		<setSkinData public="1" set="method" line="153">
			<f a="s:?shaderInit" v=":true">
				<c path="h3d.anim.Skin"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ shaderInit : true }</e></m></meta>
		</setSkinData>
		<sync set="method" line="199" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></sync>
		<syncJoints set="method" line="206">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noDebug"/></meta>
		</syncJoints>
		<emit set="method" line="226" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></emit>
		<draw set="method" line="262" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></draw>
		<new public="1" set="method" line="82"><f a="s:?mat:?parent">
	<c path="h3d.anim.Skin"/>
	<c path="Array"><x path="Null"><c path="h3d.mat.Material"/></x></c>
	<c path="h3d.scene.Object"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.scene.TileSprite" params="" file="./h3d/scene/TileSprite.hx">
		<extends path="h3d.scene.Mesh"/>
		<faceCamera public="1">
			<x path="Bool"/>
			<haxe_doc>If true, will follow camera orientation to always appear facing X coordinate at camera. (default: true)</haxe_doc>
		</faceCamera>
		<faceZAxis public="1">
			<x path="Bool"/>
			<haxe_doc>If true, will track camera on Z axis, otherwise only X and Y coordinates will be adjusted, and sprite will look forward at all times. (default: true)</haxe_doc>
		</faceZAxis>
		<tile public="1" set="accessor">
			<c path="h2d.Tile"/>
			<haxe_doc>Currently displayed `h2d.Tile`.</haxe_doc>
		</tile>
		<ppu><x path="Float"/></ppu>
		<pixelsPerUnit public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>Pixels per unit value. Affects the sprite size in 3D space. (default: 1)</haxe_doc>
		</pixelsPerUnit>
		<plane><c path="h3d.prim.PlanePrim"/></plane>
		<set_tile set="method" line="48"><f a="t">
	<c path="h2d.Tile"/>
	<c path="h2d.Tile"/>
</f></set_tile>
		<set_pixelsPerUnit set="method" line="62"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pixelsPerUnit>
		<syncRec set="method" line="69" override="1"><f a="ctx">
	<c path="h3d.scene.RenderContext"/>
	<x path="Void"/>
</f></syncRec>
		<new public="1" set="method" line="34">
			<f a="tile:?ppu:?faceCamera:?parent" v=":1:true:">
				<c path="h2d.Tile"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="h3d.scene.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ faceCamera : true, ppu : 1 }</e></m></meta>
		</new>
		<haxe_doc>A classic 2D sprite that can follow camera orientation to always face it.
  Sprite front is X forward.</haxe_doc>
		<meta><m n=":access"><e>h2d.Tile</e></m></meta>
	</class>
	<class path="h3d.shader.AmbientLight" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/AmbientLight.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey23:h3d.shader.AmbientLighty4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-380R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini333y3:maxi399y4:filey77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FAmbientLight.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i339R16i393R17R18gR19jR4:5:2i3jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i339R16i349R17R18gR19r17R20jR21:1:1oR0y10:lightColorR9i-378R5jR10:4:0R11r17ggoR14oR15i352R16i393R17R18gR19jR4:5:2i3r16R20jR21:10:3oR14oR15i352R16i360R17R18gR19jR4:2:0R20jR21:1:1oR0y8:additivey10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-379R5jR10:2:0R11r29ggoR14oR15i363R16i382R17R18gR19r26R20jR21:1:1oR0y12:ambientLightR9i-374y6:parentoR0y6:globalR9i-373R5jR10:0:0R11jR4:13:1ar37oR0y16:perPixelLightingR26ajR27:0:1nhR9i-375R29r38R5r39R11r29ghgR5r39R11r26ggoR14oR15i385R16i393R17R18gR19jR4:5:2i3r16R20jR21:8:2oR14oR15i385R16i389R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:39:0gaoR14oR15i390R16i392R17R18gR19jR4:3:0R20jR21:0:1jy10:hxsl.Const:3:1d0ghggghgR12ahgoR3r3R5r4R7oR0y16:__init__fragmentR9i-381R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i433R16i504R17R18gR19r3R20jR21:4:1aoR14oR15i439R16i498R17R18gR19jR4:5:2i3r16R20jR21:5:3r18oR14oR15i439R16i454R17R18gR19r77R20jR21:1:1oR0y15:lightPixelColorR9i-377R5r22R11r77ggoR14oR15i457R16i498R17R18gR19r26R20jR21:10:3oR14oR15i457R16i465R17R18gR19r29R20jR21:1:1r30goR14oR15i468R16i487R17R18gR19r26R20jR21:1:1r37goR14oR15i490R16i498R17R18gR19jR4:5:2i3r16R20jR21:8:2oR14oR15i490R16i494R17R18gR19r52R20jR21:2:1r53gaoR14oR15i495R16i497R17R18gR19r58R20jR21:0:1jR33:3:1d0ghggghgR12ahgoR3jR4:5:2i3r16R5jR6:3:0R7oR0y9:calcLightR9i-383R5r6R11jR4:14:1aoR3r107R12aoR0R24R11jR4:5:2i3r16ghghgR13oR14oR15i557R16i670R17R18gR19r3R20jR21:4:1aoR14oR15i563R16i664R17R18gR19r3R20jR21:12:1oR14oR15i570R16i664R17R18gR19r114R20jR21:10:3oR14oR15i570R16i578R17R18gR19r29R20jR21:1:1r30goR14oR15i581R16i591R17R18gR19r114R20jR21:1:1oR0R24R9i-382R5r22R11r114ggoR14oR15i594R16i664R17R18gR19jR4:5:2i3r16R20jR21:3:1oR14oR15i595R16i663R17R18gR19r132R20jR21:5:3jR23:0:0oR14oR15i595R16i614R17R18gR19r26R20jR21:1:1r37goR14oR15i617R16i663R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:1:0oR14oR15i617R16i650R17R18gR19jR4:5:2i3r16R20jR21:8:2oR14oR15i617R16i642R17R18gR19jR4:14:1aoR3r145R12aoR0y1:_R11r26goR0y1:bR11r58ghghR20jR21:2:1jR32:22:0gaoR14oR15i617R16i642R17R18gR19r26R20jR21:3:1oR14oR15i618R16i641R17R18gR19r26R20jR21:5:3jR23:3:0oR14oR15i618R16i619R17R18gR19r58R20jR21:0:1jR33:3:1i1goR14oR15i622R16i641R17R18gR19r26R20jR21:1:1r37gggoR14oR15i647R16i649R17R18gR19r58R20jR21:0:1jR33:3:1d0ghgoR14oR15i653R16i663R17R18gR19r114R20jR21:1:1r128gggggghgR12ar128hgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-384R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i694R16i776R17R18gR19r3R20jR21:4:1aoR14oR15i700R16i770R17R18gR19r3R20jR21:10:3oR14oR15i704R16i728R17R18gR19r29R20jR21:6:2jy15:haxe.macro.Unop:2:0oR14oR15i705R16i728R17R18gR19r29R20jR21:1:1r41ggoR14oR15i731R16i770R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:20:1r142oR14oR15i731R16i745R17R18gR19r207R20jR21:9:2oR14oR15i731R16i741R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y10:pixelColorR9i-376R5r22R11r213ggajy14:hxsl.Component:0:0jR42:1:0jR42:2:0hgoR14oR15i749R16i770R17R18gR19r107R20jR21:8:2oR14oR15i749R16i758R17R18gR19r115R20jR21:1:1r109gaoR14oR15i759R16i769R17R18gR19r17R20jR21:1:1r21ghggnghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-385R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i802R16i888R17R18gR19r3R20jR21:4:1aoR14oR15i808R16i882R17R18gR19r3R20jR21:10:3oR14oR15i812R16i835R17R18gR19r29R20jR21:1:1r41goR14oR15i838R16i882R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:20:1r142oR14oR15i838R16i852R17R18gR19r252R20jR21:9:2oR14oR15i838R16i848R17R18gR19r213R20jR21:1:1r214gar217r218r219hgoR14oR15i856R16i882R17R18gR19r107R20jR21:8:2oR14oR15i856R16i865R17R18gR19r115R20jR21:1:1r109gaoR14oR15i866R16i881R17R18gR19r77R20jR21:1:1r80ghggnghgR12ahghy4:varsar38r214r80r21r30r5r67r109r188r237hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey23:h3d.shader.AmbientLighty4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-380R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini333y3:maxi399y4:filey77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FAmbientLight.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i339R16i393R17R18gR19jR4:5:2i3jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i339R16i349R17R18gR19r17R20jR21:1:1oR0y10:lightColorR9i-378R5jR10:4:0R11r17ggoR14oR15i352R16i393R17R18gR19jR4:5:2i3r16R20jR21:10:3oR14oR15i352R16i360R17R18gR19jR4:2:0R20jR21:1:1oR0y8:additivey10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-379R5jR10:2:0R11r29ggoR14oR15i363R16i382R17R18gR19r26R20jR21:1:1oR0y12:ambientLightR9i-374y6:parentoR0y6:globalR9i-373R5jR10:0:0R11jR4:13:1ar37oR0y16:perPixelLightingR26ajR27:0:1nhR9i-375R29r38R5r39R11r29ghgR5r39R11r26ggoR14oR15i385R16i393R17R18gR19jR4:5:2i3r16R20jR21:8:2oR14oR15i385R16i389R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:39:0gaoR14oR15i390R16i392R17R18gR19jR4:3:0R20jR21:0:1jy10:hxsl.Const:3:1d0ghggghgR12ahgoR3r3R5r4R7oR0y16:__init__fragmentR9i-381R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i433R16i504R17R18gR19r3R20jR21:4:1aoR14oR15i439R16i498R17R18gR19jR4:5:2i3r16R20jR21:5:3r18oR14oR15i439R16i454R17R18gR19r77R20jR21:1:1oR0y15:lightPixelColorR9i-377R5r22R11r77ggoR14oR15i457R16i498R17R18gR19r26R20jR21:10:3oR14oR15i457R16i465R17R18gR19r29R20jR21:1:1r30goR14oR15i468R16i487R17R18gR19r26R20jR21:1:1r37goR14oR15i490R16i498R17R18gR19jR4:5:2i3r16R20jR21:8:2oR14oR15i490R16i494R17R18gR19r52R20jR21:2:1r53gaoR14oR15i495R16i497R17R18gR19r58R20jR21:0:1jR33:3:1d0ghggghgR12ahgoR3jR4:5:2i3r16R5jR6:3:0R7oR0y9:calcLightR9i-383R5r6R11jR4:14:1aoR3r107R12aoR0R24R11jR4:5:2i3r16ghghgR13oR14oR15i557R16i670R17R18gR19r3R20jR21:4:1aoR14oR15i563R16i664R17R18gR19r3R20jR21:12:1oR14oR15i570R16i664R17R18gR19r114R20jR21:10:3oR14oR15i570R16i578R17R18gR19r29R20jR21:1:1r30goR14oR15i581R16i591R17R18gR19r114R20jR21:1:1oR0R24R9i-382R5r22R11r114ggoR14oR15i594R16i664R17R18gR19jR4:5:2i3r16R20jR21:3:1oR14oR15i595R16i663R17R18gR19r132R20jR21:5:3jR23:0:0oR14oR15i595R16i614R17R18gR19r26R20jR21:1:1r37goR14oR15i617R16i663R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:1:0oR14oR15i617R16i650R17R18gR19jR4:5:2i3r16R20jR21:8:2oR14oR15i617R16i642R17R18gR19jR4:14:1aoR3r145R12aoR0y1:_R11r26goR0y1:bR11r58ghghR20jR21:2:1jR32:22:0gaoR14oR15i617R16i642R17R18gR19r26R20jR21:3:1oR14oR15i618R16i641R17R18gR19r26R20jR21:5:3jR23:3:0oR14oR15i618R16i619R17R18gR19r58R20jR21:0:1jR33:3:1i1goR14oR15i622R16i641R17R18gR19r26R20jR21:1:1r37gggoR14oR15i647R16i649R17R18gR19r58R20jR21:0:1jR33:3:1d0ghgoR14oR15i653R16i663R17R18gR19r114R20jR21:1:1r128gggggghgR12ar128hgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-384R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i694R16i776R17R18gR19r3R20jR21:4:1aoR14oR15i700R16i770R17R18gR19r3R20jR21:10:3oR14oR15i704R16i728R17R18gR19r29R20jR21:6:2jy15:haxe.macro.Unop:2:0oR14oR15i705R16i728R17R18gR19r29R20jR21:1:1r41ggoR14oR15i731R16i770R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:20:1r142oR14oR15i731R16i745R17R18gR19r207R20jR21:9:2oR14oR15i731R16i741R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y10:pixelColorR9i-376R5r22R11r213ggajy14:hxsl.Component:0:0jR42:1:0jR42:2:0hgoR14oR15i749R16i770R17R18gR19r107R20jR21:8:2oR14oR15i749R16i758R17R18gR19r115R20jR21:1:1r109gaoR14oR15i759R16i769R17R18gR19r17R20jR21:1:1r21ghggnghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-385R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i802R16i888R17R18gR19r3R20jR21:4:1aoR14oR15i808R16i882R17R18gR19r3R20jR21:10:3oR14oR15i812R16i835R17R18gR19r29R20jR21:1:1r41goR14oR15i838R16i882R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:20:1r142oR14oR15i838R16i852R17R18gR19r252R20jR21:9:2oR14oR15i838R16i848R17R18gR19r213R20jR21:1:1r214gar217r218r219hgoR14oR15i856R16i882R17R18gR19r107R20jR21:8:2oR14oR15i856R16i865R17R18gR19r115R20jR21:1:1r109gaoR14oR15i866R16i881R17R18gR19r77R20jR21:1:1r80ghggnghgR12ahghy4:varsar38r214r80r21r30r5r67r109r188r237hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<additive public="1" get="accessor" set="accessor"><x path="Bool"/></additive>
		<additive__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</additive__>
		<get_additive get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_additive>
		<set_additive get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_additive>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@global var global:{ var ambientLight : Vec3; @const};
	var pixelColor:Vec4;
	var lightPixelColor:Vec3;
	var lightColor:Vec3;
	@const var additive:Bool;
	function __init__() {
		lightColor = additive ? global.ambientLight : vec3(0.);
	};
	function __init__fragment() {
		lightPixelColor = additive ? global.ambientLight : vec3(0.);
	};
	function calcLight(lightColor:Vec3):Vec3 {
		return additive ? lightColor : (global.ambientLight + (1 - global.ambientLight).max(0.) * lightColor);
	};
	function vertex() {
		if (!global.perPixelLighting) pixelColor.rgb *= calcLight(lightColor);
	};
	function fragment() {
		if (global.perPixelLighting) pixelColor.rgb *= calcLight(lightPixelColor);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.Base2d" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Base2d.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey17:h3d.shader.Base2dy4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-63R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini963y3:maxi1507y4:filey71:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FBase2d.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i969R16i1017R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i969R16i983R17R18gR19r17R20jR21:1:1oR0y14:spritePositionR9i-45R5jR10:4:0R11r17ggoR14oR15i986R16i1017R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i986R16i990R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i991R16i1005R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y8:positionR9i-36y6:parentoR0y5:inputR9i-35R5jR10:1:0R11jR4:13:1ar37oR0y2:uvR9i-37R27r38R5r39R11jR4:5:2i2r16goR0y5:colorR9i-38R27r38R5r39R11jR4:5:2i4r16ghgR5r39R11r36ggoR14oR15i1007R16i1013R17R18gR19jR4:3:0R20jR21:1:1oR0y6:zValueR9i-43R5jR10:2:0R11r49ggoR14oR15i1015R16i1016R17R18gR19r49R20jR21:0:1jy10:hxsl.Const:3:1i1ghggoR14oR15i1023R16i1285R17R18gR19r3R20jR21:10:3oR14oR15i1027R16i1037R17R18gR19jR4:2:0R20jR21:1:1oR0y10:isRelativey10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-50R5r51R11r63ggoR14oR15i1040R16i1241R17R18gR19r3R20jR21:4:1aoR14oR15i1047R16i1114R17R18gR19r49R20jR21:5:3r18oR14oR15i1047R16i1065R17R18gR19r49R20jR21:9:2oR14oR15i1047R16i1063R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y16:absolutePositionR9i-46R5r22R11r77ggajy14:hxsl.Component:0:0hgoR14oR15i1068R16i1114R17R18gR19r49R20jR21:8:2oR14oR15i1068R16i1093R17R18gR19jR4:14:1aoR3r49R12aoR0y1:_R11jR4:5:2i3r16goR0y1:bR11jR4:5:2i3r16ghghR20jR21:2:1jR25:29:0gaoR14oR15i1068R16i1093R17R18gR19r91R20jR21:8:2oR14oR15i1068R16i1072R17R18gR19jR4:14:1ahR20jR21:2:1jR25:39:0gaoR14oR15i1073R16i1090R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1073R16i1087R17R18gR19r17R20jR21:1:1r21gar81jR37:1:0hgoR14oR15i1091R16i1092R17R18gR19r49R20jR21:0:1jR32:3:1i1ghgoR14oR15i1098R16i1113R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y15:absoluteMatrixAR9i-52R5r51R11r123gghggoR14oR15i1121R16i1188R17R18gR19r49R20jR21:5:3r18oR14oR15i1121R16i1139R17R18gR19r49R20jR21:9:2oR14oR15i1121R16i1137R17R18gR19r77R20jR21:1:1r78gar114hgoR14oR15i1142R16i1188R17R18gR19r49R20jR21:8:2oR14oR15i1142R16i1167R17R18gR19jR4:14:1aoR3r49R12aoR0R38R11jR4:5:2i3r16gr92hghR20jR21:2:1r95gaoR14oR15i1142R16i1167R17R18gR19r145R20jR21:8:2oR14oR15i1142R16i1146R17R18gR19r103R20jR21:2:1r104gaoR14oR15i1147R16i1164R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1147R16i1161R17R18gR19r17R20jR21:1:1r21gar81r114hgoR14oR15i1165R16i1166R17R18gR19r49R20jR21:0:1jR32:3:1i1ghgoR14oR15i1172R16i1187R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y15:absoluteMatrixBR9i-53R5r51R11r170gghggoR14oR15i1195R16i1234R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i1195R16i1214R17R18gR19r177R20jR21:9:2oR14oR15i1195R16i1211R17R18gR19r77R20jR21:1:1r78gajR37:2:0jR37:3:0hgoR14oR15i1217R16i1234R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1217R16i1231R17R18gR19r17R20jR21:1:1r21gar184r185hgghgoR14oR15i1252R16i1285R17R18gR19r77R20jR21:5:3r18oR14oR15i1252R16i1268R17R18gR19r77R20jR21:1:1r78goR14oR15i1271R16i1285R17R18gR19r17R20jR21:1:1r21gggoR14oR15i1291R16i1358R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i1291R16i1303R17R18gR19r209R20jR21:1:1oR0y12:calculatedUVR9i-49R5jR10:3:0R11r209ggoR14oR15i1306R16i1358R17R18gR19jR4:5:2i2r16R20jR21:10:3oR14oR15i1306R16i1314R17R18gR19r63R20jR21:1:1oR0y8:hasUVPosR34ajR35:0:1nhR9i-56R5r51R11r63ggoR14oR15i1317R16i1347R17R18gR19r217R20jR21:5:3jR23:0:0oR14oR15i1317R16i1336R17R18gR19jR4:5:2i2r16R20jR21:5:3jR23:1:0oR14oR15i1317R16i1325R17R18gR19r42R20jR21:1:1r41goR14oR15i1328R16i1336R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1328R16i1333R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y5:uvPosR9i-57R5r51R11r239ggar184r185hggoR14oR15i1339R16i1347R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1339R16i1344R17R18gR19r239R20jR21:1:1r240gar81r114hggoR14oR15i1350R16i1358R17R18gR19r42R20jR21:1:1r41gggoR14oR15i1364R16i1423R17R18gR19jR4:5:2i4r16R20jR21:5:3r18oR14oR15i1364R16i1374R17R18gR19r261R20jR21:1:1oR0y10:pixelColorR9i-47R5r22R11r261ggoR14oR15i1377R16i1423R17R18gR19jR4:5:2i4r16R20jR21:10:3oR14oR15i1377R16i1387R17R18gR19r63R20jR21:1:1r64goR14oR15i1390R16i1409R17R18gR19r268R20jR21:5:3r230oR14oR15i1390R16i1395R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0R30R9i-51R5r51R11r276ggoR14oR15i1398R16i1409R17R18gR19r44R20jR21:1:1r43ggoR14oR15i1412R16i1423R17R18gR19r44R20jR21:1:1r43gggoR14oR15i1429R16i1469R17R18gR19jR4:5:2i4r16R20jR21:5:3r18oR14oR15i1429R16i1441R17R18gR19r290R20jR21:1:1oR0y12:textureColorR9i-48R5r22R11r290ggoR14oR15i1444R16i1469R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i1444R16i1451R17R18gR19jR4:14:1aoR3r297R12aoR0R38R11jR4:10:0goR0R29R11jR4:5:2i2r16ghghR20jR21:2:1jR25:33:0gaoR14oR15i1444R16i1451R17R18gR19r304R20jR21:1:1oR0y7:textureR9i-44R5r51R11r304ggoR14oR15i1456R16i1468R17R18gR19r209R20jR21:1:1r212ghggoR14oR15i1475R16i1501R17R18gR19r261R20jR21:5:3jR23:20:1r230oR14oR15i1475R16i1485R17R18gR19r261R20jR21:1:1r264goR14oR15i1489R16i1501R17R18gR19r290R20jR21:1:1r293gghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-64R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i1531R16i2043R17R18gR19r3R20jR21:4:1aoR14oR15i1596R16i1635R17R18gR19r3R20jR21:7:2oR0y3:tmpR9i-66R5r22R11jR4:5:2i3r16goR14oR15i1606R16i1634R17R18gR19r345R20jR21:8:2oR14oR15i1606R16i1610R17R18gR19r103R20jR21:2:1r104gaoR14oR15i1611R16i1630R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1611R16i1627R17R18gR19r77R20jR21:1:1r78gar81r114hgoR14oR15i1632R16i1633R17R18gR19r49R20jR21:0:1jR32:3:1i1ghggoR14oR15i1640R16i1751R17R18gR19jR4:5:2i4r16R20jR21:5:3r18oR14oR15i1640R16i1654R17R18gR19r368R20jR21:1:1oR0y14:outputPositionR9i-62R5r22R11r368ggoR14oR15i1657R16i1751R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i1657R16i1661R17R18gR19r30R20jR21:2:1r31gaoR14oR15i1668R16i1690R17R18gR19r49R20jR21:8:2oR14oR15i1668R16i1671R17R18gR19jR4:14:1aoR3r49R12aoR0R38R11r345gr92hghR20jR21:2:1r95gaoR14oR15i1668R16i1671R17R18gR19r345R20jR21:1:1r344goR14oR15i1676R16i1689R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y13:filterMatrixAR9i-54R5r51R11r396gghgoR14oR15i1697R16i1719R17R18gR19r49R20jR21:8:2oR14oR15i1697R16i1700R17R18gR19jR4:14:1aoR3r49R12aoR0R38R11r345gr92hghR20jR21:2:1r95gaoR14oR15i1697R16i1700R17R18gR19r345R20jR21:1:1r344goR14oR15i1705R16i1718R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y13:filterMatrixBR9i-55R5r51R11r416gghgoR14oR15i1726R16i1745R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1726R16i1742R17R18gR19r77R20jR21:1:1r78gar184r185hghggoR14oR15i1786R16i1853R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i1786R16i1803R17R18gR19r432R20jR21:9:2oR14oR15i1786R16i1800R17R18gR19r368R20jR21:1:1r371gar81r114hgoR14oR15i1806R16i1853R17R18gR19jR4:5:2i2r16R20jR21:5:3r230oR14oR15i1806R16i1839R17R18gR19jR4:5:2i2r16R20jR21:3:1oR14oR15i1807R16i1838R17R18gR19r445R20jR21:5:3r226oR14oR15i1807R16i1824R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1807R16i1821R17R18gR19r368R20jR21:1:1r371gar81r114hgoR14oR15i1827R16i1838R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1827R16i1835R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y8:viewportR9i-61R5r51R11r461ggar81r114hgggoR14oR15i1842R16i1853R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1842R16i1850R17R18gR19r461R20jR21:1:1r462gar184r185hgggoR14oR15i1945R16i1999R17R18gR19r3R20jR21:10:3oR14oR15i1949R16i1959R17R18gR19r63R20jR21:1:1oR0y10:pixelAlignR34ajR35:0:1nhR9i-59R5r51R11r63ggoR14oR15i1962R16i1999R17R18gR19jR4:5:2i2r16R20jR21:5:3jR23:20:1jR23:3:0oR14oR15i1962R16i1979R17R18gR19r488R20jR21:9:2oR14oR15i1962R16i1976R17R18gR19r368R20jR21:1:1r371gar81r114hgoR14oR15i1983R16i1999R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y16:halfPixelInverseR9i-60R5r51R11r500gggngoR14oR15i2005R16i2037R17R18gR19jR4:5:2i4r16R20jR21:5:3r18oR14oR15i2005R16i2020R17R18gR19r507R20jR21:1:1oR0R26R9i-40R27oR0y6:outputR9i-39R5r22R11jR4:13:1ar510oR0R30R9i-41R27r511R5r22R11jR4:5:2i4r16ghgR5r22R11r507ggoR14oR15i2023R16i2037R17R18gR19r368R20jR21:1:1r371gghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-65R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i2069R16i2159R17R18gR19r3R20jR21:4:1aoR14oR15i2075R16i2122R17R18gR19r3R20jR21:10:3oR14oR15i2079R16i2112R17R18gR19r63R20jR21:5:3jR23:14:0oR14oR15i2079R16i2088R17R18gR19r63R20jR21:1:1oR0y9:killAlphaR34ajR35:0:1nhR9i-58R5r51R11r63ggoR14oR15i2092R16i2112R17R18gR19r63R20jR21:5:3jR23:9:0oR14oR15i2092R16i2104R17R18gR19r49R20jR21:9:2oR14oR15i2092R16i2102R17R18gR19r261R20jR21:1:1r264gar185hgoR14oR15i2107R16i2112R17R18gR19r49R20jR21:0:1jR32:3:1d0.001gggoR14oR15i2115R16i2122R17R18gR19r3R20jR21:11:0gngoR14oR15i2128R16i2153R17R18gR19r514R20jR21:5:3r18oR14oR15i2128R16i2140R17R18gR19r514R20jR21:1:1r513goR14oR15i2143R16i2153R17R18gR19r261R20jR21:1:1r264gghgR12ahghy4:varsar38r511oR0y4:timeR9i-42R5jR10:0:0R11r49gr50r313r21r78r264r293r212r64r277r124r171r397r417r220r240r540r482r501r462r371r5r334r525hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey17:h3d.shader.Base2dy4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-63R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini963y3:maxi1507y4:filey71:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FBase2d.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i969R16i1017R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i969R16i983R17R18gR19r17R20jR21:1:1oR0y14:spritePositionR9i-45R5jR10:4:0R11r17ggoR14oR15i986R16i1017R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i986R16i990R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i991R16i1005R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y8:positionR9i-36y6:parentoR0y5:inputR9i-35R5jR10:1:0R11jR4:13:1ar37oR0y2:uvR9i-37R27r38R5r39R11jR4:5:2i2r16goR0y5:colorR9i-38R27r38R5r39R11jR4:5:2i4r16ghgR5r39R11r36ggoR14oR15i1007R16i1013R17R18gR19jR4:3:0R20jR21:1:1oR0y6:zValueR9i-43R5jR10:2:0R11r49ggoR14oR15i1015R16i1016R17R18gR19r49R20jR21:0:1jy10:hxsl.Const:3:1i1ghggoR14oR15i1023R16i1285R17R18gR19r3R20jR21:10:3oR14oR15i1027R16i1037R17R18gR19jR4:2:0R20jR21:1:1oR0y10:isRelativey10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-50R5r51R11r63ggoR14oR15i1040R16i1241R17R18gR19r3R20jR21:4:1aoR14oR15i1047R16i1114R17R18gR19r49R20jR21:5:3r18oR14oR15i1047R16i1065R17R18gR19r49R20jR21:9:2oR14oR15i1047R16i1063R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y16:absolutePositionR9i-46R5r22R11r77ggajy14:hxsl.Component:0:0hgoR14oR15i1068R16i1114R17R18gR19r49R20jR21:8:2oR14oR15i1068R16i1093R17R18gR19jR4:14:1aoR3r49R12aoR0y1:_R11jR4:5:2i3r16goR0y1:bR11jR4:5:2i3r16ghghR20jR21:2:1jR25:29:0gaoR14oR15i1068R16i1093R17R18gR19r91R20jR21:8:2oR14oR15i1068R16i1072R17R18gR19jR4:14:1ahR20jR21:2:1jR25:39:0gaoR14oR15i1073R16i1090R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1073R16i1087R17R18gR19r17R20jR21:1:1r21gar81jR37:1:0hgoR14oR15i1091R16i1092R17R18gR19r49R20jR21:0:1jR32:3:1i1ghgoR14oR15i1098R16i1113R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y15:absoluteMatrixAR9i-52R5r51R11r123gghggoR14oR15i1121R16i1188R17R18gR19r49R20jR21:5:3r18oR14oR15i1121R16i1139R17R18gR19r49R20jR21:9:2oR14oR15i1121R16i1137R17R18gR19r77R20jR21:1:1r78gar114hgoR14oR15i1142R16i1188R17R18gR19r49R20jR21:8:2oR14oR15i1142R16i1167R17R18gR19jR4:14:1aoR3r49R12aoR0R38R11jR4:5:2i3r16gr92hghR20jR21:2:1r95gaoR14oR15i1142R16i1167R17R18gR19r145R20jR21:8:2oR14oR15i1142R16i1146R17R18gR19r103R20jR21:2:1r104gaoR14oR15i1147R16i1164R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1147R16i1161R17R18gR19r17R20jR21:1:1r21gar81r114hgoR14oR15i1165R16i1166R17R18gR19r49R20jR21:0:1jR32:3:1i1ghgoR14oR15i1172R16i1187R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y15:absoluteMatrixBR9i-53R5r51R11r170gghggoR14oR15i1195R16i1234R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i1195R16i1214R17R18gR19r177R20jR21:9:2oR14oR15i1195R16i1211R17R18gR19r77R20jR21:1:1r78gajR37:2:0jR37:3:0hgoR14oR15i1217R16i1234R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1217R16i1231R17R18gR19r17R20jR21:1:1r21gar184r185hgghgoR14oR15i1252R16i1285R17R18gR19r77R20jR21:5:3r18oR14oR15i1252R16i1268R17R18gR19r77R20jR21:1:1r78goR14oR15i1271R16i1285R17R18gR19r17R20jR21:1:1r21gggoR14oR15i1291R16i1358R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i1291R16i1303R17R18gR19r209R20jR21:1:1oR0y12:calculatedUVR9i-49R5jR10:3:0R11r209ggoR14oR15i1306R16i1358R17R18gR19jR4:5:2i2r16R20jR21:10:3oR14oR15i1306R16i1314R17R18gR19r63R20jR21:1:1oR0y8:hasUVPosR34ajR35:0:1nhR9i-56R5r51R11r63ggoR14oR15i1317R16i1347R17R18gR19r217R20jR21:5:3jR23:0:0oR14oR15i1317R16i1336R17R18gR19jR4:5:2i2r16R20jR21:5:3jR23:1:0oR14oR15i1317R16i1325R17R18gR19r42R20jR21:1:1r41goR14oR15i1328R16i1336R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1328R16i1333R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y5:uvPosR9i-57R5r51R11r239ggar184r185hggoR14oR15i1339R16i1347R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1339R16i1344R17R18gR19r239R20jR21:1:1r240gar81r114hggoR14oR15i1350R16i1358R17R18gR19r42R20jR21:1:1r41gggoR14oR15i1364R16i1423R17R18gR19jR4:5:2i4r16R20jR21:5:3r18oR14oR15i1364R16i1374R17R18gR19r261R20jR21:1:1oR0y10:pixelColorR9i-47R5r22R11r261ggoR14oR15i1377R16i1423R17R18gR19jR4:5:2i4r16R20jR21:10:3oR14oR15i1377R16i1387R17R18gR19r63R20jR21:1:1r64goR14oR15i1390R16i1409R17R18gR19r268R20jR21:5:3r230oR14oR15i1390R16i1395R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0R30R9i-51R5r51R11r276ggoR14oR15i1398R16i1409R17R18gR19r44R20jR21:1:1r43ggoR14oR15i1412R16i1423R17R18gR19r44R20jR21:1:1r43gggoR14oR15i1429R16i1469R17R18gR19jR4:5:2i4r16R20jR21:5:3r18oR14oR15i1429R16i1441R17R18gR19r290R20jR21:1:1oR0y12:textureColorR9i-48R5r22R11r290ggoR14oR15i1444R16i1469R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i1444R16i1451R17R18gR19jR4:14:1aoR3r297R12aoR0R38R11jR4:10:0goR0R29R11jR4:5:2i2r16ghghR20jR21:2:1jR25:33:0gaoR14oR15i1444R16i1451R17R18gR19r304R20jR21:1:1oR0y7:textureR9i-44R5r51R11r304ggoR14oR15i1456R16i1468R17R18gR19r209R20jR21:1:1r212ghggoR14oR15i1475R16i1501R17R18gR19r261R20jR21:5:3jR23:20:1r230oR14oR15i1475R16i1485R17R18gR19r261R20jR21:1:1r264goR14oR15i1489R16i1501R17R18gR19r290R20jR21:1:1r293gghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-64R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i1531R16i2043R17R18gR19r3R20jR21:4:1aoR14oR15i1596R16i1635R17R18gR19r3R20jR21:7:2oR0y3:tmpR9i-66R5r22R11jR4:5:2i3r16goR14oR15i1606R16i1634R17R18gR19r345R20jR21:8:2oR14oR15i1606R16i1610R17R18gR19r103R20jR21:2:1r104gaoR14oR15i1611R16i1630R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1611R16i1627R17R18gR19r77R20jR21:1:1r78gar81r114hgoR14oR15i1632R16i1633R17R18gR19r49R20jR21:0:1jR32:3:1i1ghggoR14oR15i1640R16i1751R17R18gR19jR4:5:2i4r16R20jR21:5:3r18oR14oR15i1640R16i1654R17R18gR19r368R20jR21:1:1oR0y14:outputPositionR9i-62R5r22R11r368ggoR14oR15i1657R16i1751R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i1657R16i1661R17R18gR19r30R20jR21:2:1r31gaoR14oR15i1668R16i1690R17R18gR19r49R20jR21:8:2oR14oR15i1668R16i1671R17R18gR19jR4:14:1aoR3r49R12aoR0R38R11r345gr92hghR20jR21:2:1r95gaoR14oR15i1668R16i1671R17R18gR19r345R20jR21:1:1r344goR14oR15i1676R16i1689R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y13:filterMatrixAR9i-54R5r51R11r396gghgoR14oR15i1697R16i1719R17R18gR19r49R20jR21:8:2oR14oR15i1697R16i1700R17R18gR19jR4:14:1aoR3r49R12aoR0R38R11r345gr92hghR20jR21:2:1r95gaoR14oR15i1697R16i1700R17R18gR19r345R20jR21:1:1r344goR14oR15i1705R16i1718R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y13:filterMatrixBR9i-55R5r51R11r416gghgoR14oR15i1726R16i1745R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1726R16i1742R17R18gR19r77R20jR21:1:1r78gar184r185hghggoR14oR15i1786R16i1853R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i1786R16i1803R17R18gR19r432R20jR21:9:2oR14oR15i1786R16i1800R17R18gR19r368R20jR21:1:1r371gar81r114hgoR14oR15i1806R16i1853R17R18gR19jR4:5:2i2r16R20jR21:5:3r230oR14oR15i1806R16i1839R17R18gR19jR4:5:2i2r16R20jR21:3:1oR14oR15i1807R16i1838R17R18gR19r445R20jR21:5:3r226oR14oR15i1807R16i1824R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1807R16i1821R17R18gR19r368R20jR21:1:1r371gar81r114hgoR14oR15i1827R16i1838R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1827R16i1835R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y8:viewportR9i-61R5r51R11r461ggar81r114hgggoR14oR15i1842R16i1853R17R18gR19jR4:5:2i2r16R20jR21:9:2oR14oR15i1842R16i1850R17R18gR19r461R20jR21:1:1r462gar184r185hgggoR14oR15i1945R16i1999R17R18gR19r3R20jR21:10:3oR14oR15i1949R16i1959R17R18gR19r63R20jR21:1:1oR0y10:pixelAlignR34ajR35:0:1nhR9i-59R5r51R11r63ggoR14oR15i1962R16i1999R17R18gR19jR4:5:2i2r16R20jR21:5:3jR23:20:1jR23:3:0oR14oR15i1962R16i1979R17R18gR19r488R20jR21:9:2oR14oR15i1962R16i1976R17R18gR19r368R20jR21:1:1r371gar81r114hgoR14oR15i1983R16i1999R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y16:halfPixelInverseR9i-60R5r51R11r500gggngoR14oR15i2005R16i2037R17R18gR19jR4:5:2i4r16R20jR21:5:3r18oR14oR15i2005R16i2020R17R18gR19r507R20jR21:1:1oR0R26R9i-40R27oR0y6:outputR9i-39R5r22R11jR4:13:1ar510oR0R30R9i-41R27r511R5r22R11jR4:5:2i4r16ghgR5r22R11r507ggoR14oR15i2023R16i2037R17R18gR19r368R20jR21:1:1r371gghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-65R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i2069R16i2159R17R18gR19r3R20jR21:4:1aoR14oR15i2075R16i2122R17R18gR19r3R20jR21:10:3oR14oR15i2079R16i2112R17R18gR19r63R20jR21:5:3jR23:14:0oR14oR15i2079R16i2088R17R18gR19r63R20jR21:1:1oR0y9:killAlphaR34ajR35:0:1nhR9i-58R5r51R11r63ggoR14oR15i2092R16i2112R17R18gR19r63R20jR21:5:3jR23:9:0oR14oR15i2092R16i2104R17R18gR19r49R20jR21:9:2oR14oR15i2092R16i2102R17R18gR19r261R20jR21:1:1r264gar185hgoR14oR15i2107R16i2112R17R18gR19r49R20jR21:0:1jR32:3:1d0.001gggoR14oR15i2115R16i2122R17R18gR19r3R20jR21:11:0gngoR14oR15i2128R16i2153R17R18gR19r514R20jR21:5:3r18oR14oR15i2128R16i2140R17R18gR19r514R20jR21:1:1r513goR14oR15i2143R16i2153R17R18gR19r261R20jR21:1:1r264gghgR12ahghy4:varsar38r511oR0y4:timeR9i-42R5jR10:0:0R11r49gr50r313r21r78r264r293r212r64r277r124r171r397r417r220r240r540r482r501r462r371r5r334r525hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<zValue public="1" get="accessor" set="accessor"><x path="Float"/></zValue>
		<zValue__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</zValue__>
		<get_zValue get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_zValue>
		<set_zValue get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_zValue>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture>
		<texture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<isRelative public="1" get="accessor" set="accessor"><x path="Bool"/></isRelative>
		<isRelative__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</isRelative__>
		<get_isRelative get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isRelative>
		<set_isRelative get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isRelative>
		<color public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></color>
		<color__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</color__>
		<get_color get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_color>
		<set_color get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_color>
		<absoluteMatrixA public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></absoluteMatrixA>
		<absoluteMatrixA__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</absoluteMatrixA__>
		<get_absoluteMatrixA get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_absoluteMatrixA>
		<set_absoluteMatrixA get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_absoluteMatrixA>
		<absoluteMatrixB public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></absoluteMatrixB>
		<absoluteMatrixB__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</absoluteMatrixB__>
		<get_absoluteMatrixB get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_absoluteMatrixB>
		<set_absoluteMatrixB get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_absoluteMatrixB>
		<filterMatrixA public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></filterMatrixA>
		<filterMatrixA__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</filterMatrixA__>
		<get_filterMatrixA get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_filterMatrixA>
		<set_filterMatrixA get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_filterMatrixA>
		<filterMatrixB public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></filterMatrixB>
		<filterMatrixB__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</filterMatrixB__>
		<get_filterMatrixB get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_filterMatrixB>
		<set_filterMatrixB get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_filterMatrixB>
		<hasUVPos public="1" get="accessor" set="accessor"><x path="Bool"/></hasUVPos>
		<hasUVPos__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</hasUVPos__>
		<get_hasUVPos get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_hasUVPos>
		<set_hasUVPos get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_hasUVPos>
		<uvPos public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></uvPos>
		<uvPos__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</uvPos__>
		<get_uvPos get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_uvPos>
		<set_uvPos get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_uvPos>
		<killAlpha public="1" get="accessor" set="accessor"><x path="Bool"/></killAlpha>
		<killAlpha__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</killAlpha__>
		<get_killAlpha get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_killAlpha>
		<set_killAlpha get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_killAlpha>
		<pixelAlign public="1" get="accessor" set="accessor"><x path="Bool"/></pixelAlign>
		<pixelAlign__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</pixelAlign__>
		<get_pixelAlign get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_pixelAlign>
		<set_pixelAlign get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_pixelAlign>
		<halfPixelInverse public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></halfPixelInverse>
		<halfPixelInverse__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</halfPixelInverse__>
		<get_halfPixelInverse get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_halfPixelInverse>
		<set_halfPixelInverse get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_halfPixelInverse>
		<viewport public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></viewport>
		<viewport__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</viewport__>
		<get_viewport get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_viewport>
		<set_viewport get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_viewport>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@input var input:{ var position : Vec2; var uv : Vec2; var color : Vec4};
	var output:{ var position : Vec4; var color : Vec4};
	@global var time:Float;
	@param var zValue:Float;
	@param var texture:Sampler2D;
	var spritePosition:Vec4;
	var absolutePosition:Vec4;
	var pixelColor:Vec4;
	var textureColor:Vec4;
	@var var calculatedUV:Vec2;
	@const var isRelative:Bool;
	@param var color:Vec4;
	@param var absoluteMatrixA:Vec3;
	@param var absoluteMatrixB:Vec3;
	@param var filterMatrixA:Vec3;
	@param var filterMatrixB:Vec3;
	@const var hasUVPos:Bool;
	@param var uvPos:Vec4;
	@const var killAlpha:Bool;
	@const var pixelAlign:Bool;
	@param var halfPixelInverse:Vec2;
	@param var viewport:Vec4;
	var outputPosition:Vec4;
	function __init__() {
		spritePosition = vec4(input.position, zValue, 1);
		if (isRelative) {
			absolutePosition.x = vec3(spritePosition.xy, 1).dot(absoluteMatrixA);
			absolutePosition.y = vec3(spritePosition.xy, 1).dot(absoluteMatrixB);
			absolutePosition.zw = spritePosition.zw;
		} else absolutePosition = spritePosition;
		calculatedUV = hasUVPos ? input.uv * uvPos.zw + uvPos.xy : input.uv;
		pixelColor = isRelative ? color * input.color : input.color;
		textureColor = texture.get(calculatedUV);
		pixelColor *= textureColor;
	};
	function vertex() {
		var tmp = vec3(absolutePosition.xy, 1);
		outputPosition = vec4(tmp.dot(filterMatrixA), tmp.dot(filterMatrixB), absolutePosition.zw);
		outputPosition.xy = (outputPosition.xy + viewport.xy) * viewport.zw;
		if (pixelAlign) outputPosition.xy -= halfPixelInverse;
		output.position = outputPosition;
	};
	function fragment() {
		if (killAlpha && pixelColor.a < 0.001) discard;
		output.color = pixelColor;
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.BaseMesh" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/BaseMesh.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey19:h3d.shader.BaseMeshy4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-215R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini1326y3:maxi1969y4:filey73:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FBaseMesh.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i1332R16i1365R17R18gR19jR4:5:2i3jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i1332R16i1348R17R18gR19r17R20jR21:1:1oR0y16:relativePositionR9i-200R5jR10:4:0R11r17ggoR14oR15i1351R16i1365R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y8:positionR9i-192y6:parentoR0y5:inputR9i-191R5jR10:1:0R11jR4:13:1ar27oR0y6:normalR9i-193R26r28R5r29R11jR4:5:2i3r16ghgR5r29R11r26gggoR14oR15i1371R16i1437R17R18gR19jR4:5:2i3r16R20jR21:5:3r18oR14oR15i1371R16i1390R17R18gR19r38R20jR21:1:1oR0y19:transformedPositionR9i-201R5r22R11r38ggoR14oR15i1393R16i1437R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:1:0oR14oR15i1393R16i1409R17R18gR19r17R20jR21:1:1r21goR14oR15i1412R16i1437R17R18gR19jR4:8:0R20jR21:8:2oR14oR15i1412R16i1428R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:50:0gaoR14oR15i1412R16i1428R17R18gR19jR4:7:0R20jR21:1:1oR0y9:modelViewy10:qualifiersajy17:hxsl.VarQualifier:3:0hR9i-189R26oR0y6:globalR9i-186R5jR10:0:0R11jR4:13:1aoR0y4:timeR9i-187R26r66R5r67R11jR4:3:0goR0y9:pixelSizeR9i-188R26r66R5r67R11jR4:5:2i2r16gr63oR0y16:modelViewInverseR32ar65hR9i-190R26r66R5r67R11r62ghgR5r67R11r62gghgggoR14oR15i1443R16i1509R17R18gR19jR4:5:2i4r16R20jR21:5:3r18oR14oR15i1443R16i1460R17R18gR19r82R20jR21:1:1oR0y17:projectedPositionR9i-204R5r22R11r82ggoR14oR15i1463R16i1509R17R18gR19jR4:5:2i4r16R20jR21:5:3r46oR14oR15i1463R16i1491R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i1463R16i1467R17R18gR19jR4:14:1ahR20jR21:2:1jR30:40:0gaoR14oR15i1468R16i1487R17R18gR19r38R20jR21:1:1r41goR14oR15i1489R16i1490R17R18gR19r70R20jR21:0:1jy10:hxsl.Const:3:1i1ghgoR14oR15i1494R16i1509R17R18gR19r62R20jR21:1:1oR0y8:viewProjR9i-181R26oR0y6:cameraR9i-175R5r67R11jR4:13:1aoR0y4:viewR9i-176R26r111R5r67R11r62goR0y4:projR9i-177R26r111R5r67R11r62goR0R25R9i-178R26r111R5r67R11jR4:5:2i3r16goR0y8:projFlipR9i-179R26r111R5r67R11r70goR0y8:projDiagR9i-180R26r111R5r67R11jR4:5:2i3r16gr110oR0y15:inverseViewProjR9i-182R26r111R5r67R11r62goR0y5:zNearR9i-183R26r111R5r67R11r70goR0y4:zFarR9i-184R26r111R5r67R11r70goR0y3:dirR9i-185R26r111R5jR10:3:0R11jR4:5:2i3r16ghgR5r67R11r62ggggoR14oR15i1515R16i1587R17R18gR19jR4:5:2i3r16R20jR21:5:3r18oR14oR15i1515R16i1532R17R18gR19r132R20jR21:1:1oR0y17:transformedNormalR9i-203R5r22R11r132ggoR14oR15i1535R16i1587R17R18gR19r45R20jR21:8:2oR14oR15i1535R16i1575R17R18gR19jR4:14:1aoR3r45R12aoR0y1:_R11r45ghghR20jR21:2:1jR30:31:0gaoR14oR15i1535R16i1575R17R18gR19r45R20jR21:3:1oR14oR15i1536R16i1574R17R18gR19r45R20jR21:5:3r46oR14oR15i1536R16i1548R17R18gR19r32R20jR21:1:1r31goR14oR15i1551R16i1574R17R18gR19jR4:6:0R20jR21:8:2oR14oR15i1551R16i1567R17R18gR19jR4:14:1ahR20jR21:2:1jR30:48:0gaoR14oR15i1551R16i1567R17R18gR19r62R20jR21:1:1r63ghggghggoR14oR15i1593R16i1657R17R18gR19r125R20jR21:5:3r18oR14oR15i1593R16i1603R17R18gR19r125R20jR21:1:1r123goR14oR15i1606R16i1657R17R18gR19r45R20jR21:8:2oR14oR15i1606R16i1645R17R18gR19jR4:14:1aoR3r45R12aoR0R51R11jR4:5:2i3r16ghghR20jR21:2:1r146gaoR14oR15i1606R16i1645R17R18gR19r187R20jR21:3:1oR14oR15i1607R16i1644R17R18gR19r187R20jR21:5:3jR23:3:0oR14oR15i1607R16i1622R17R18gR19r116R20jR21:1:1r115goR14oR15i1625R16i1644R17R18gR19r38R20jR21:1:1r41ggghggoR14oR15i1663R16i1681R17R18gR19jR4:5:2i4r16R20jR21:5:3r18oR14oR15i1663R16i1673R17R18gR19r208R20jR21:1:1oR0y10:pixelColorR9i-205R5r22R11r208ggoR14oR15i1676R16i1681R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y5:colorR9i-211R5jR10:2:0R11r215gggoR14oR15i1687R16i1712R17R18gR19r70R20jR21:5:3r18oR14oR15i1687R16i1696R17R18gR19r70R20jR21:1:1oR0y9:specPowerR9i-208R5r22R11r70ggoR14oR15i1699R16i1712R17R18gR19r70R20jR21:1:1oR0y13:specularPowerR32ajR33:7:2d0d100hR9i-212R5r217R11r70gggoR14oR15i1718R16i1760R17R18gR19jR4:5:2i3r16R20jR21:5:3r18oR14oR15i1718R16i1727R17R18gR19r235R20jR21:1:1oR0y9:specColorR9i-209R5r22R11r235ggoR14oR15i1730R16i1760R17R18gR19jR4:5:2i3r16R20jR21:5:3r46oR14oR15i1730R16i1743R17R18gR19r242R20jR21:1:1oR0y13:specularColorR9i-214R5r217R11r242ggoR14oR15i1746R16i1760R17R18gR19r70R20jR21:1:1oR0y14:specularAmountR32ajR33:7:2d0d10hR9i-213R5r217R11r70ggggoR14oR15i1766R16i1831R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i1766R16i1774R17R18gR19r257R20jR21:1:1oR0y8:screenUVR9i-207R5r22R11r257ggoR14oR15i1777R16i1831R17R18gR19jR4:5:2i2r16R20jR21:8:2oR14oR15i1777R16i1787R17R18gR19jR4:14:1aoR3r264R12aoR0y9:screenPosR11r264ghghR20jR21:2:1jR30:56:0gaoR14oR15i1788R16i1830R17R18gR19jR4:5:2i2r16R20jR21:5:3jR23:2:0oR14oR15i1788R16i1808R17R18gR19r277R20jR21:9:2oR14oR15i1788R16i1805R17R18gR19r82R20jR21:1:1r85gajy14:hxsl.Component:0:0jR61:1:0hgoR14oR15i1811R16i1830R17R18gR19r70R20jR21:9:2oR14oR15i1811R16i1828R17R18gR19r82R20jR21:1:1r85gajR61:3:0hgghggoR14oR15i1837R16i1886R17R18gR19r70R20jR21:5:3r18oR14oR15i1837R16i1842R17R18gR19r70R20jR21:1:1oR0y5:depthR9i-206R5r22R11r70ggoR14oR15i1845R16i1886R17R18gR19r70R20jR21:5:3r278oR14oR15i1845R16i1864R17R18gR19r70R20jR21:9:2oR14oR15i1845R16i1862R17R18gR19r82R20jR21:1:1r85gajR61:2:0hgoR14oR15i1867R16i1886R17R18gR19r70R20jR21:9:2oR14oR15i1867R16i1884R17R18gR19r82R20jR21:1:1r85gar294hgggoR14oR15i1892R16i1963R17R18gR19r70R20jR21:5:3r18oR14oR15i1892R16i1901R17R18gR19r70R20jR21:1:1oR0y9:worldDistR9i-210R5r22R11r70ggoR14oR15i1904R16i1963R17R18gR19r70R20jR21:5:3r278oR14oR15i1904R16i1949R17R18gR19r70R20jR21:8:2oR14oR15i1904R16i1910R17R18gR19jR4:14:1aoR3r70R12aoR0y5:valueR11r45ghghR20jR21:2:1jR30:27:0gaoR14oR15i1911R16i1948R17R18gR19jR4:5:2i3r16R20jR21:5:3r195oR14oR15i1911R16i1930R17R18gR19r38R20jR21:1:1r41goR14oR15i1933R16i1948R17R18gR19r116R20jR21:1:1r115gghgoR14oR15i1952R16i1963R17R18gR19r70R20jR21:1:1r122ggghgR12ahgoR3r3R5r4R7oR0y16:__init__fragmentR9i-216R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i2003R16i2442R17R18gR19r3R20jR21:4:1aoR14oR15i2009R16i2058R17R18gR19r132R20jR21:5:3r18oR14oR15i2009R16i2026R17R18gR19r132R20jR21:1:1r135goR14oR15i2029R16i2058R17R18gR19r45R20jR21:8:2oR14oR15i2029R16i2046R17R18gR19jR4:14:1aoR3r45R12aoR0R51R11r132ghghR20jR21:2:1r146gaoR14oR15i2029R16i2046R17R18gR19r132R20jR21:1:1r135ghggoR14oR15i2159R16i2224R17R18gR19r257R20jR21:5:3r18oR14oR15i2159R16i2167R17R18gR19r257R20jR21:1:1r260goR14oR15i2170R16i2224R17R18gR19r264R20jR21:8:2oR14oR15i2170R16i2180R17R18gR19r271R20jR21:2:1r272gaoR14oR15i2181R16i2223R17R18gR19jR4:5:2i2r16R20jR21:5:3r278oR14oR15i2181R16i2201R17R18gR19r405R20jR21:9:2oR14oR15i2181R16i2198R17R18gR19r82R20jR21:1:1r85gar285r286hgoR14oR15i2204R16i2223R17R18gR19r70R20jR21:9:2oR14oR15i2204R16i2221R17R18gR19r82R20jR21:1:1r85gar294hgghggoR14oR15i2230R16i2279R17R18gR19r70R20jR21:5:3r18oR14oR15i2230R16i2235R17R18gR19r70R20jR21:1:1r303goR14oR15i2238R16i2279R17R18gR19r70R20jR21:5:3r278oR14oR15i2238R16i2257R17R18gR19r70R20jR21:9:2oR14oR15i2238R16i2255R17R18gR19r82R20jR21:1:1r85gar313hgoR14oR15i2260R16i2279R17R18gR19r70R20jR21:9:2oR14oR15i2260R16i2277R17R18gR19r82R20jR21:1:1r85gar294hgggoR14oR15i2363R16i2388R17R18gR19r70R20jR21:5:3r18oR14oR15i2363R16i2372R17R18gR19r70R20jR21:1:1r224goR14oR15i2375R16i2388R17R18gR19r70R20jR21:1:1r228ggoR14oR15i2394R16i2436R17R18gR19r235R20jR21:5:3r18oR14oR15i2394R16i2403R17R18gR19r235R20jR21:1:1r238goR14oR15i2406R16i2436R17R18gR19r242R20jR21:5:3r46oR14oR15i2406R16i2419R17R18gR19r242R20jR21:1:1r245goR14oR15i2422R16i2436R17R18gR19r70R20jR21:1:1r249ggghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-217R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i2466R16i2598R17R18gR19r3R20jR21:4:1aoR14oR15i2472R16i2540R17R18gR19jR4:5:2i4r16R20jR21:5:3r18oR14oR15i2472R16i2487R17R18gR19r484R20jR21:1:1oR0R25R9i-195R26oR0y6:outputR9i-194R5r22R11jR4:13:1ar487oR0R53R9i-196R26r488R5r22R11jR4:5:2i4r16goR0R62R9i-197R26r488R5r22R11r70goR0R28R9i-198R26r488R5r22R11jR4:5:2i3r16goR0R63R9i-199R26r488R5r22R11r70ghgR5r22R11r484ggoR14oR15i2490R16i2540R17R18gR19jR4:5:2i4r16R20jR21:5:3r46oR14oR15i2490R16i2507R17R18gR19r82R20jR21:1:1r85goR14oR15i2510R16i2540R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i2510R16i2514R17R18gR19r96R20jR21:2:1r97gaoR14oR15i2515R16i2516R17R18gR19r70R20jR21:0:1jR39:3:1i1goR14oR15i2518R16i2533R17R18gR19r70R20jR21:1:1r117goR14oR15i2535R16i2536R17R18gR19r70R20jR21:0:1jR39:3:1i1goR14oR15i2538R16i2539R17R18gR19r70R20jR21:0:1jR39:3:1i1ghgggoR14oR15i2546R16i2592R17R18gR19jR4:5:2i3r16R20jR21:5:3r18oR14oR15i2546R16i2570R17R18gR19r531R20jR21:1:1oR0y24:pixelTransformedPositionR9i-202R5r22R11r531ggoR14oR15i2573R16i2592R17R18gR19r38R20jR21:1:1r41gghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-218R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i2624R16i2760R17R18gR19r3R20jR21:4:1aoR14oR15i2630R16i2655R17R18gR19r491R20jR21:5:3r18oR14oR15i2630R16i2642R17R18gR19r491R20jR21:1:1r490goR14oR15i2645R16i2655R17R18gR19r208R20jR21:1:1r211ggoR14oR15i2661R16i2681R17R18gR19r70R20jR21:5:3r18oR14oR15i2661R16i2673R17R18gR19r70R20jR21:1:1r492goR14oR15i2676R16i2681R17R18gR19r70R20jR21:1:1r303ggoR14oR15i2687R16i2720R17R18gR19r494R20jR21:5:3r18oR14oR15i2687R16i2700R17R18gR19r494R20jR21:1:1r493goR14oR15i2703R16i2720R17R18gR19r132R20jR21:1:1r135ggoR14oR15i2726R16i2754R17R18gR19r70R20jR21:5:3r18oR14oR15i2726R16i2742R17R18gR19r70R20jR21:1:1r495goR14oR15i2745R16i2754R17R18gR19r70R20jR21:1:1r328gghgR12ahghy4:varsar111r66r28r488r21r41r534r135r85r211r303r260r224r238r328r216r228r249r245r5r363r474r544hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey19:h3d.shader.BaseMeshy4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-215R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini1326y3:maxi1969y4:filey73:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FBaseMesh.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i1332R16i1365R17R18gR19jR4:5:2i3jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i1332R16i1348R17R18gR19r17R20jR21:1:1oR0y16:relativePositionR9i-200R5jR10:4:0R11r17ggoR14oR15i1351R16i1365R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y8:positionR9i-192y6:parentoR0y5:inputR9i-191R5jR10:1:0R11jR4:13:1ar27oR0y6:normalR9i-193R26r28R5r29R11jR4:5:2i3r16ghgR5r29R11r26gggoR14oR15i1371R16i1437R17R18gR19jR4:5:2i3r16R20jR21:5:3r18oR14oR15i1371R16i1390R17R18gR19r38R20jR21:1:1oR0y19:transformedPositionR9i-201R5r22R11r38ggoR14oR15i1393R16i1437R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:1:0oR14oR15i1393R16i1409R17R18gR19r17R20jR21:1:1r21goR14oR15i1412R16i1437R17R18gR19jR4:8:0R20jR21:8:2oR14oR15i1412R16i1428R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:50:0gaoR14oR15i1412R16i1428R17R18gR19jR4:7:0R20jR21:1:1oR0y9:modelViewy10:qualifiersajy17:hxsl.VarQualifier:3:0hR9i-189R26oR0y6:globalR9i-186R5jR10:0:0R11jR4:13:1aoR0y4:timeR9i-187R26r66R5r67R11jR4:3:0goR0y9:pixelSizeR9i-188R26r66R5r67R11jR4:5:2i2r16gr63oR0y16:modelViewInverseR32ar65hR9i-190R26r66R5r67R11r62ghgR5r67R11r62gghgggoR14oR15i1443R16i1509R17R18gR19jR4:5:2i4r16R20jR21:5:3r18oR14oR15i1443R16i1460R17R18gR19r82R20jR21:1:1oR0y17:projectedPositionR9i-204R5r22R11r82ggoR14oR15i1463R16i1509R17R18gR19jR4:5:2i4r16R20jR21:5:3r46oR14oR15i1463R16i1491R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i1463R16i1467R17R18gR19jR4:14:1ahR20jR21:2:1jR30:40:0gaoR14oR15i1468R16i1487R17R18gR19r38R20jR21:1:1r41goR14oR15i1489R16i1490R17R18gR19r70R20jR21:0:1jy10:hxsl.Const:3:1i1ghgoR14oR15i1494R16i1509R17R18gR19r62R20jR21:1:1oR0y8:viewProjR9i-181R26oR0y6:cameraR9i-175R5r67R11jR4:13:1aoR0y4:viewR9i-176R26r111R5r67R11r62goR0y4:projR9i-177R26r111R5r67R11r62goR0R25R9i-178R26r111R5r67R11jR4:5:2i3r16goR0y8:projFlipR9i-179R26r111R5r67R11r70goR0y8:projDiagR9i-180R26r111R5r67R11jR4:5:2i3r16gr110oR0y15:inverseViewProjR9i-182R26r111R5r67R11r62goR0y5:zNearR9i-183R26r111R5r67R11r70goR0y4:zFarR9i-184R26r111R5r67R11r70goR0y3:dirR9i-185R26r111R5jR10:3:0R11jR4:5:2i3r16ghgR5r67R11r62ggggoR14oR15i1515R16i1587R17R18gR19jR4:5:2i3r16R20jR21:5:3r18oR14oR15i1515R16i1532R17R18gR19r132R20jR21:1:1oR0y17:transformedNormalR9i-203R5r22R11r132ggoR14oR15i1535R16i1587R17R18gR19r45R20jR21:8:2oR14oR15i1535R16i1575R17R18gR19jR4:14:1aoR3r45R12aoR0y1:_R11r45ghghR20jR21:2:1jR30:31:0gaoR14oR15i1535R16i1575R17R18gR19r45R20jR21:3:1oR14oR15i1536R16i1574R17R18gR19r45R20jR21:5:3r46oR14oR15i1536R16i1548R17R18gR19r32R20jR21:1:1r31goR14oR15i1551R16i1574R17R18gR19jR4:6:0R20jR21:8:2oR14oR15i1551R16i1567R17R18gR19jR4:14:1ahR20jR21:2:1jR30:48:0gaoR14oR15i1551R16i1567R17R18gR19r62R20jR21:1:1r63ghggghggoR14oR15i1593R16i1657R17R18gR19r125R20jR21:5:3r18oR14oR15i1593R16i1603R17R18gR19r125R20jR21:1:1r123goR14oR15i1606R16i1657R17R18gR19r45R20jR21:8:2oR14oR15i1606R16i1645R17R18gR19jR4:14:1aoR3r45R12aoR0R51R11jR4:5:2i3r16ghghR20jR21:2:1r146gaoR14oR15i1606R16i1645R17R18gR19r187R20jR21:3:1oR14oR15i1607R16i1644R17R18gR19r187R20jR21:5:3jR23:3:0oR14oR15i1607R16i1622R17R18gR19r116R20jR21:1:1r115goR14oR15i1625R16i1644R17R18gR19r38R20jR21:1:1r41ggghggoR14oR15i1663R16i1681R17R18gR19jR4:5:2i4r16R20jR21:5:3r18oR14oR15i1663R16i1673R17R18gR19r208R20jR21:1:1oR0y10:pixelColorR9i-205R5r22R11r208ggoR14oR15i1676R16i1681R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y5:colorR9i-211R5jR10:2:0R11r215gggoR14oR15i1687R16i1712R17R18gR19r70R20jR21:5:3r18oR14oR15i1687R16i1696R17R18gR19r70R20jR21:1:1oR0y9:specPowerR9i-208R5r22R11r70ggoR14oR15i1699R16i1712R17R18gR19r70R20jR21:1:1oR0y13:specularPowerR32ajR33:7:2d0d100hR9i-212R5r217R11r70gggoR14oR15i1718R16i1760R17R18gR19jR4:5:2i3r16R20jR21:5:3r18oR14oR15i1718R16i1727R17R18gR19r235R20jR21:1:1oR0y9:specColorR9i-209R5r22R11r235ggoR14oR15i1730R16i1760R17R18gR19jR4:5:2i3r16R20jR21:5:3r46oR14oR15i1730R16i1743R17R18gR19r242R20jR21:1:1oR0y13:specularColorR9i-214R5r217R11r242ggoR14oR15i1746R16i1760R17R18gR19r70R20jR21:1:1oR0y14:specularAmountR32ajR33:7:2d0d10hR9i-213R5r217R11r70ggggoR14oR15i1766R16i1831R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i1766R16i1774R17R18gR19r257R20jR21:1:1oR0y8:screenUVR9i-207R5r22R11r257ggoR14oR15i1777R16i1831R17R18gR19jR4:5:2i2r16R20jR21:8:2oR14oR15i1777R16i1787R17R18gR19jR4:14:1aoR3r264R12aoR0y9:screenPosR11r264ghghR20jR21:2:1jR30:56:0gaoR14oR15i1788R16i1830R17R18gR19jR4:5:2i2r16R20jR21:5:3jR23:2:0oR14oR15i1788R16i1808R17R18gR19r277R20jR21:9:2oR14oR15i1788R16i1805R17R18gR19r82R20jR21:1:1r85gajy14:hxsl.Component:0:0jR61:1:0hgoR14oR15i1811R16i1830R17R18gR19r70R20jR21:9:2oR14oR15i1811R16i1828R17R18gR19r82R20jR21:1:1r85gajR61:3:0hgghggoR14oR15i1837R16i1886R17R18gR19r70R20jR21:5:3r18oR14oR15i1837R16i1842R17R18gR19r70R20jR21:1:1oR0y5:depthR9i-206R5r22R11r70ggoR14oR15i1845R16i1886R17R18gR19r70R20jR21:5:3r278oR14oR15i1845R16i1864R17R18gR19r70R20jR21:9:2oR14oR15i1845R16i1862R17R18gR19r82R20jR21:1:1r85gajR61:2:0hgoR14oR15i1867R16i1886R17R18gR19r70R20jR21:9:2oR14oR15i1867R16i1884R17R18gR19r82R20jR21:1:1r85gar294hgggoR14oR15i1892R16i1963R17R18gR19r70R20jR21:5:3r18oR14oR15i1892R16i1901R17R18gR19r70R20jR21:1:1oR0y9:worldDistR9i-210R5r22R11r70ggoR14oR15i1904R16i1963R17R18gR19r70R20jR21:5:3r278oR14oR15i1904R16i1949R17R18gR19r70R20jR21:8:2oR14oR15i1904R16i1910R17R18gR19jR4:14:1aoR3r70R12aoR0y5:valueR11r45ghghR20jR21:2:1jR30:27:0gaoR14oR15i1911R16i1948R17R18gR19jR4:5:2i3r16R20jR21:5:3r195oR14oR15i1911R16i1930R17R18gR19r38R20jR21:1:1r41goR14oR15i1933R16i1948R17R18gR19r116R20jR21:1:1r115gghgoR14oR15i1952R16i1963R17R18gR19r70R20jR21:1:1r122ggghgR12ahgoR3r3R5r4R7oR0y16:__init__fragmentR9i-216R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i2003R16i2442R17R18gR19r3R20jR21:4:1aoR14oR15i2009R16i2058R17R18gR19r132R20jR21:5:3r18oR14oR15i2009R16i2026R17R18gR19r132R20jR21:1:1r135goR14oR15i2029R16i2058R17R18gR19r45R20jR21:8:2oR14oR15i2029R16i2046R17R18gR19jR4:14:1aoR3r45R12aoR0R51R11r132ghghR20jR21:2:1r146gaoR14oR15i2029R16i2046R17R18gR19r132R20jR21:1:1r135ghggoR14oR15i2159R16i2224R17R18gR19r257R20jR21:5:3r18oR14oR15i2159R16i2167R17R18gR19r257R20jR21:1:1r260goR14oR15i2170R16i2224R17R18gR19r264R20jR21:8:2oR14oR15i2170R16i2180R17R18gR19r271R20jR21:2:1r272gaoR14oR15i2181R16i2223R17R18gR19jR4:5:2i2r16R20jR21:5:3r278oR14oR15i2181R16i2201R17R18gR19r405R20jR21:9:2oR14oR15i2181R16i2198R17R18gR19r82R20jR21:1:1r85gar285r286hgoR14oR15i2204R16i2223R17R18gR19r70R20jR21:9:2oR14oR15i2204R16i2221R17R18gR19r82R20jR21:1:1r85gar294hgghggoR14oR15i2230R16i2279R17R18gR19r70R20jR21:5:3r18oR14oR15i2230R16i2235R17R18gR19r70R20jR21:1:1r303goR14oR15i2238R16i2279R17R18gR19r70R20jR21:5:3r278oR14oR15i2238R16i2257R17R18gR19r70R20jR21:9:2oR14oR15i2238R16i2255R17R18gR19r82R20jR21:1:1r85gar313hgoR14oR15i2260R16i2279R17R18gR19r70R20jR21:9:2oR14oR15i2260R16i2277R17R18gR19r82R20jR21:1:1r85gar294hgggoR14oR15i2363R16i2388R17R18gR19r70R20jR21:5:3r18oR14oR15i2363R16i2372R17R18gR19r70R20jR21:1:1r224goR14oR15i2375R16i2388R17R18gR19r70R20jR21:1:1r228ggoR14oR15i2394R16i2436R17R18gR19r235R20jR21:5:3r18oR14oR15i2394R16i2403R17R18gR19r235R20jR21:1:1r238goR14oR15i2406R16i2436R17R18gR19r242R20jR21:5:3r46oR14oR15i2406R16i2419R17R18gR19r242R20jR21:1:1r245goR14oR15i2422R16i2436R17R18gR19r70R20jR21:1:1r249ggghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-217R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i2466R16i2598R17R18gR19r3R20jR21:4:1aoR14oR15i2472R16i2540R17R18gR19jR4:5:2i4r16R20jR21:5:3r18oR14oR15i2472R16i2487R17R18gR19r484R20jR21:1:1oR0R25R9i-195R26oR0y6:outputR9i-194R5r22R11jR4:13:1ar487oR0R53R9i-196R26r488R5r22R11jR4:5:2i4r16goR0R62R9i-197R26r488R5r22R11r70goR0R28R9i-198R26r488R5r22R11jR4:5:2i3r16goR0R63R9i-199R26r488R5r22R11r70ghgR5r22R11r484ggoR14oR15i2490R16i2540R17R18gR19jR4:5:2i4r16R20jR21:5:3r46oR14oR15i2490R16i2507R17R18gR19r82R20jR21:1:1r85goR14oR15i2510R16i2540R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i2510R16i2514R17R18gR19r96R20jR21:2:1r97gaoR14oR15i2515R16i2516R17R18gR19r70R20jR21:0:1jR39:3:1i1goR14oR15i2518R16i2533R17R18gR19r70R20jR21:1:1r117goR14oR15i2535R16i2536R17R18gR19r70R20jR21:0:1jR39:3:1i1goR14oR15i2538R16i2539R17R18gR19r70R20jR21:0:1jR39:3:1i1ghgggoR14oR15i2546R16i2592R17R18gR19jR4:5:2i3r16R20jR21:5:3r18oR14oR15i2546R16i2570R17R18gR19r531R20jR21:1:1oR0y24:pixelTransformedPositionR9i-202R5r22R11r531ggoR14oR15i2573R16i2592R17R18gR19r38R20jR21:1:1r41gghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-218R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i2624R16i2760R17R18gR19r3R20jR21:4:1aoR14oR15i2630R16i2655R17R18gR19r491R20jR21:5:3r18oR14oR15i2630R16i2642R17R18gR19r491R20jR21:1:1r490goR14oR15i2645R16i2655R17R18gR19r208R20jR21:1:1r211ggoR14oR15i2661R16i2681R17R18gR19r70R20jR21:5:3r18oR14oR15i2661R16i2673R17R18gR19r70R20jR21:1:1r492goR14oR15i2676R16i2681R17R18gR19r70R20jR21:1:1r303ggoR14oR15i2687R16i2720R17R18gR19r494R20jR21:5:3r18oR14oR15i2687R16i2700R17R18gR19r494R20jR21:1:1r493goR14oR15i2703R16i2720R17R18gR19r132R20jR21:1:1r135ggoR14oR15i2726R16i2754R17R18gR19r70R20jR21:5:3r18oR14oR15i2726R16i2742R17R18gR19r70R20jR21:1:1r495goR14oR15i2745R16i2754R17R18gR19r70R20jR21:1:1r328gghgR12ahghy4:varsar111r66r28r488r21r41r534r135r85r211r303r260r224r238r328r216r228r249r245r5r363r474r544hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<color public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></color>
		<color__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</color__>
		<get_color get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_color>
		<set_color get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_color>
		<specularPower public="1" get="accessor" set="accessor"><x path="Float"/></specularPower>
		<specularPower__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</specularPower__>
		<get_specularPower get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_specularPower>
		<set_specularPower get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_specularPower>
		<specularAmount public="1" get="accessor" set="accessor"><x path="Float"/></specularAmount>
		<specularAmount__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</specularAmount__>
		<get_specularAmount get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_specularAmount>
		<set_specularAmount get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_specularAmount>
		<specularColor public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></specularColor>
		<specularColor__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</specularColor__>
		<get_specularColor get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_specularColor>
		<set_specularColor get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_specularColor>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="95"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@global var camera:{ var view : Mat4; var proj : Mat4; var position : Vec3; var projFlip : Float; var projDiag : Vec3; var viewProj : Mat4; var inverseViewProj : Mat4; var zNear : Float; var zFar : Float; @var};
	@global var global:{ var time : Float; var pixelSize : Vec2; @perObject; @perObject};
	@input var input:{ var position : Vec3; var normal : Vec3};
	var output:{ var position : Vec4; var color : Vec4; var depth : Float; var normal : Vec3; var worldDist : Float};
	var relativePosition:Vec3;
	var transformedPosition:Vec3;
	var pixelTransformedPosition:Vec3;
	var transformedNormal:Vec3;
	var projectedPosition:Vec4;
	var pixelColor:Vec4;
	var depth:Float;
	var screenUV:Vec2;
	var specPower:Float;
	var specColor:Vec3;
	var worldDist:Float;
	@param var color:Vec4;
	@range(0, 100) @param var specularPower:Float;
	@range(0, 10) @param var specularAmount:Float;
	@param var specularColor:Vec3;
	function __init__() {
		relativePosition = input.position;
		transformedPosition = relativePosition * global.modelView.mat3x4();
		projectedPosition = vec4(transformedPosition, 1) * camera.viewProj;
		transformedNormal = (input.normal * global.modelView.mat3()).normalize();
		camera.dir = (camera.position - transformedPosition).normalize();
		pixelColor = color;
		specPower = specularPower;
		specColor = specularColor * specularAmount;
		screenUV = screenToUv(projectedPosition.xy / projectedPosition.w);
		depth = projectedPosition.z / projectedPosition.w;
		worldDist = length(transformedPosition - camera.position) / camera.zFar;
	};
	function __init__fragment() {
		transformedNormal = transformedNormal.normalize();
		screenUV = screenToUv(projectedPosition.xy / projectedPosition.w);
		depth = projectedPosition.z / projectedPosition.w;
		specPower = specularPower;
		specColor = specularColor * specularAmount;
	};
	function vertex() {
		output.position = projectedPosition * vec4(1, camera.projFlip, 1, 1);
		pixelTransformedPosition = transformedPosition;
	};
	function fragment() {
		output.color = pixelColor;
		output.depth = depth;
		output.normal = transformedNormal;
		output.worldDist = worldDist;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.Blur" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Blur.hx">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;oy4:namey15:h3d.shader.Blury4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-286R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini330y3:maxi396y4:filey77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FScreenShader.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i336R16i361R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i336R16i348R17R18gR19r17R20jR21:1:1oR0y5:colorR9i-266y6:parentoR0y6:outputR9i-264R5jR10:4:0R11jR4:13:1aoR0y8:positionR9i-265R25r22R5r23R11jR4:5:2i4r16gr21hgR5r23R11r17ggoR14oR15i351R16i361R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y10:pixelColorR9i-267R5r23R11r31gggoR14oR15i367R16i390R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i367R16i379R17R18gR19r37R20jR21:1:1oR0y12:calculatedUVR9i-268R5r23R11r37ggoR14oR15i382R16i390R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y2:uvR9i-262R25oR0y5:inputR9i-260R5jR10:1:0R11jR4:13:1aoR0R27R9i-261R25r46R5r47R11jR4:5:2i2r16gr45hgR5r47R11r44ggghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-287R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i420R16i504R17R18gR19r3R20jR21:4:1aoR14oR15i426R16i498R17R18gR19r26R20jR21:5:3r18oR14oR15i426R16i441R17R18gR19r26R20jR21:1:1r25goR14oR15i444R16i498R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i444R16i448R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i449R16i465R17R18gR19jR4:3:0R20jR21:9:2oR14oR15i449R16i463R17R18gR19r50R20jR21:1:1r49gajy14:hxsl.Component:0:0hgoR14oR15i467R16i491R17R18gR19r83R20jR21:5:3jR23:1:0oR14oR15i467R16i483R17R18gR19r83R20jR21:9:2oR14oR15i467R16i481R17R18gR19r50R20jR21:1:1r49gajR34:1:0hgoR14oR15i486R16i491R17R18gR19r83R20jR21:1:1oR0y5:flipYR9i-263R5jR10:2:0R11r83gggoR14oR15i493R16i494R17R18gR19r83R20jR21:0:1jy10:hxsl.Const:3:1zgoR14oR15i496R16i497R17R18gR19r83R20jR21:0:1jR36:3:1i1ghgghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-288R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i767R16i2480R17y69:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FBlur.hxgR19r3R20jR21:4:1aoR14oR15i773R16i2220R17R38gR19r3R20jR21:10:3oR14oR15i777R16i793R17R38gR19jR4:2:0R20jR21:1:1oR0y16:isDepthDependanty10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-280R5r104R11r133ggoR14oR15i796R16i1415R17R38gR19r3R20jR21:4:1aoR14oR15i803R16i836R17R38gR19r3R20jR21:7:2oR0y4:pcurR9i-291R5r23R11jR4:5:2i3r16goR14oR15i814R16i835R17R38gR19r144R20jR21:8:2oR14oR15i814R16i825R17R38gR19jR4:14:1aoR3r144R12aoR0R30R11jR4:5:2i2r16ghghR20jR21:1:1oR0y11:getPositionR9i-290R5r6R11r154ggaoR14oR15i826R16i834R17R38gR19r44R20jR21:1:1r45ghggoR14oR15i842R16i875R17R38gR19r3R20jR21:7:2oR0y4:ccurR9i-292R5r23R11jR4:5:2i4r16goR14oR15i853R16i874R17R38gR19r166R20jR21:8:2oR14oR15i853R16i860R17R38gR19jR4:14:1aoR3r166R12aoR0y1:_R11jR4:10:0goR0R30R11jR4:5:2i2r16ghghR20jR21:2:1jR33:33:0gaoR14oR15i853R16i860R17R38gR19r175R20jR21:1:1oR0y7:textureR9i-270R5r104R11r175ggoR14oR15i865R16i873R17R38gR19r44R20jR21:1:1r45ghggoR14oR15i881R16i910R17R38gR19r3R20jR21:7:2oR0R24R9i-293R5r23R11jR4:5:2i4r16goR14oR15i893R16i909R17R38gR19r194R20jR21:8:2oR14oR15i893R16i897R17R38gR19r77R20jR21:2:1r78gaoR14oR15i898R16i899R17R38gR19r83R20jR21:0:1jR36:3:1zgoR14oR15i901R16i902R17R38gR19r83R20jR21:0:1jR36:3:1zgoR14oR15i904R16i905R17R38gR19r83R20jR21:0:1jR36:3:1zgoR14oR15i907R16i908R17R38gR19r83R20jR21:0:1jR36:3:1zghggoR14oR15i916R16i969R17R38gR19r3R20jR21:7:2oR0y4:ncurR9i-294R5r23R11jR4:5:2i3r16goR14oR15i927R16i968R17R38gR19r222R20jR21:8:2oR14oR15i927R16i939R17R38gR19jR4:14:1aoR3r222R12aoR0y5:valueR11r166ghghR20jR21:2:1jR33:55:0gaoR14oR15i940R16i967R17R38gR19r166R20jR21:8:2oR14oR15i940R16i953R17R38gR19jR4:14:1aoR3r166R12aoR0R45R11r175gr176hghR20jR21:2:1r179gaoR14oR15i940R16i953R17R38gR19r175R20jR21:1:1oR0y13:normalTextureR9i-282R5r104R11r175ggoR14oR15i958R16i966R17R38gR19r44R20jR21:1:1r45ghghggoR14oR15i975R16i1384R17R38gR19r3R20jR21:20:3y6:unrollahoR14oR15i983R16i1384R17R38gR19r3R20jR21:13:3oR0y1:iR9i-295R5r23R11jR4:1:0goR14oR15i993R16i1015R17R38gR19jR4:15:2r262jy13:hxsl.SizeDecl:0:1zR20jR21:5:3jR23:21:0oR14oR15i993R16i1008R17R38gR19r262R20jR21:5:3jR23:0:0oR14oR15i993R16i1001R17R38gR19r262R20jR21:6:2jy15:haxe.macro.Unop:3:0oR14oR15i994R16i1001R17R38gR19r262R20jR21:1:1oR0y7:QualityR40ajR41:0:1nhR9i-272R5r104R11r262gggoR14oR15i1004R16i1008R17R38gR19r262R20jR21:0:1jR36:2:1i1ggoR14oR15i1008R16i1015R17R38gR19r262R20jR21:1:1r276ggoR14oR15i1018R16i1384R17R38gR19r3R20jR21:4:1aoR14oR15i1026R16i1078R17R38gR19r3R20jR21:7:2oR0R30R9i-296R5r23R11jR4:5:2i2r16goR14oR15i1035R16i1077R17R38gR19r296R20jR21:5:3r270oR14oR15i1035R16i1043R17R38gR19r44R20jR21:1:1r45goR14oR15i1046R16i1077R17R38gR19jR4:5:2i2r16R20jR21:5:3r92oR14oR15i1046R16i1051R17R38gR19r304R20jR21:1:1oR0y5:pixelR9i-276R5r104R11r304ggoR14oR15i1054R16i1077R17R38gR19r83R20jR21:16:2oR14oR15i1054R16i1061R17R38gR19jR4:15:2r83jR52:1:1r276R20jR21:1:1oR0y7:offsetsR9i-275R5r104R11r314ggoR14oR15i1062R16i1076R17R38gR19r262R20jR21:10:3oR14oR15i1062R16i1067R17R38gR19r133R20jR21:5:3jR23:9:0oR14oR15i1062R16i1063R17R38gR19r262R20jR21:1:1r261goR14oR15i1066R16i1067R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i1070R16i1072R17R38gR19r262R20jR21:6:2r273oR14oR15i1071R16i1072R17R38gR19r262R20jR21:1:1r261ggoR14oR15i1075R16i1076R17R38gR19r262R20jR21:1:1r261ggggggoR14oR15i1085R16i1109R17R38gR19r3R20jR21:7:2oR0y1:cR9i-297R5r23R11r166goR14oR15i1093R16i1108R17R38gR19r166R20jR21:8:2oR14oR15i1093R16i1100R17R38gR19jR4:14:1aoR3r166R12aoR0R45R11r175gr176hghR20jR21:2:1r179gaoR14oR15i1093R16i1100R17R38gR19r175R20jR21:1:1r184goR14oR15i1105R16i1107R17R38gR19r296R20jR21:1:1r295ghggoR14oR15i1116R16i1140R17R38gR19r3R20jR21:7:2oR0R14R9i-298R5r23R11r144goR14oR15i1124R16i1139R17R38gR19r144R20jR21:8:2oR14oR15i1124R16i1135R17R38gR19r154R20jR21:1:1r155gaoR14oR15i1136R16i1138R17R38gR19r296R20jR21:1:1r295ghggoR14oR15i1147R16i1180R17R38gR19r3R20jR21:7:2oR0y1:dR9i-299R5r23R11r83goR14oR15i1155R16i1179R17R38gR19r83R20jR21:8:2oR14oR15i1155R16i1165R17R38gR19jR4:14:1aoR3r83R12aoR0R45R11jR4:5:2i3r16goR0y1:bR11r222ghghR20jR21:2:1jR33:29:0gaoR14oR15i1155R16i1165R17R38gR19r391R20jR21:3:1oR14oR15i1156R16i1164R17R38gR19r391R20jR21:5:3jR23:3:0oR14oR15i1156R16i1157R17R38gR19r144R20jR21:1:1r368goR14oR15i1160R16i1164R17R38gR19r144R20jR21:1:1r143gggoR14oR15i1170R16i1178R17R38gR19jR4:5:2i3r16R20jR21:5:3r401oR14oR15i1170R16i1171R17R38gR19r144R20jR21:1:1r368goR14oR15i1174R16i1178R17R38gR19r144R20jR21:1:1r143gghggoR14oR15i1187R16i1231R17R38gR19r3R20jR21:7:2oR0y1:nR9i-300R5r23R11r222goR14oR15i1195R16i1230R17R38gR19r222R20jR21:8:2oR14oR15i1195R16i1207R17R38gR19r231R20jR21:2:1r232gaoR14oR15i1208R16i1229R17R38gR19r166R20jR21:8:2oR14oR15i1208R16i1221R17R38gR19jR4:14:1aoR3r166R12aoR0R45R11r175gr176hghR20jR21:2:1r179gaoR14oR15i1208R16i1221R17R38gR19r175R20jR21:1:1r248goR14oR15i1226R16i1228R17R38gR19r296R20jR21:1:1r295ghghggoR14oR15i1240R16i1269R17R38gR19r166R20jR21:5:3r18oR14oR15i1240R16i1241R17R38gR19r166R20jR21:1:1r346goR14oR15i1244R16i1269R17R38gR19r166R20jR21:8:2oR14oR15i1244R16i1247R17R38gR19jR4:14:1aoR3r166R12aoR0y1:xR11r166goR0y1:yR11r166goR0y1:aR11r83ghghR20jR21:2:1jR33:24:0gaoR14oR15i1248R16i1252R17R38gR19r166R20jR21:1:1r165goR14oR15i1254R16i1255R17R38gR19r166R20jR21:1:1r346goR14oR15i1257R16i1268R17R38gR19r83R20jR21:8:2oR14oR15i1257R16i1261R17R38gR19jR4:14:1aoR3r83R12aoR0R45R11r222gr392hghR20jR21:2:1r394gaoR14oR15i1257R16i1261R17R38gR19r222R20jR21:1:1r221goR14oR15i1266R16i1267R17R38gR19r222R20jR21:1:1r424ghghggoR14oR15i1277R16i1333R17R38gR19r166R20jR21:5:3r18oR14oR15i1277R16i1278R17R38gR19r166R20jR21:1:1r346goR14oR15i1281R16i1333R17R38gR19r166R20jR21:8:2oR14oR15i1281R16i1284R17R38gR19jR4:14:1ar461hR20jR21:2:1r467gaoR14oR15i1285R16i1286R17R38gR19r166R20jR21:1:1r346goR14oR15i1288R16i1292R17R38gR19r166R20jR21:1:1r165goR14oR15i1294R16i1332R17R38gR19r83R20jR21:8:2oR14oR15i1294R16i1324R17R38gR19jR4:14:1aoR3r83R12aoR0R45R11r83goR0R59R11r83ghghR20jR21:2:1jR33:21:0gaoR14oR15i1294R16i1324R17R38gR19r83R20jR21:3:1oR14oR15i1295R16i1323R17R38gR19r83R20jR21:5:3r92oR14oR15i1295R16i1314R17R38gR19r83R20jR21:8:2oR14oR15i1295R16i1306R17R38gR19jR4:14:1aoR3r83R12aoR0R45R11r83gr523hghR20jR21:2:1jR33:22:0gaoR14oR15i1295R16i1306R17R38gR19r83R20jR21:3:1oR14oR15i1296R16i1305R17R38gR19r83R20jR21:5:3r401oR14oR15i1296R16i1297R17R38gR19r83R20jR21:1:1r382goR14oR15i1300R16i1305R17R38gR19r83R20jR21:0:1jR36:3:1d0.001gggoR14oR15i1311R16i1313R17R38gR19r83R20jR21:0:1jR36:3:1d0ghgoR14oR15i1317R16i1323R17R38gR19r83R20jR21:0:1jR36:3:1i100000gggoR14oR15i1329R16i1331R17R38gR19r83R20jR21:0:1jR36:3:1d1ghghggoR14oR15i1341R16i1376R17R38gR19r194R20jR21:5:3jR23:20:1r270oR14oR15i1341R16i1346R17R38gR19r194R20jR21:1:1r193goR14oR15i1350R16i1376R17R38gR19r166R20jR21:5:3r92oR14oR15i1350R16i1351R17R38gR19r166R20jR21:1:1r346goR14oR15i1354R16i1376R17R38gR19r83R20jR21:16:2oR14oR15i1354R16i1360R17R38gR19jR4:15:2r83jR52:1:1r276R20jR21:1:1oR0y6:valuesR9i-274R5r104R11r591ggoR14oR15i1361R16i1375R17R38gR19r262R20jR21:10:3oR14oR15i1361R16i1366R17R38gR19r133R20jR21:5:3r321oR14oR15i1361R16i1362R17R38gR19r262R20jR21:1:1r261goR14oR15i1365R16i1366R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i1369R16i1371R17R38gR19r262R20jR21:6:2r273oR14oR15i1370R16i1371R17R38gR19r262R20jR21:1:1r261ggoR14oR15i1374R16i1375R17R38gR19r262R20jR21:1:1r261ggggghgggoR14oR15i1390R16i1408R17R38gR19r31R20jR21:5:3r18oR14oR15i1390R16i1400R17R38gR19r31R20jR21:1:1r32goR14oR15i1403R16i1408R17R38gR19r194R20jR21:1:1r193gghgoR14oR15i1425R16i2220R17R38gR19r3R20jR21:10:3oR14oR15i1429R16i1436R17R38gR19r133R20jR21:1:1oR0y7:isDepthR40ajR41:0:1nhR9i-273R5r104R11r133ggoR14oR15i1439R16i1834R17R38gR19r3R20jR21:4:1aoR14oR15i1446R16i1459R17R38gR19r3R20jR21:7:2oR0y3:valR9i-301R5r23R11r83goR14oR15i1456R16i1458R17R38gR19r83R20jR21:0:1jR36:3:1d0ggoR14oR15i1465R16i1784R17R38gR19r3R20jR21:20:3R50ahoR14oR15i1473R16i1784R17R38gR19r3R20jR21:13:3oR0R51R9i-302R5r23R11r262goR14oR15i1483R16i1505R17R38gR19jR4:15:2r262jR52:0:1zR20jR21:5:3r267oR14oR15i1483R16i1498R17R38gR19r262R20jR21:5:3r270oR14oR15i1483R16i1491R17R38gR19r262R20jR21:6:2r273oR14oR15i1484R16i1491R17R38gR19r262R20jR21:1:1r276ggoR14oR15i1494R16i1498R17R38gR19r262R20jR21:0:1jR36:2:1i1ggoR14oR15i1498R16i1505R17R38gR19r262R20jR21:1:1r276ggoR14oR15i1507R16i1784R17R38gR19r3R20jR21:4:1aoR14oR15i1515R16i1776R17R38gR19r3R20jR21:10:3oR14oR15i1519R16i1525R17R38gR19r133R20jR21:1:1oR0y6:isCubeR40ajR41:0:1nhR9i-283R5r104R11r133ggoR14oR15i1528R16i1664R17R38gR19r83R20jR21:5:3jR23:20:1r270oR14oR15i1528R16i1531R17R38gR19r83R20jR21:1:1r645goR14oR15i1535R16i1664R17R38gR19r83R20jR21:5:3r92oR14oR15i1535R16i1639R17R38gR19r83R20jR21:8:2oR14oR15i1535R16i1541R17R38gR19jR4:14:1aoR3r83R12aoR0R48R11r166ghghR20jR21:2:1jR33:53:0gaoR14oR15i1542R16i1638R17R38gR19r166R20jR21:8:2oR14oR15i1542R16i1553R17R38gR19jR4:14:1aoR3r166R12aoR0R45R11jR4:12:0goR0y6:normalR11r222ghghR20jR21:2:1r179gaoR14oR15i1542R16i1553R17R38gR19r717R20jR21:1:1oR0y11:cubeTextureR9i-284R5r104R11r717ggoR14oR15i1558R16i1637R17R38gR19r222R20jR21:5:3r92oR14oR15i1558R16i1627R17R38gR19jR4:5:2i3r16R20jR21:8:2oR14oR15i1558R16i1562R17R38gR19jR4:14:1ahR20jR21:2:1jR33:39:0gaoR14oR15i1563R16i1623R17R38gR19jR4:5:2i2r16R20jR21:5:3r401oR14oR15i1563R16i1617R17R38gR19r740R20jR21:5:3r92oR14oR15i1563R16i1612R17R38gR19r740R20jR21:3:1oR14oR15i1564R16i1610R17R38gR19r740R20jR21:5:3r270oR14oR15i1564R16i1572R17R38gR19r44R20jR21:1:1r45goR14oR15i1575R16i1610R17R38gR19r304R20jR21:5:3r92oR14oR15i1575R16i1606R17R38gR19r304R20jR21:5:3r92oR14oR15i1575R16i1580R17R38gR19r304R20jR21:1:1r307goR14oR15i1583R16i1606R17R38gR19r83R20jR21:16:2oR14oR15i1583R16i1590R17R38gR19r314R20jR21:1:1r315goR14oR15i1591R16i1605R17R38gR19r262R20jR21:10:3oR14oR15i1591R16i1596R17R38gR19r133R20jR21:5:3r321oR14oR15i1591R16i1592R17R38gR19r262R20jR21:1:1r656goR14oR15i1595R16i1596R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i1599R16i1601R17R38gR19r262R20jR21:6:2r273oR14oR15i1600R16i1601R17R38gR19r262R20jR21:1:1r656ggoR14oR15i1604R16i1605R17R38gR19r262R20jR21:1:1r656ggggoR14oR15i1609R16i1610R17R38gR19r83R20jR21:8:2oR14oR15i1609R16i1610R17R38gR19jR4:14:1ahR20jR21:2:1jR33:36:0gaoR14oR15i1609R16i1610R17R38gR19r262R20jR21:1:1r656ghggggoR14oR15i1614R16i1617R17R38gR19r83R20jR21:0:1jR36:3:1d2ggoR14oR15i1620R16i1623R17R38gR19r83R20jR21:0:1jR36:3:1d1ggoR14oR15i1625R16i1626R17R38gR19r83R20jR21:0:1jR36:3:1i1ghgoR14oR15i1630R16i1637R17R38gR19jR4:6:0R20jR21:1:1oR0y7:cubeDirR9i-285R5r104R11r819ggghghgoR14oR15i1642R16i1664R17R38gR19r83R20jR21:16:2oR14oR15i1642R16i1648R17R38gR19r591R20jR21:1:1r592goR14oR15i1649R16i1663R17R38gR19r262R20jR21:10:3oR14oR15i1649R16i1654R17R38gR19r133R20jR21:5:3r321oR14oR15i1649R16i1650R17R38gR19r262R20jR21:1:1r656goR14oR15i1653R16i1654R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i1657R16i1659R17R38gR19r262R20jR21:6:2r273oR14oR15i1658R16i1659R17R38gR19r262R20jR21:1:1r656ggoR14oR15i1662R16i1663R17R38gR19r262R20jR21:1:1r656gggggoR14oR15i1677R16i1776R17R38gR19r83R20jR21:5:3jR23:20:1r270oR14oR15i1677R16i1680R17R38gR19r83R20jR21:1:1r645goR14oR15i1684R16i1776R17R38gR19r83R20jR21:5:3r92oR14oR15i1684R16i1751R17R38gR19r83R20jR21:8:2oR14oR15i1684R16i1690R17R38gR19r705R20jR21:2:1r706gaoR14oR15i1691R16i1750R17R38gR19r166R20jR21:8:2oR14oR15i1691R16i1698R17R38gR19jR4:14:1aoR3r166R12aoR0R45R11r175gr176hghR20jR21:2:1r179gaoR14oR15i1691R16i1698R17R38gR19r175R20jR21:1:1r184goR14oR15i1703R16i1749R17R38gR19jR4:5:2i2r16R20jR21:5:3r270oR14oR15i1703R16i1711R17R38gR19r44R20jR21:1:1r45goR14oR15i1714R16i1749R17R38gR19r304R20jR21:5:3r92oR14oR15i1714R16i1745R17R38gR19r304R20jR21:5:3r92oR14oR15i1714R16i1719R17R38gR19r304R20jR21:1:1r307goR14oR15i1722R16i1745R17R38gR19r83R20jR21:16:2oR14oR15i1722R16i1729R17R38gR19r314R20jR21:1:1r315goR14oR15i1730R16i1744R17R38gR19r262R20jR21:10:3oR14oR15i1730R16i1735R17R38gR19r133R20jR21:5:3r321oR14oR15i1730R16i1731R17R38gR19r262R20jR21:1:1r656goR14oR15i1734R16i1735R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i1738R16i1740R17R38gR19r262R20jR21:6:2r273oR14oR15i1739R16i1740R17R38gR19r262R20jR21:1:1r656ggoR14oR15i1743R16i1744R17R38gR19r262R20jR21:1:1r656ggggoR14oR15i1748R16i1749R17R38gR19r83R20jR21:8:2oR14oR15i1748R16i1749R17R38gR19jR4:14:1ahR20jR21:2:1r792gaoR14oR15i1748R16i1749R17R38gR19r262R20jR21:1:1r656ghggghghgoR14oR15i1754R16i1776R17R38gR19r83R20jR21:16:2oR14oR15i1754R16i1760R17R38gR19r591R20jR21:1:1r592goR14oR15i1761R16i1775R17R38gR19r262R20jR21:10:3oR14oR15i1761R16i1766R17R38gR19r133R20jR21:5:3r321oR14oR15i1761R16i1762R17R38gR19r262R20jR21:1:1r656goR14oR15i1765R16i1766R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i1769R16i1771R17R38gR19r262R20jR21:6:2r273oR14oR15i1770R16i1771R17R38gR19r262R20jR21:1:1r656ggoR14oR15i1774R16i1775R17R38gR19r262R20jR21:1:1r656gggggghgggoR14oR15i1790R16i1827R17R38gR19r31R20jR21:5:3r18oR14oR15i1790R16i1800R17R38gR19r31R20jR21:1:1r32goR14oR15i1803R16i1827R17R38gR19r166R20jR21:8:2oR14oR15i1803R16i1807R17R38gR19jR4:14:1aoR3r166R12aoR0R48R11r83ghghR20jR21:2:1jR33:52:0gaoR14oR15i1808R16i1826R17R38gR19r83R20jR21:8:2oR14oR15i1808R16i1811R17R38gR19jR4:14:1aoR3r83R12aoR0R45R11r83gr523hghR20jR21:2:1r525gaoR14oR15i1808R16i1811R17R38gR19r83R20jR21:1:1r645goR14oR15i1816R16i1825R17R38gR19r83R20jR21:0:1jR36:3:1d0.9999999ghghgghgoR14oR15i1840R16i2220R17R38gR19r3R20jR21:4:1aoR14oR15i1847R16i1876R17R38gR19r3R20jR21:7:2oR0R24R9i-303R5r23R11jR4:5:2i4r16goR14oR15i1859R16i1875R17R38gR19r1020R20jR21:8:2oR14oR15i1859R16i1863R17R38gR19r77R20jR21:2:1r78gaoR14oR15i1864R16i1865R17R38gR19r83R20jR21:0:1jR36:3:1zgoR14oR15i1867R16i1868R17R38gR19r83R20jR21:0:1jR36:3:1zgoR14oR15i1870R16i1871R17R38gR19r83R20jR21:0:1jR36:3:1zgoR14oR15i1873R16i1874R17R38gR19r83R20jR21:0:1jR36:3:1zghggoR14oR15i1882R16i2189R17R38gR19r3R20jR21:20:3R50ahoR14oR15i1890R16i2189R17R38gR19r3R20jR21:13:3oR0R51R9i-304R5r23R11r262goR14oR15i1900R16i1922R17R38gR19jR4:15:2r262jR52:0:1zR20jR21:5:3r267oR14oR15i1900R16i1915R17R38gR19r262R20jR21:5:3r270oR14oR15i1900R16i1908R17R38gR19r262R20jR21:6:2r273oR14oR15i1901R16i1908R17R38gR19r262R20jR21:1:1r276ggoR14oR15i1911R16i1915R17R38gR19r262R20jR21:0:1jR36:2:1i1ggoR14oR15i1915R16i1922R17R38gR19r262R20jR21:1:1r276ggoR14oR15i1924R16i2189R17R38gR19r3R20jR21:4:1aoR14oR15i1932R16i2181R17R38gR19r3R20jR21:10:3oR14oR15i1936R16i1942R17R38gR19r133R20jR21:1:1r685goR14oR15i1945R16i2075R17R38gR19r1020R20jR21:5:3jR23:20:1r270oR14oR15i1945R16i1950R17R38gR19r1020R20jR21:1:1r1019goR14oR15i1954R16i2075R17R38gR19r166R20jR21:5:3r92oR14oR15i1954R16i2050R17R38gR19r166R20jR21:8:2oR14oR15i1954R16i1965R17R38gR19jR4:14:1aoR3r166R12aoR0R45R11r717gr718hghR20jR21:2:1r179gaoR14oR15i1954R16i1965R17R38gR19r717R20jR21:1:1r724goR14oR15i1970R16i2049R17R38gR19r222R20jR21:5:3r92oR14oR15i1970R16i2039R17R38gR19jR4:5:2i3r16R20jR21:8:2oR14oR15i1970R16i1974R17R38gR19r734R20jR21:2:1r735gaoR14oR15i1975R16i2035R17R38gR19jR4:5:2i2r16R20jR21:5:3r401oR14oR15i1975R16i2029R17R38gR19r1113R20jR21:5:3r92oR14oR15i1975R16i2024R17R38gR19r1113R20jR21:3:1oR14oR15i1976R16i2022R17R38gR19r1113R20jR21:5:3r270oR14oR15i1976R16i1984R17R38gR19r44R20jR21:1:1r45goR14oR15i1987R16i2022R17R38gR19r304R20jR21:5:3r92oR14oR15i1987R16i2018R17R38gR19r304R20jR21:5:3r92oR14oR15i1987R16i1992R17R38gR19r304R20jR21:1:1r307goR14oR15i1995R16i2018R17R38gR19r83R20jR21:16:2oR14oR15i1995R16i2002R17R38gR19r314R20jR21:1:1r315goR14oR15i2003R16i2017R17R38gR19r262R20jR21:10:3oR14oR15i2003R16i2008R17R38gR19r133R20jR21:5:3r321oR14oR15i2003R16i2004R17R38gR19r262R20jR21:1:1r1050goR14oR15i2007R16i2008R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i2011R16i2013R17R38gR19r262R20jR21:6:2r273oR14oR15i2012R16i2013R17R38gR19r262R20jR21:1:1r1050ggoR14oR15i2016R16i2017R17R38gR19r262R20jR21:1:1r1050ggggoR14oR15i2021R16i2022R17R38gR19r83R20jR21:8:2oR14oR15i2021R16i2022R17R38gR19jR4:14:1ahR20jR21:2:1r792gaoR14oR15i2021R16i2022R17R38gR19r262R20jR21:1:1r1050ghggggoR14oR15i2026R16i2029R17R38gR19r83R20jR21:0:1jR36:3:1d2ggoR14oR15i2032R16i2035R17R38gR19r83R20jR21:0:1jR36:3:1d1ggoR14oR15i2037R16i2038R17R38gR19r83R20jR21:0:1jR36:3:1i1ghgoR14oR15i2042R16i2049R17R38gR19r819R20jR21:1:1r820gghgoR14oR15i2053R16i2075R17R38gR19r83R20jR21:16:2oR14oR15i2053R16i2059R17R38gR19r591R20jR21:1:1r592goR14oR15i2060R16i2074R17R38gR19r262R20jR21:10:3oR14oR15i2060R16i2065R17R38gR19r133R20jR21:5:3r321oR14oR15i2060R16i2061R17R38gR19r262R20jR21:1:1r1050goR14oR15i2064R16i2065R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i2068R16i2070R17R38gR19r262R20jR21:6:2r273oR14oR15i2069R16i2070R17R38gR19r262R20jR21:1:1r1050ggoR14oR15i2073R16i2074R17R38gR19r262R20jR21:1:1r1050gggggoR14oR15i2088R16i2181R17R38gR19r1020R20jR21:5:3jR23:20:1r270oR14oR15i2088R16i2093R17R38gR19r1020R20jR21:1:1r1019goR14oR15i2097R16i2181R17R38gR19r166R20jR21:5:3r92oR14oR15i2097R16i2156R17R38gR19r166R20jR21:8:2oR14oR15i2097R16i2104R17R38gR19jR4:14:1aoR3r166R12aoR0R45R11r175gr176hghR20jR21:2:1r179gaoR14oR15i2097R16i2104R17R38gR19r175R20jR21:1:1r184goR14oR15i2109R16i2155R17R38gR19jR4:5:2i2r16R20jR21:5:3r270oR14oR15i2109R16i2117R17R38gR19r44R20jR21:1:1r45goR14oR15i2120R16i2155R17R38gR19r304R20jR21:5:3r92oR14oR15i2120R16i2151R17R38gR19r304R20jR21:5:3r92oR14oR15i2120R16i2125R17R38gR19r304R20jR21:1:1r307goR14oR15i2128R16i2151R17R38gR19r83R20jR21:16:2oR14oR15i2128R16i2135R17R38gR19r314R20jR21:1:1r315goR14oR15i2136R16i2150R17R38gR19r262R20jR21:10:3oR14oR15i2136R16i2141R17R38gR19r133R20jR21:5:3r321oR14oR15i2136R16i2137R17R38gR19r262R20jR21:1:1r1050goR14oR15i2140R16i2141R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i2144R16i2146R17R38gR19r262R20jR21:6:2r273oR14oR15i2145R16i2146R17R38gR19r262R20jR21:1:1r1050ggoR14oR15i2149R16i2150R17R38gR19r262R20jR21:1:1r1050ggggoR14oR15i2154R16i2155R17R38gR19r83R20jR21:8:2oR14oR15i2154R16i2155R17R38gR19jR4:14:1ahR20jR21:2:1r792gaoR14oR15i2154R16i2155R17R38gR19r262R20jR21:1:1r1050ghggghgoR14oR15i2159R16i2181R17R38gR19r83R20jR21:16:2oR14oR15i2159R16i2165R17R38gR19r591R20jR21:1:1r592goR14oR15i2166R16i2180R17R38gR19r262R20jR21:10:3oR14oR15i2166R16i2171R17R38gR19r133R20jR21:5:3r321oR14oR15i2166R16i2167R17R38gR19r262R20jR21:1:1r1050goR14oR15i2170R16i2171R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i2174R16i2176R17R38gR19r262R20jR21:6:2r273oR14oR15i2175R16i2176R17R38gR19r262R20jR21:1:1r1050ggoR14oR15i2179R16i2180R17R38gR19r262R20jR21:1:1r1050gggggghgggoR14oR15i2195R16i2213R17R38gR19r31R20jR21:5:3r18oR14oR15i2195R16i2205R17R38gR19r31R20jR21:1:1r32goR14oR15i2208R16i2213R17R38gR19r1020R20jR21:1:1r1019gghgggoR14oR15i2225R16i2475R17R38gR19r3R20jR21:10:3oR14oR15i2229R16i2242R17R38gR19r133R20jR21:1:1oR0y13:hasFixedColorR40ajR41:0:1nhR9i-277R5r104R11r133ggoR14oR15i2245R16i2475R17R38gR19r3R20jR21:4:1aoR14oR15i2252R16i2380R17R38gR19r3R20jR21:10:3oR14oR15i2256R16i2272R17R38gR19r133R20jR21:1:1oR0y16:smoothFixedColorR40ajR41:0:1nhR9i-278R5r104R11r133ggoR14oR15i2281R16i2309R17R38gR19r83R20jR21:5:3jR23:20:1r92oR14oR15i2281R16i2293R17R38gR19r83R20jR21:9:2oR14oR15i2281R16i2291R17R38gR19r31R20jR21:1:1r32gajR34:3:0hgoR14oR15i2297R16i2309R17R38gR19r83R20jR21:9:2oR14oR15i2297R16i2307R17R38gR19jR4:5:2i4r16R20jR21:1:1oR0y10:fixedColorR9i-279R5r104R11r1383ggar1377hggoR14oR15i2327R16i2380R17R38gR19r83R20jR21:5:3r18oR14oR15i2327R16i2339R17R38gR19r83R20jR21:9:2oR14oR15i2327R16i2337R17R38gR19r31R20jR21:1:1r32gar1377hgoR14oR15i2342R16i2380R17R38gR19r83R20jR21:5:3r92oR14oR15i2342R16i2354R17R38gR19r83R20jR21:9:2oR14oR15i2342R16i2352R17R38gR19r1383R20jR21:1:1r1384gar1377hgoR14oR15i2357R16i2380R17R38gR19r83R20jR21:8:2oR14oR15i2357R16i2362R17R38gR19jR4:14:1aoR3r83R12aoR0R48R11r133ghghR20jR21:2:1r792gaoR14oR15i2363R16i2379R17R38gR19r133R20jR21:5:3jR23:7:0oR14oR15i2363R16i2375R17R38gR19r83R20jR21:9:2oR14oR15i2363R16i2373R17R38gR19r31R20jR21:1:1r32gar1377hgoR14oR15i2378R16i2379R17R38gR19r83R20jR21:0:1jR36:3:1zgghggggoR14oR15i2387R16i2433R17R38gR19jR4:5:2i3r16R20jR21:5:3r18oR14oR15i2387R16i2401R17R38gR19r1439R20jR21:9:2oR14oR15i2387R16i2397R17R38gR19r31R20jR21:1:1r32gar88r99jR34:2:0hgoR14oR15i2404R16i2433R17R38gR19jR4:5:2i3r16R20jR21:5:3r92oR14oR15i2404R16i2418R17R38gR19r1450R20jR21:9:2oR14oR15i2404R16i2414R17R38gR19r1383R20jR21:1:1r1384gar88r99r1446hgoR14oR15i2421R16i2433R17R38gR19r83R20jR21:9:2oR14oR15i2421R16i2431R17R38gR19r31R20jR21:1:1r32gar1377hggghgnghgR12ahgoR3r144R5jR6:3:0R7r155R13oR14oR15i2527R16i2709R17R38gR19r3R20jR21:4:1aoR14oR15i2533R16i2574R17R38gR19r3R20jR21:7:2oR0y5:depthR9i-305R5r23R11r83goR14oR15i2545R16i2573R17R38gR19r83R20jR21:8:2oR14oR15i2545R16i2551R17R38gR19r705R20jR21:2:1r706gaoR14oR15i2552R16i2572R17R38gR19r166R20jR21:8:2oR14oR15i2552R16i2564R17R38gR19jR4:14:1aoR3r166R12aoR0R45R11r175gr176hghR20jR21:2:1r179gaoR14oR15i2552R16i2564R17R38gR19r175R20jR21:1:1oR0y12:depthTextureR9i-271R5r104R11r175ggoR14oR15i2569R16i2571R17R38gR19r153R20jR21:1:1oR0R30R9i-289R5r23R11r153gghghggoR14oR15i2579R16i2645R17R38gR19r3R20jR21:7:2oR0y4:tempR9i-306R5r23R11r166goR14oR15i2590R16i2644R17R38gR19r166R20jR21:5:3r92oR14oR15i2590R16i2620R17R38gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i2590R16i2594R17R38gR19r77R20jR21:2:1r78gaoR14oR15i2595R16i2609R17R38gR19r177R20jR21:8:2oR14oR15i2595R16i2605R17R38gR19jR4:14:1aoR3r177R12aoR0R30R11r177ghghR20jR21:2:1jR33:57:0gaoR14oR15i2606R16i2608R17R38gR19r153R20jR21:1:1r1502ghgoR14oR15i2611R16i2616R17R38gR19r83R20jR21:1:1r1478goR14oR15i2618R16i2619R17R38gR19r83R20jR21:0:1jR36:3:1i1ghgoR14oR15i2623R16i2644R17R38gR19jR4:7:0R20jR21:1:1oR0y21:cameraInverseViewProjR9i-269R5r104R11r1545ggggoR14oR15i2650R16i2683R17R38gR19r3R20jR21:7:2oR0y8:originWSR9i-307R5r23R11jR4:5:2i3r16goR14oR15i2665R16i2682R17R38gR19r1553R20jR21:5:3jR23:2:0oR14oR15i2665R16i2673R17R38gR19r1553R20jR21:9:2oR14oR15i2665R16i2669R17R38gR19r166R20jR21:1:1r1509gar88r99r1446hgoR14oR15i2676R16i2682R17R38gR19r83R20jR21:9:2oR14oR15i2676R16i2680R17R38gR19r166R20jR21:1:1r1509gar1377hgggoR14oR15i2688R16i2703R17R38gR19r3R20jR21:12:1oR14oR15i2695R16i2703R17R38gR19r1553R20jR21:1:1r1552gghgR12ar1502hghy4:varsar46r103r22r32r40r1546r184r1498r276r636r592r315r307r1353r1364r1384r134oR0y9:hasNormalR40ajR41:0:1nhR9i-281R5r104R11r133gr248r685r724r820r5r58r121r155hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey15:h3d.shader.Blury4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-286R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini330y3:maxi396y4:filey77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FScreenShader.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i336R16i361R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i336R16i348R17R18gR19r17R20jR21:1:1oR0y5:colorR9i-266y6:parentoR0y6:outputR9i-264R5jR10:4:0R11jR4:13:1aoR0y8:positionR9i-265R25r22R5r23R11jR4:5:2i4r16gr21hgR5r23R11r17ggoR14oR15i351R16i361R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y10:pixelColorR9i-267R5r23R11r31gggoR14oR15i367R16i390R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i367R16i379R17R18gR19r37R20jR21:1:1oR0y12:calculatedUVR9i-268R5r23R11r37ggoR14oR15i382R16i390R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y2:uvR9i-262R25oR0y5:inputR9i-260R5jR10:1:0R11jR4:13:1aoR0R27R9i-261R25r46R5r47R11jR4:5:2i2r16gr45hgR5r47R11r44ggghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-287R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i420R16i504R17R18gR19r3R20jR21:4:1aoR14oR15i426R16i498R17R18gR19r26R20jR21:5:3r18oR14oR15i426R16i441R17R18gR19r26R20jR21:1:1r25goR14oR15i444R16i498R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i444R16i448R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i449R16i465R17R18gR19jR4:3:0R20jR21:9:2oR14oR15i449R16i463R17R18gR19r50R20jR21:1:1r49gajy14:hxsl.Component:0:0hgoR14oR15i467R16i491R17R18gR19r83R20jR21:5:3jR23:1:0oR14oR15i467R16i483R17R18gR19r83R20jR21:9:2oR14oR15i467R16i481R17R18gR19r50R20jR21:1:1r49gajR34:1:0hgoR14oR15i486R16i491R17R18gR19r83R20jR21:1:1oR0y5:flipYR9i-263R5jR10:2:0R11r83gggoR14oR15i493R16i494R17R18gR19r83R20jR21:0:1jy10:hxsl.Const:3:1zgoR14oR15i496R16i497R17R18gR19r83R20jR21:0:1jR36:3:1i1ghgghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-288R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i767R16i2480R17y69:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FBlur.hxgR19r3R20jR21:4:1aoR14oR15i773R16i2220R17R38gR19r3R20jR21:10:3oR14oR15i777R16i793R17R38gR19jR4:2:0R20jR21:1:1oR0y16:isDepthDependanty10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-280R5r104R11r133ggoR14oR15i796R16i1415R17R38gR19r3R20jR21:4:1aoR14oR15i803R16i836R17R38gR19r3R20jR21:7:2oR0y4:pcurR9i-291R5r23R11jR4:5:2i3r16goR14oR15i814R16i835R17R38gR19r144R20jR21:8:2oR14oR15i814R16i825R17R38gR19jR4:14:1aoR3r144R12aoR0R30R11jR4:5:2i2r16ghghR20jR21:1:1oR0y11:getPositionR9i-290R5r6R11r154ggaoR14oR15i826R16i834R17R38gR19r44R20jR21:1:1r45ghggoR14oR15i842R16i875R17R38gR19r3R20jR21:7:2oR0y4:ccurR9i-292R5r23R11jR4:5:2i4r16goR14oR15i853R16i874R17R38gR19r166R20jR21:8:2oR14oR15i853R16i860R17R38gR19jR4:14:1aoR3r166R12aoR0y1:_R11jR4:10:0goR0R30R11jR4:5:2i2r16ghghR20jR21:2:1jR33:33:0gaoR14oR15i853R16i860R17R38gR19r175R20jR21:1:1oR0y7:textureR9i-270R5r104R11r175ggoR14oR15i865R16i873R17R38gR19r44R20jR21:1:1r45ghggoR14oR15i881R16i910R17R38gR19r3R20jR21:7:2oR0R24R9i-293R5r23R11jR4:5:2i4r16goR14oR15i893R16i909R17R38gR19r194R20jR21:8:2oR14oR15i893R16i897R17R38gR19r77R20jR21:2:1r78gaoR14oR15i898R16i899R17R38gR19r83R20jR21:0:1jR36:3:1zgoR14oR15i901R16i902R17R38gR19r83R20jR21:0:1jR36:3:1zgoR14oR15i904R16i905R17R38gR19r83R20jR21:0:1jR36:3:1zgoR14oR15i907R16i908R17R38gR19r83R20jR21:0:1jR36:3:1zghggoR14oR15i916R16i969R17R38gR19r3R20jR21:7:2oR0y4:ncurR9i-294R5r23R11jR4:5:2i3r16goR14oR15i927R16i968R17R38gR19r222R20jR21:8:2oR14oR15i927R16i939R17R38gR19jR4:14:1aoR3r222R12aoR0y5:valueR11r166ghghR20jR21:2:1jR33:55:0gaoR14oR15i940R16i967R17R38gR19r166R20jR21:8:2oR14oR15i940R16i953R17R38gR19jR4:14:1aoR3r166R12aoR0R45R11r175gr176hghR20jR21:2:1r179gaoR14oR15i940R16i953R17R38gR19r175R20jR21:1:1oR0y13:normalTextureR9i-282R5r104R11r175ggoR14oR15i958R16i966R17R38gR19r44R20jR21:1:1r45ghghggoR14oR15i975R16i1384R17R38gR19r3R20jR21:20:3y6:unrollahoR14oR15i983R16i1384R17R38gR19r3R20jR21:13:3oR0y1:iR9i-295R5r23R11jR4:1:0goR14oR15i993R16i1015R17R38gR19jR4:15:2r262jy13:hxsl.SizeDecl:0:1zR20jR21:5:3jR23:21:0oR14oR15i993R16i1008R17R38gR19r262R20jR21:5:3jR23:0:0oR14oR15i993R16i1001R17R38gR19r262R20jR21:6:2jy15:haxe.macro.Unop:3:0oR14oR15i994R16i1001R17R38gR19r262R20jR21:1:1oR0y7:QualityR40ajR41:0:1nhR9i-272R5r104R11r262gggoR14oR15i1004R16i1008R17R38gR19r262R20jR21:0:1jR36:2:1i1ggoR14oR15i1008R16i1015R17R38gR19r262R20jR21:1:1r276ggoR14oR15i1018R16i1384R17R38gR19r3R20jR21:4:1aoR14oR15i1026R16i1078R17R38gR19r3R20jR21:7:2oR0R30R9i-296R5r23R11jR4:5:2i2r16goR14oR15i1035R16i1077R17R38gR19r296R20jR21:5:3r270oR14oR15i1035R16i1043R17R38gR19r44R20jR21:1:1r45goR14oR15i1046R16i1077R17R38gR19jR4:5:2i2r16R20jR21:5:3r92oR14oR15i1046R16i1051R17R38gR19r304R20jR21:1:1oR0y5:pixelR9i-276R5r104R11r304ggoR14oR15i1054R16i1077R17R38gR19r83R20jR21:16:2oR14oR15i1054R16i1061R17R38gR19jR4:15:2r83jR52:1:1r276R20jR21:1:1oR0y7:offsetsR9i-275R5r104R11r314ggoR14oR15i1062R16i1076R17R38gR19r262R20jR21:10:3oR14oR15i1062R16i1067R17R38gR19r133R20jR21:5:3jR23:9:0oR14oR15i1062R16i1063R17R38gR19r262R20jR21:1:1r261goR14oR15i1066R16i1067R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i1070R16i1072R17R38gR19r262R20jR21:6:2r273oR14oR15i1071R16i1072R17R38gR19r262R20jR21:1:1r261ggoR14oR15i1075R16i1076R17R38gR19r262R20jR21:1:1r261ggggggoR14oR15i1085R16i1109R17R38gR19r3R20jR21:7:2oR0y1:cR9i-297R5r23R11r166goR14oR15i1093R16i1108R17R38gR19r166R20jR21:8:2oR14oR15i1093R16i1100R17R38gR19jR4:14:1aoR3r166R12aoR0R45R11r175gr176hghR20jR21:2:1r179gaoR14oR15i1093R16i1100R17R38gR19r175R20jR21:1:1r184goR14oR15i1105R16i1107R17R38gR19r296R20jR21:1:1r295ghggoR14oR15i1116R16i1140R17R38gR19r3R20jR21:7:2oR0R14R9i-298R5r23R11r144goR14oR15i1124R16i1139R17R38gR19r144R20jR21:8:2oR14oR15i1124R16i1135R17R38gR19r154R20jR21:1:1r155gaoR14oR15i1136R16i1138R17R38gR19r296R20jR21:1:1r295ghggoR14oR15i1147R16i1180R17R38gR19r3R20jR21:7:2oR0y1:dR9i-299R5r23R11r83goR14oR15i1155R16i1179R17R38gR19r83R20jR21:8:2oR14oR15i1155R16i1165R17R38gR19jR4:14:1aoR3r83R12aoR0R45R11jR4:5:2i3r16goR0y1:bR11r222ghghR20jR21:2:1jR33:29:0gaoR14oR15i1155R16i1165R17R38gR19r391R20jR21:3:1oR14oR15i1156R16i1164R17R38gR19r391R20jR21:5:3jR23:3:0oR14oR15i1156R16i1157R17R38gR19r144R20jR21:1:1r368goR14oR15i1160R16i1164R17R38gR19r144R20jR21:1:1r143gggoR14oR15i1170R16i1178R17R38gR19jR4:5:2i3r16R20jR21:5:3r401oR14oR15i1170R16i1171R17R38gR19r144R20jR21:1:1r368goR14oR15i1174R16i1178R17R38gR19r144R20jR21:1:1r143gghggoR14oR15i1187R16i1231R17R38gR19r3R20jR21:7:2oR0y1:nR9i-300R5r23R11r222goR14oR15i1195R16i1230R17R38gR19r222R20jR21:8:2oR14oR15i1195R16i1207R17R38gR19r231R20jR21:2:1r232gaoR14oR15i1208R16i1229R17R38gR19r166R20jR21:8:2oR14oR15i1208R16i1221R17R38gR19jR4:14:1aoR3r166R12aoR0R45R11r175gr176hghR20jR21:2:1r179gaoR14oR15i1208R16i1221R17R38gR19r175R20jR21:1:1r248goR14oR15i1226R16i1228R17R38gR19r296R20jR21:1:1r295ghghggoR14oR15i1240R16i1269R17R38gR19r166R20jR21:5:3r18oR14oR15i1240R16i1241R17R38gR19r166R20jR21:1:1r346goR14oR15i1244R16i1269R17R38gR19r166R20jR21:8:2oR14oR15i1244R16i1247R17R38gR19jR4:14:1aoR3r166R12aoR0y1:xR11r166goR0y1:yR11r166goR0y1:aR11r83ghghR20jR21:2:1jR33:24:0gaoR14oR15i1248R16i1252R17R38gR19r166R20jR21:1:1r165goR14oR15i1254R16i1255R17R38gR19r166R20jR21:1:1r346goR14oR15i1257R16i1268R17R38gR19r83R20jR21:8:2oR14oR15i1257R16i1261R17R38gR19jR4:14:1aoR3r83R12aoR0R45R11r222gr392hghR20jR21:2:1r394gaoR14oR15i1257R16i1261R17R38gR19r222R20jR21:1:1r221goR14oR15i1266R16i1267R17R38gR19r222R20jR21:1:1r424ghghggoR14oR15i1277R16i1333R17R38gR19r166R20jR21:5:3r18oR14oR15i1277R16i1278R17R38gR19r166R20jR21:1:1r346goR14oR15i1281R16i1333R17R38gR19r166R20jR21:8:2oR14oR15i1281R16i1284R17R38gR19jR4:14:1ar461hR20jR21:2:1r467gaoR14oR15i1285R16i1286R17R38gR19r166R20jR21:1:1r346goR14oR15i1288R16i1292R17R38gR19r166R20jR21:1:1r165goR14oR15i1294R16i1332R17R38gR19r83R20jR21:8:2oR14oR15i1294R16i1324R17R38gR19jR4:14:1aoR3r83R12aoR0R45R11r83goR0R59R11r83ghghR20jR21:2:1jR33:21:0gaoR14oR15i1294R16i1324R17R38gR19r83R20jR21:3:1oR14oR15i1295R16i1323R17R38gR19r83R20jR21:5:3r92oR14oR15i1295R16i1314R17R38gR19r83R20jR21:8:2oR14oR15i1295R16i1306R17R38gR19jR4:14:1aoR3r83R12aoR0R45R11r83gr523hghR20jR21:2:1jR33:22:0gaoR14oR15i1295R16i1306R17R38gR19r83R20jR21:3:1oR14oR15i1296R16i1305R17R38gR19r83R20jR21:5:3r401oR14oR15i1296R16i1297R17R38gR19r83R20jR21:1:1r382goR14oR15i1300R16i1305R17R38gR19r83R20jR21:0:1jR36:3:1d0.001gggoR14oR15i1311R16i1313R17R38gR19r83R20jR21:0:1jR36:3:1d0ghgoR14oR15i1317R16i1323R17R38gR19r83R20jR21:0:1jR36:3:1i100000gggoR14oR15i1329R16i1331R17R38gR19r83R20jR21:0:1jR36:3:1d1ghghggoR14oR15i1341R16i1376R17R38gR19r194R20jR21:5:3jR23:20:1r270oR14oR15i1341R16i1346R17R38gR19r194R20jR21:1:1r193goR14oR15i1350R16i1376R17R38gR19r166R20jR21:5:3r92oR14oR15i1350R16i1351R17R38gR19r166R20jR21:1:1r346goR14oR15i1354R16i1376R17R38gR19r83R20jR21:16:2oR14oR15i1354R16i1360R17R38gR19jR4:15:2r83jR52:1:1r276R20jR21:1:1oR0y6:valuesR9i-274R5r104R11r591ggoR14oR15i1361R16i1375R17R38gR19r262R20jR21:10:3oR14oR15i1361R16i1366R17R38gR19r133R20jR21:5:3r321oR14oR15i1361R16i1362R17R38gR19r262R20jR21:1:1r261goR14oR15i1365R16i1366R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i1369R16i1371R17R38gR19r262R20jR21:6:2r273oR14oR15i1370R16i1371R17R38gR19r262R20jR21:1:1r261ggoR14oR15i1374R16i1375R17R38gR19r262R20jR21:1:1r261ggggghgggoR14oR15i1390R16i1408R17R38gR19r31R20jR21:5:3r18oR14oR15i1390R16i1400R17R38gR19r31R20jR21:1:1r32goR14oR15i1403R16i1408R17R38gR19r194R20jR21:1:1r193gghgoR14oR15i1425R16i2220R17R38gR19r3R20jR21:10:3oR14oR15i1429R16i1436R17R38gR19r133R20jR21:1:1oR0y7:isDepthR40ajR41:0:1nhR9i-273R5r104R11r133ggoR14oR15i1439R16i1834R17R38gR19r3R20jR21:4:1aoR14oR15i1446R16i1459R17R38gR19r3R20jR21:7:2oR0y3:valR9i-301R5r23R11r83goR14oR15i1456R16i1458R17R38gR19r83R20jR21:0:1jR36:3:1d0ggoR14oR15i1465R16i1784R17R38gR19r3R20jR21:20:3R50ahoR14oR15i1473R16i1784R17R38gR19r3R20jR21:13:3oR0R51R9i-302R5r23R11r262goR14oR15i1483R16i1505R17R38gR19jR4:15:2r262jR52:0:1zR20jR21:5:3r267oR14oR15i1483R16i1498R17R38gR19r262R20jR21:5:3r270oR14oR15i1483R16i1491R17R38gR19r262R20jR21:6:2r273oR14oR15i1484R16i1491R17R38gR19r262R20jR21:1:1r276ggoR14oR15i1494R16i1498R17R38gR19r262R20jR21:0:1jR36:2:1i1ggoR14oR15i1498R16i1505R17R38gR19r262R20jR21:1:1r276ggoR14oR15i1507R16i1784R17R38gR19r3R20jR21:4:1aoR14oR15i1515R16i1776R17R38gR19r3R20jR21:10:3oR14oR15i1519R16i1525R17R38gR19r133R20jR21:1:1oR0y6:isCubeR40ajR41:0:1nhR9i-283R5r104R11r133ggoR14oR15i1528R16i1664R17R38gR19r83R20jR21:5:3jR23:20:1r270oR14oR15i1528R16i1531R17R38gR19r83R20jR21:1:1r645goR14oR15i1535R16i1664R17R38gR19r83R20jR21:5:3r92oR14oR15i1535R16i1639R17R38gR19r83R20jR21:8:2oR14oR15i1535R16i1541R17R38gR19jR4:14:1aoR3r83R12aoR0R48R11r166ghghR20jR21:2:1jR33:53:0gaoR14oR15i1542R16i1638R17R38gR19r166R20jR21:8:2oR14oR15i1542R16i1553R17R38gR19jR4:14:1aoR3r166R12aoR0R45R11jR4:12:0goR0y6:normalR11r222ghghR20jR21:2:1r179gaoR14oR15i1542R16i1553R17R38gR19r717R20jR21:1:1oR0y11:cubeTextureR9i-284R5r104R11r717ggoR14oR15i1558R16i1637R17R38gR19r222R20jR21:5:3r92oR14oR15i1558R16i1627R17R38gR19jR4:5:2i3r16R20jR21:8:2oR14oR15i1558R16i1562R17R38gR19jR4:14:1ahR20jR21:2:1jR33:39:0gaoR14oR15i1563R16i1623R17R38gR19jR4:5:2i2r16R20jR21:5:3r401oR14oR15i1563R16i1617R17R38gR19r740R20jR21:5:3r92oR14oR15i1563R16i1612R17R38gR19r740R20jR21:3:1oR14oR15i1564R16i1610R17R38gR19r740R20jR21:5:3r270oR14oR15i1564R16i1572R17R38gR19r44R20jR21:1:1r45goR14oR15i1575R16i1610R17R38gR19r304R20jR21:5:3r92oR14oR15i1575R16i1606R17R38gR19r304R20jR21:5:3r92oR14oR15i1575R16i1580R17R38gR19r304R20jR21:1:1r307goR14oR15i1583R16i1606R17R38gR19r83R20jR21:16:2oR14oR15i1583R16i1590R17R38gR19r314R20jR21:1:1r315goR14oR15i1591R16i1605R17R38gR19r262R20jR21:10:3oR14oR15i1591R16i1596R17R38gR19r133R20jR21:5:3r321oR14oR15i1591R16i1592R17R38gR19r262R20jR21:1:1r656goR14oR15i1595R16i1596R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i1599R16i1601R17R38gR19r262R20jR21:6:2r273oR14oR15i1600R16i1601R17R38gR19r262R20jR21:1:1r656ggoR14oR15i1604R16i1605R17R38gR19r262R20jR21:1:1r656ggggoR14oR15i1609R16i1610R17R38gR19r83R20jR21:8:2oR14oR15i1609R16i1610R17R38gR19jR4:14:1ahR20jR21:2:1jR33:36:0gaoR14oR15i1609R16i1610R17R38gR19r262R20jR21:1:1r656ghggggoR14oR15i1614R16i1617R17R38gR19r83R20jR21:0:1jR36:3:1d2ggoR14oR15i1620R16i1623R17R38gR19r83R20jR21:0:1jR36:3:1d1ggoR14oR15i1625R16i1626R17R38gR19r83R20jR21:0:1jR36:3:1i1ghgoR14oR15i1630R16i1637R17R38gR19jR4:6:0R20jR21:1:1oR0y7:cubeDirR9i-285R5r104R11r819ggghghgoR14oR15i1642R16i1664R17R38gR19r83R20jR21:16:2oR14oR15i1642R16i1648R17R38gR19r591R20jR21:1:1r592goR14oR15i1649R16i1663R17R38gR19r262R20jR21:10:3oR14oR15i1649R16i1654R17R38gR19r133R20jR21:5:3r321oR14oR15i1649R16i1650R17R38gR19r262R20jR21:1:1r656goR14oR15i1653R16i1654R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i1657R16i1659R17R38gR19r262R20jR21:6:2r273oR14oR15i1658R16i1659R17R38gR19r262R20jR21:1:1r656ggoR14oR15i1662R16i1663R17R38gR19r262R20jR21:1:1r656gggggoR14oR15i1677R16i1776R17R38gR19r83R20jR21:5:3jR23:20:1r270oR14oR15i1677R16i1680R17R38gR19r83R20jR21:1:1r645goR14oR15i1684R16i1776R17R38gR19r83R20jR21:5:3r92oR14oR15i1684R16i1751R17R38gR19r83R20jR21:8:2oR14oR15i1684R16i1690R17R38gR19r705R20jR21:2:1r706gaoR14oR15i1691R16i1750R17R38gR19r166R20jR21:8:2oR14oR15i1691R16i1698R17R38gR19jR4:14:1aoR3r166R12aoR0R45R11r175gr176hghR20jR21:2:1r179gaoR14oR15i1691R16i1698R17R38gR19r175R20jR21:1:1r184goR14oR15i1703R16i1749R17R38gR19jR4:5:2i2r16R20jR21:5:3r270oR14oR15i1703R16i1711R17R38gR19r44R20jR21:1:1r45goR14oR15i1714R16i1749R17R38gR19r304R20jR21:5:3r92oR14oR15i1714R16i1745R17R38gR19r304R20jR21:5:3r92oR14oR15i1714R16i1719R17R38gR19r304R20jR21:1:1r307goR14oR15i1722R16i1745R17R38gR19r83R20jR21:16:2oR14oR15i1722R16i1729R17R38gR19r314R20jR21:1:1r315goR14oR15i1730R16i1744R17R38gR19r262R20jR21:10:3oR14oR15i1730R16i1735R17R38gR19r133R20jR21:5:3r321oR14oR15i1730R16i1731R17R38gR19r262R20jR21:1:1r656goR14oR15i1734R16i1735R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i1738R16i1740R17R38gR19r262R20jR21:6:2r273oR14oR15i1739R16i1740R17R38gR19r262R20jR21:1:1r656ggoR14oR15i1743R16i1744R17R38gR19r262R20jR21:1:1r656ggggoR14oR15i1748R16i1749R17R38gR19r83R20jR21:8:2oR14oR15i1748R16i1749R17R38gR19jR4:14:1ahR20jR21:2:1r792gaoR14oR15i1748R16i1749R17R38gR19r262R20jR21:1:1r656ghggghghgoR14oR15i1754R16i1776R17R38gR19r83R20jR21:16:2oR14oR15i1754R16i1760R17R38gR19r591R20jR21:1:1r592goR14oR15i1761R16i1775R17R38gR19r262R20jR21:10:3oR14oR15i1761R16i1766R17R38gR19r133R20jR21:5:3r321oR14oR15i1761R16i1762R17R38gR19r262R20jR21:1:1r656goR14oR15i1765R16i1766R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i1769R16i1771R17R38gR19r262R20jR21:6:2r273oR14oR15i1770R16i1771R17R38gR19r262R20jR21:1:1r656ggoR14oR15i1774R16i1775R17R38gR19r262R20jR21:1:1r656gggggghgggoR14oR15i1790R16i1827R17R38gR19r31R20jR21:5:3r18oR14oR15i1790R16i1800R17R38gR19r31R20jR21:1:1r32goR14oR15i1803R16i1827R17R38gR19r166R20jR21:8:2oR14oR15i1803R16i1807R17R38gR19jR4:14:1aoR3r166R12aoR0R48R11r83ghghR20jR21:2:1jR33:52:0gaoR14oR15i1808R16i1826R17R38gR19r83R20jR21:8:2oR14oR15i1808R16i1811R17R38gR19jR4:14:1aoR3r83R12aoR0R45R11r83gr523hghR20jR21:2:1r525gaoR14oR15i1808R16i1811R17R38gR19r83R20jR21:1:1r645goR14oR15i1816R16i1825R17R38gR19r83R20jR21:0:1jR36:3:1d0.9999999ghghgghgoR14oR15i1840R16i2220R17R38gR19r3R20jR21:4:1aoR14oR15i1847R16i1876R17R38gR19r3R20jR21:7:2oR0R24R9i-303R5r23R11jR4:5:2i4r16goR14oR15i1859R16i1875R17R38gR19r1020R20jR21:8:2oR14oR15i1859R16i1863R17R38gR19r77R20jR21:2:1r78gaoR14oR15i1864R16i1865R17R38gR19r83R20jR21:0:1jR36:3:1zgoR14oR15i1867R16i1868R17R38gR19r83R20jR21:0:1jR36:3:1zgoR14oR15i1870R16i1871R17R38gR19r83R20jR21:0:1jR36:3:1zgoR14oR15i1873R16i1874R17R38gR19r83R20jR21:0:1jR36:3:1zghggoR14oR15i1882R16i2189R17R38gR19r3R20jR21:20:3R50ahoR14oR15i1890R16i2189R17R38gR19r3R20jR21:13:3oR0R51R9i-304R5r23R11r262goR14oR15i1900R16i1922R17R38gR19jR4:15:2r262jR52:0:1zR20jR21:5:3r267oR14oR15i1900R16i1915R17R38gR19r262R20jR21:5:3r270oR14oR15i1900R16i1908R17R38gR19r262R20jR21:6:2r273oR14oR15i1901R16i1908R17R38gR19r262R20jR21:1:1r276ggoR14oR15i1911R16i1915R17R38gR19r262R20jR21:0:1jR36:2:1i1ggoR14oR15i1915R16i1922R17R38gR19r262R20jR21:1:1r276ggoR14oR15i1924R16i2189R17R38gR19r3R20jR21:4:1aoR14oR15i1932R16i2181R17R38gR19r3R20jR21:10:3oR14oR15i1936R16i1942R17R38gR19r133R20jR21:1:1r685goR14oR15i1945R16i2075R17R38gR19r1020R20jR21:5:3jR23:20:1r270oR14oR15i1945R16i1950R17R38gR19r1020R20jR21:1:1r1019goR14oR15i1954R16i2075R17R38gR19r166R20jR21:5:3r92oR14oR15i1954R16i2050R17R38gR19r166R20jR21:8:2oR14oR15i1954R16i1965R17R38gR19jR4:14:1aoR3r166R12aoR0R45R11r717gr718hghR20jR21:2:1r179gaoR14oR15i1954R16i1965R17R38gR19r717R20jR21:1:1r724goR14oR15i1970R16i2049R17R38gR19r222R20jR21:5:3r92oR14oR15i1970R16i2039R17R38gR19jR4:5:2i3r16R20jR21:8:2oR14oR15i1970R16i1974R17R38gR19r734R20jR21:2:1r735gaoR14oR15i1975R16i2035R17R38gR19jR4:5:2i2r16R20jR21:5:3r401oR14oR15i1975R16i2029R17R38gR19r1113R20jR21:5:3r92oR14oR15i1975R16i2024R17R38gR19r1113R20jR21:3:1oR14oR15i1976R16i2022R17R38gR19r1113R20jR21:5:3r270oR14oR15i1976R16i1984R17R38gR19r44R20jR21:1:1r45goR14oR15i1987R16i2022R17R38gR19r304R20jR21:5:3r92oR14oR15i1987R16i2018R17R38gR19r304R20jR21:5:3r92oR14oR15i1987R16i1992R17R38gR19r304R20jR21:1:1r307goR14oR15i1995R16i2018R17R38gR19r83R20jR21:16:2oR14oR15i1995R16i2002R17R38gR19r314R20jR21:1:1r315goR14oR15i2003R16i2017R17R38gR19r262R20jR21:10:3oR14oR15i2003R16i2008R17R38gR19r133R20jR21:5:3r321oR14oR15i2003R16i2004R17R38gR19r262R20jR21:1:1r1050goR14oR15i2007R16i2008R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i2011R16i2013R17R38gR19r262R20jR21:6:2r273oR14oR15i2012R16i2013R17R38gR19r262R20jR21:1:1r1050ggoR14oR15i2016R16i2017R17R38gR19r262R20jR21:1:1r1050ggggoR14oR15i2021R16i2022R17R38gR19r83R20jR21:8:2oR14oR15i2021R16i2022R17R38gR19jR4:14:1ahR20jR21:2:1r792gaoR14oR15i2021R16i2022R17R38gR19r262R20jR21:1:1r1050ghggggoR14oR15i2026R16i2029R17R38gR19r83R20jR21:0:1jR36:3:1d2ggoR14oR15i2032R16i2035R17R38gR19r83R20jR21:0:1jR36:3:1d1ggoR14oR15i2037R16i2038R17R38gR19r83R20jR21:0:1jR36:3:1i1ghgoR14oR15i2042R16i2049R17R38gR19r819R20jR21:1:1r820gghgoR14oR15i2053R16i2075R17R38gR19r83R20jR21:16:2oR14oR15i2053R16i2059R17R38gR19r591R20jR21:1:1r592goR14oR15i2060R16i2074R17R38gR19r262R20jR21:10:3oR14oR15i2060R16i2065R17R38gR19r133R20jR21:5:3r321oR14oR15i2060R16i2061R17R38gR19r262R20jR21:1:1r1050goR14oR15i2064R16i2065R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i2068R16i2070R17R38gR19r262R20jR21:6:2r273oR14oR15i2069R16i2070R17R38gR19r262R20jR21:1:1r1050ggoR14oR15i2073R16i2074R17R38gR19r262R20jR21:1:1r1050gggggoR14oR15i2088R16i2181R17R38gR19r1020R20jR21:5:3jR23:20:1r270oR14oR15i2088R16i2093R17R38gR19r1020R20jR21:1:1r1019goR14oR15i2097R16i2181R17R38gR19r166R20jR21:5:3r92oR14oR15i2097R16i2156R17R38gR19r166R20jR21:8:2oR14oR15i2097R16i2104R17R38gR19jR4:14:1aoR3r166R12aoR0R45R11r175gr176hghR20jR21:2:1r179gaoR14oR15i2097R16i2104R17R38gR19r175R20jR21:1:1r184goR14oR15i2109R16i2155R17R38gR19jR4:5:2i2r16R20jR21:5:3r270oR14oR15i2109R16i2117R17R38gR19r44R20jR21:1:1r45goR14oR15i2120R16i2155R17R38gR19r304R20jR21:5:3r92oR14oR15i2120R16i2151R17R38gR19r304R20jR21:5:3r92oR14oR15i2120R16i2125R17R38gR19r304R20jR21:1:1r307goR14oR15i2128R16i2151R17R38gR19r83R20jR21:16:2oR14oR15i2128R16i2135R17R38gR19r314R20jR21:1:1r315goR14oR15i2136R16i2150R17R38gR19r262R20jR21:10:3oR14oR15i2136R16i2141R17R38gR19r133R20jR21:5:3r321oR14oR15i2136R16i2137R17R38gR19r262R20jR21:1:1r1050goR14oR15i2140R16i2141R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i2144R16i2146R17R38gR19r262R20jR21:6:2r273oR14oR15i2145R16i2146R17R38gR19r262R20jR21:1:1r1050ggoR14oR15i2149R16i2150R17R38gR19r262R20jR21:1:1r1050ggggoR14oR15i2154R16i2155R17R38gR19r83R20jR21:8:2oR14oR15i2154R16i2155R17R38gR19jR4:14:1ahR20jR21:2:1r792gaoR14oR15i2154R16i2155R17R38gR19r262R20jR21:1:1r1050ghggghgoR14oR15i2159R16i2181R17R38gR19r83R20jR21:16:2oR14oR15i2159R16i2165R17R38gR19r591R20jR21:1:1r592goR14oR15i2166R16i2180R17R38gR19r262R20jR21:10:3oR14oR15i2166R16i2171R17R38gR19r133R20jR21:5:3r321oR14oR15i2166R16i2167R17R38gR19r262R20jR21:1:1r1050goR14oR15i2170R16i2171R17R38gR19r262R20jR21:0:1jR36:2:1zggoR14oR15i2174R16i2176R17R38gR19r262R20jR21:6:2r273oR14oR15i2175R16i2176R17R38gR19r262R20jR21:1:1r1050ggoR14oR15i2179R16i2180R17R38gR19r262R20jR21:1:1r1050gggggghgggoR14oR15i2195R16i2213R17R38gR19r31R20jR21:5:3r18oR14oR15i2195R16i2205R17R38gR19r31R20jR21:1:1r32goR14oR15i2208R16i2213R17R38gR19r1020R20jR21:1:1r1019gghgggoR14oR15i2225R16i2475R17R38gR19r3R20jR21:10:3oR14oR15i2229R16i2242R17R38gR19r133R20jR21:1:1oR0y13:hasFixedColorR40ajR41:0:1nhR9i-277R5r104R11r133ggoR14oR15i2245R16i2475R17R38gR19r3R20jR21:4:1aoR14oR15i2252R16i2380R17R38gR19r3R20jR21:10:3oR14oR15i2256R16i2272R17R38gR19r133R20jR21:1:1oR0y16:smoothFixedColorR40ajR41:0:1nhR9i-278R5r104R11r133ggoR14oR15i2281R16i2309R17R38gR19r83R20jR21:5:3jR23:20:1r92oR14oR15i2281R16i2293R17R38gR19r83R20jR21:9:2oR14oR15i2281R16i2291R17R38gR19r31R20jR21:1:1r32gajR34:3:0hgoR14oR15i2297R16i2309R17R38gR19r83R20jR21:9:2oR14oR15i2297R16i2307R17R38gR19jR4:5:2i4r16R20jR21:1:1oR0y10:fixedColorR9i-279R5r104R11r1383ggar1377hggoR14oR15i2327R16i2380R17R38gR19r83R20jR21:5:3r18oR14oR15i2327R16i2339R17R38gR19r83R20jR21:9:2oR14oR15i2327R16i2337R17R38gR19r31R20jR21:1:1r32gar1377hgoR14oR15i2342R16i2380R17R38gR19r83R20jR21:5:3r92oR14oR15i2342R16i2354R17R38gR19r83R20jR21:9:2oR14oR15i2342R16i2352R17R38gR19r1383R20jR21:1:1r1384gar1377hgoR14oR15i2357R16i2380R17R38gR19r83R20jR21:8:2oR14oR15i2357R16i2362R17R38gR19jR4:14:1aoR3r83R12aoR0R48R11r133ghghR20jR21:2:1r792gaoR14oR15i2363R16i2379R17R38gR19r133R20jR21:5:3jR23:7:0oR14oR15i2363R16i2375R17R38gR19r83R20jR21:9:2oR14oR15i2363R16i2373R17R38gR19r31R20jR21:1:1r32gar1377hgoR14oR15i2378R16i2379R17R38gR19r83R20jR21:0:1jR36:3:1zgghggggoR14oR15i2387R16i2433R17R38gR19jR4:5:2i3r16R20jR21:5:3r18oR14oR15i2387R16i2401R17R38gR19r1439R20jR21:9:2oR14oR15i2387R16i2397R17R38gR19r31R20jR21:1:1r32gar88r99jR34:2:0hgoR14oR15i2404R16i2433R17R38gR19jR4:5:2i3r16R20jR21:5:3r92oR14oR15i2404R16i2418R17R38gR19r1450R20jR21:9:2oR14oR15i2404R16i2414R17R38gR19r1383R20jR21:1:1r1384gar88r99r1446hgoR14oR15i2421R16i2433R17R38gR19r83R20jR21:9:2oR14oR15i2421R16i2431R17R38gR19r31R20jR21:1:1r32gar1377hggghgnghgR12ahgoR3r144R5jR6:3:0R7r155R13oR14oR15i2527R16i2709R17R38gR19r3R20jR21:4:1aoR14oR15i2533R16i2574R17R38gR19r3R20jR21:7:2oR0y5:depthR9i-305R5r23R11r83goR14oR15i2545R16i2573R17R38gR19r83R20jR21:8:2oR14oR15i2545R16i2551R17R38gR19r705R20jR21:2:1r706gaoR14oR15i2552R16i2572R17R38gR19r166R20jR21:8:2oR14oR15i2552R16i2564R17R38gR19jR4:14:1aoR3r166R12aoR0R45R11r175gr176hghR20jR21:2:1r179gaoR14oR15i2552R16i2564R17R38gR19r175R20jR21:1:1oR0y12:depthTextureR9i-271R5r104R11r175ggoR14oR15i2569R16i2571R17R38gR19r153R20jR21:1:1oR0R30R9i-289R5r23R11r153gghghggoR14oR15i2579R16i2645R17R38gR19r3R20jR21:7:2oR0y4:tempR9i-306R5r23R11r166goR14oR15i2590R16i2644R17R38gR19r166R20jR21:5:3r92oR14oR15i2590R16i2620R17R38gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i2590R16i2594R17R38gR19r77R20jR21:2:1r78gaoR14oR15i2595R16i2609R17R38gR19r177R20jR21:8:2oR14oR15i2595R16i2605R17R38gR19jR4:14:1aoR3r177R12aoR0R30R11r177ghghR20jR21:2:1jR33:57:0gaoR14oR15i2606R16i2608R17R38gR19r153R20jR21:1:1r1502ghgoR14oR15i2611R16i2616R17R38gR19r83R20jR21:1:1r1478goR14oR15i2618R16i2619R17R38gR19r83R20jR21:0:1jR36:3:1i1ghgoR14oR15i2623R16i2644R17R38gR19jR4:7:0R20jR21:1:1oR0y21:cameraInverseViewProjR9i-269R5r104R11r1545ggggoR14oR15i2650R16i2683R17R38gR19r3R20jR21:7:2oR0y8:originWSR9i-307R5r23R11jR4:5:2i3r16goR14oR15i2665R16i2682R17R38gR19r1553R20jR21:5:3jR23:2:0oR14oR15i2665R16i2673R17R38gR19r1553R20jR21:9:2oR14oR15i2665R16i2669R17R38gR19r166R20jR21:1:1r1509gar88r99r1446hgoR14oR15i2676R16i2682R17R38gR19r83R20jR21:9:2oR14oR15i2676R16i2680R17R38gR19r166R20jR21:1:1r1509gar1377hgggoR14oR15i2688R16i2703R17R38gR19r3R20jR21:12:1oR14oR15i2695R16i2703R17R38gR19r1553R20jR21:1:1r1552gghgR12ar1502hghy4:varsar46r103r22r32r40r1546r184r1498r276r636r592r315r307r1353r1364r1384r134oR0y9:hasNormalR40ajR41:0:1nhR9i-281R5r104R11r133gr248r685r724r820r5r58r121r155hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<cameraInverseViewProj public="1" get="accessor" set="accessor"><t path="hxsl.Matrix"/></cameraInverseViewProj>
		<cameraInverseViewProj__ expr="new hxsl.Types.Matrix()">
			<t path="hxsl.Matrix"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Matrix()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</cameraInverseViewProj__>
		<get_cameraInverseViewProj get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_cameraInverseViewProj>
		<set_cameraInverseViewProj get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Matrix"/>
				<t path="hxsl.Matrix"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_cameraInverseViewProj>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture>
		<texture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<depthTexture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></depthTexture>
		<depthTexture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</depthTexture__>
		<get_depthTexture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_depthTexture>
		<set_depthTexture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_depthTexture>
		<Quality public="1" get="accessor" set="accessor"><x path="Int"/></Quality>
		<Quality__ expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</Quality__>
		<get_Quality get="inline" set="null" line="5">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_Quality>
		<set_Quality get="inline" set="null" line="5">
			<f a="_v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_Quality>
		<isDepth public="1" get="accessor" set="accessor"><x path="Bool"/></isDepth>
		<isDepth__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</isDepth__>
		<get_isDepth get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isDepth>
		<set_isDepth get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isDepth>
		<values public="1" get="accessor" set="accessor"><c path="Array"><x path="Float"/></c></values>
		<values__ expr="new Array()">
			<c path="Array"><x path="Float"/></c>
			<meta>
				<m n=":value"><e>new Array()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</values__>
		<get_values get="inline" set="null" line="5">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_values>
		<set_values get="inline" set="null" line="5">
			<f a="_v">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_values>
		<offsets public="1" get="accessor" set="accessor"><c path="Array"><x path="Float"/></c></offsets>
		<offsets__ expr="new Array()">
			<c path="Array"><x path="Float"/></c>
			<meta>
				<m n=":value"><e>new Array()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</offsets__>
		<get_offsets get="inline" set="null" line="5">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_offsets>
		<set_offsets get="inline" set="null" line="5">
			<f a="_v">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_offsets>
		<pixel public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></pixel>
		<pixel__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</pixel__>
		<get_pixel get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_pixel>
		<set_pixel get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_pixel>
		<hasFixedColor public="1" get="accessor" set="accessor"><x path="Bool"/></hasFixedColor>
		<hasFixedColor__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</hasFixedColor__>
		<get_hasFixedColor get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_hasFixedColor>
		<set_hasFixedColor get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_hasFixedColor>
		<smoothFixedColor public="1" get="accessor" set="accessor"><x path="Bool"/></smoothFixedColor>
		<smoothFixedColor__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</smoothFixedColor__>
		<get_smoothFixedColor get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_smoothFixedColor>
		<set_smoothFixedColor get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_smoothFixedColor>
		<fixedColor public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></fixedColor>
		<fixedColor__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</fixedColor__>
		<get_fixedColor get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_fixedColor>
		<set_fixedColor get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_fixedColor>
		<isDepthDependant public="1" get="accessor" set="accessor"><x path="Bool"/></isDepthDependant>
		<isDepthDependant__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</isDepthDependant__>
		<get_isDepthDependant get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isDepthDependant>
		<set_isDepthDependant get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isDepthDependant>
		<hasNormal public="1" get="accessor" set="accessor"><x path="Bool"/></hasNormal>
		<hasNormal__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</hasNormal__>
		<get_hasNormal get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_hasNormal>
		<set_hasNormal get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_hasNormal>
		<normalTexture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></normalTexture>
		<normalTexture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</normalTexture__>
		<get_normalTexture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_normalTexture>
		<set_normalTexture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_normalTexture>
		<isCube public="1" get="accessor" set="accessor"><x path="Bool"/></isCube>
		<isCube__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</isCube__>
		<get_isCube get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isCube>
		<set_isCube get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isCube>
		<cubeTexture public="1" get="accessor" set="accessor"><t path="hxsl.SamplerCube"/></cubeTexture>
		<cubeTexture__>
			<t path="hxsl.SamplerCube"/>
			<meta><m n=":noCompletion"/></meta>
		</cubeTexture__>
		<get_cubeTexture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.SamplerCube"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_cubeTexture>
		<set_cubeTexture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.SamplerCube"/>
				<t path="hxsl.SamplerCube"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_cubeTexture>
		<cubeDir public="1" get="accessor" set="accessor"><t path="hxsl.Matrix"/></cubeDir>
		<cubeDir__ expr="new hxsl.Types.Matrix()">
			<t path="hxsl.Matrix"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Matrix()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</cubeDir__>
		<get_cubeDir get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_cubeDir>
		<set_cubeDir get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Matrix"/>
				<t path="hxsl.Matrix"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_cubeDir>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@param var cameraInverseViewProj:Mat4;
	@param var texture:Sampler2D;
	@param var depthTexture:Sampler2D;
	@param @const var Quality:Int;
	@param @const var isDepth:Bool;
	@param var values:Array<Float,Quality>;
	@param var offsets:Array<Float,Quality>;
	@param var pixel:Vec2;
	@const var hasFixedColor:Bool;
	@const var smoothFixedColor:Bool;
	@param var fixedColor:Vec4;
	@param @const var isDepthDependant:Bool;
	@param @const var hasNormal:Bool;
	@param var normalTexture:Sampler2D;
	@param @const var isCube:Bool;
	@param var cubeTexture:SamplerCube;
	@param var cubeDir:Mat3;
	function fragment() {
		if (isDepthDependant) {
			var pcur = getPosition(input.uv);
			var ccur = texture.get(input.uv);
			var color = vec4(0, 0, 0, 0);
			var ncur = unpackNormal(normalTexture.get(input.uv));
			@unroll for (i  in  -Quality + 1 ... Quality) {
				var uv = input.uv + pixel * offsets[i < 0 ? -i : i];
				var c = texture.get(uv);
				var p = getPosition(uv);
				var d = (p - pcur).dot(p - pcur);
				var n = unpackNormal(normalTexture.get(uv));
				c = mix(ccur, c, ncur.dot(n));
				c = mix(c, ccur, ((d - 0.001).max(0.) * 100000).min(1.));
				color += c * values[i < 0 ? -i : i];
			};
			pixelColor = color;
		} else if (isDepth) {
			var val = 0.;
			@unroll for (i  in  -Quality + 1 ... Quality) {
				if (isCube) val += unpack(cubeTexture.get(vec3((input.uv + pixel * offsets[i < 0 ? -i : i] * i) * 2.0 - 1.0, 1) * cubeDir)) * values[i < 0 ? -i : i] else val += unpack(texture.get(input.uv + pixel * offsets[i < 0 ? -i : i] * i)) * values[i < 0 ? -i : i];
			};
			pixelColor = pack(val.min(0.9999999));
		} else {
			var color = vec4(0, 0, 0, 0);
			@unroll for (i  in  -Quality + 1 ... Quality) {
				if (isCube) color += cubeTexture.get(vec3((input.uv + pixel * offsets[i < 0 ? -i : i] * i) * 2.0 - 1.0, 1) * cubeDir) * values[i < 0 ? -i : i] else color += texture.get(input.uv + pixel * offsets[i < 0 ? -i : i] * i) * values[i < 0 ? -i : i];
			};
			pixelColor = color;
		};
		if (hasFixedColor) {
			if (smoothFixedColor) pixelColor.a *= fixedColor.a else pixelColor.a = fixedColor.a * float(pixelColor.a > 0);
			pixelColor.rgb = fixedColor.rgb * pixelColor.a;
		};
	};
	function getPosition(uv:Vec2):Vec3 {
		var depth = unpack(depthTexture.get(uv));
		var temp = vec4(uvToScreen(uv), depth, 1) * cameraInverseViewProj;
		var originWS = temp.xyz / temp.w;
		return originWS;
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<abstract path="h3d.shader.BufferKind" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Buffers.hx" module="h3d.shader.Buffers">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="h3d.shader._Buffers.BufferKind_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Buffers.hx" private="1" module="h3d.shader.Buffers" extern="1">
	<Globals public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
		<x path="h3d.shader.BufferKind"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Globals>
	<Params public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
		<x path="h3d.shader.BufferKind"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Params>
	<Textures public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
		<x path="h3d.shader.BufferKind"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Textures>
	<Buffers public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
		<x path="h3d.shader.BufferKind"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Buffers>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="h3d.shader._Buffers.BufferKind_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Buffers.hx" private="1" module="h3d.shader.Buffers" extern="1">
		<Globals public="1" get="inline" set="null" expr="cast 0" line="4" static="1">
			<x path="h3d.shader.BufferKind"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Globals>
		<Params public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
			<x path="h3d.shader.BufferKind"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Params>
		<Textures public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
			<x path="h3d.shader.BufferKind"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Textures>
		<Buffers public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
			<x path="h3d.shader.BufferKind"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Buffers>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="h3d.shader.ShaderBufferData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Buffers.hx" module="h3d.shader.Buffers"><x path="haxe.ds.Vector"><t path="hxd.impl.Float32"/></x></typedef>
	<class path="h3d.shader.ShaderBuffers" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Buffers.hx" module="h3d.shader.Buffers">
		<globals public="1"><t path="h3d.shader.ShaderBufferData"/></globals>
		<params public="1"><t path="h3d.shader.ShaderBufferData"/></params>
		<tex public="1"><x path="haxe.ds.Vector"><c path="h3d.mat.Texture"/></x></tex>
		<buffers public="1"><x path="haxe.ds.Vector"><c path="h3d.Buffer"/></x></buffers>
		<grow public="1" set="method" line="26"><f a="s">
	<c path="hxsl.RuntimeShaderData"/>
	<x path="Void"/>
</f></grow>
		<new public="1" set="method" line="19"><f a="s">
	<c path="hxsl.RuntimeShaderData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.shader.Buffers" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Buffers.hx">
		<vertex public="1"><c path="h3d.shader.ShaderBuffers"/></vertex>
		<fragment public="1"><c path="h3d.shader.ShaderBuffers"/></fragment>
		<grow public="1" get="inline" set="null" line="49"><f a="s">
	<c path="hxsl.RuntimeShader"/>
	<x path="Void"/>
</f></grow>
		<new public="1" set="method" line="44"><f a="s">
	<c path="hxsl.RuntimeShader"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="h3d.shader.Camera2d" params="" file="./h3d/shader/Camera2d.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey19:h3d.shader.Camera2dy4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:0:0y3:refoR0y6:vertexy2:idi-138R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini343y3:maxi359y4:filey30:.%2Fh3d%2Fshader%2FCamera2d.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1ahgR12ahghy4:varsaoR0y5:inputR9i-108R5jR10:1:0R11jR4:13:1aoR0y8:positionR9i-109y6:parentr17R5r18R11jR4:5:2i2jy12:hxsl.VecType:1:0goR0y2:uvR9i-110R25r17R5r18R11jR4:5:2i2r21goR0y5:colorR9i-111R25r17R5r18R11jR4:5:2i4r21ghgoR0y6:outputR9i-112R5jR10:4:0R11jR4:13:1aoR0R24R9i-113R25r28R5r29R11jR4:5:2i4r21goR0R28R9i-114R25r28R5r29R11jR4:5:2i4r21ghgoR0y4:timeR9i-115R5jR10:0:0R11jR4:3:0goR0y14:spritePositionR9i-118R5r29R11jR4:5:2i4r21goR0y16:absolutePositionR9i-119R5r29R11jR4:5:2i4r21goR0y10:pixelColorR9i-120R5r29R11jR4:5:2i4r21goR0y12:textureColorR9i-121R5r29R11jR4:5:2i4r21goR0y12:calculatedUVR9i-122R5jR10:3:0R11jR4:5:2i2r21goR0y14:outputPositionR9i-135R5r29R11jR4:5:2i4r21goR0y13:cameraMatrixAR9i-136R5jR10:2:0R11jR4:5:2i3r21goR0y13:cameraMatrixBR9i-137R5r53R11jR4:5:2i3r21gr5hg&quot;" line="10" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey19:h3d.shader.Camera2dy4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:0:0y3:refoR0y6:vertexy2:idi-138R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini343y3:maxi359y4:filey30:.%2Fh3d%2Fshader%2FCamera2d.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1ahgR12ahghy4:varsaoR0y5:inputR9i-108R5jR10:1:0R11jR4:13:1aoR0y8:positionR9i-109y6:parentr17R5r18R11jR4:5:2i2jy12:hxsl.VecType:1:0goR0y2:uvR9i-110R25r17R5r18R11jR4:5:2i2r21goR0y5:colorR9i-111R25r17R5r18R11jR4:5:2i4r21ghgoR0y6:outputR9i-112R5jR10:4:0R11jR4:13:1aoR0R24R9i-113R25r28R5r29R11jR4:5:2i4r21goR0R28R9i-114R25r28R5r29R11jR4:5:2i4r21ghgoR0y4:timeR9i-115R5jR10:0:0R11jR4:3:0goR0y14:spritePositionR9i-118R5r29R11jR4:5:2i4r21goR0y16:absolutePositionR9i-119R5r29R11jR4:5:2i4r21goR0y10:pixelColorR9i-120R5r29R11jR4:5:2i4r21goR0y12:textureColorR9i-121R5r29R11jR4:5:2i4r21goR0y12:calculatedUVR9i-122R5jR10:3:0R11jR4:5:2i2r21goR0y14:outputPositionR9i-135R5r29R11jR4:5:2i4r21goR0y13:cameraMatrixAR9i-136R5jR10:2:0R11jR4:5:2i3r21goR0y13:cameraMatrixBR9i-137R5r53R11jR4:5:2i3r21gr5hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<cameraMatrixA public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></cameraMatrixA>
		<cameraMatrixA__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</cameraMatrixA__>
		<get_cameraMatrixA get="inline" set="null" line="10">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_cameraMatrixA>
		<set_cameraMatrixA get="inline" set="null" line="10">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_cameraMatrixA>
		<cameraMatrixB public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></cameraMatrixB>
		<cameraMatrixB__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</cameraMatrixB__>
		<get_cameraMatrixB get="inline" set="null" line="10">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_cameraMatrixB>
		<set_cameraMatrixB get="inline" set="null" line="10">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_cameraMatrixB>
		<updateConstants public="1" set="method" line="10" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="10" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="10" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="10" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":src"><e>{
	@:import h3d.shader.Base2d;
	@param var cameraMatrixA:Vec3;
	@param var cameraMatrixB:Vec3;
	function vertex() { };
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="h3d.shader.ColorAdd" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/ColorAdd.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey19:h3d.shader.ColorAddy4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:1:0y3:refoR0y8:fragmenty2:idi-487R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini164y3:maxi199y4:filey73:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FColorAdd.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i170R16i193R17R18gR19jR4:5:2i3jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:20:1jR23:0:0oR14oR15i170R16i184R17R18gR19r17R20jR21:9:2oR14oR15i170R16i180R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y10:pixelColorR9i-485R5jR10:4:0R11r24ggajy14:hxsl.Component:0:0jR25:1:0jR25:2:0hgoR14oR15i188R16i193R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y5:colorR9i-486R5jR10:2:0R11r35ggghgR12ahghy4:varsar25r36r5hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey19:h3d.shader.ColorAddy4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:1:0y3:refoR0y8:fragmenty2:idi-487R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini164y3:maxi199y4:filey73:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FColorAdd.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i170R16i193R17R18gR19jR4:5:2i3jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:20:1jR23:0:0oR14oR15i170R16i184R17R18gR19r17R20jR21:9:2oR14oR15i170R16i180R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y10:pixelColorR9i-485R5jR10:4:0R11r24ggajy14:hxsl.Component:0:0jR25:1:0jR25:2:0hgoR14oR15i188R16i193R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y5:colorR9i-486R5jR10:2:0R11r35ggghgR12ahghy4:varsar25r36r5hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<color public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></color>
		<color__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</color__>
		<get_color get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_color>
		<set_color get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_color>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="16">
			<f a="?color" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ color : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	var pixelColor:Vec4;
	@param var color:Vec3;
	function fragment() {
		pixelColor.rgb += color;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.ColorKey" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/ColorKey.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey19:h3d.shader.ColorKeyy4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:1:0y3:refoR0y8:fragmenty2:idi-490R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini167y3:maxi260y4:filey73:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FColorKey.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i173R16i209R17R18gR19r3R20jR21:7:2oR0y5:cdiffR9i-491R5jR10:4:0R11jR4:5:2i4jy12:hxsl.VecType:1:0goR14oR15i185R16i208R17R18gR19r19R20jR21:5:3jy16:haxe.macro.Binop:3:0oR14oR15i185R16i197R17R18gR19jR4:5:2i4r18R20jR21:1:1oR0y12:textureColorR9i-489R5r17R11r25ggoR14oR15i200R16i208R17R18gR19jR4:5:2i4r18R20jR21:1:1oR0y8:colorKeyR9i-488R5jR10:2:0R11r30ggggoR14oR15i214R16i254R17R18gR19r3R20jR21:10:3oR14oR15i218R16i244R17R18gR19jR4:2:0R20jR21:5:3jR24:9:0oR14oR15i218R16i234R17R18gR19jR4:3:0R20jR21:8:2oR14oR15i218R16i223R17R18gR19jR4:14:1aoR3r44R12aoR0y1:_R11r19goR0y1:bR11jR4:5:2i4r18ghghR20jR21:2:1jy12:hxsl.TGlobal:29:0gaoR14oR15i218R16i223R17R18gR19r19R20jR21:1:1r16goR14oR15i228R16i233R17R18gR19r19R20jR21:1:1r16ghgoR14oR15i237R16i244R17R18gR19r44R20jR21:0:1jy10:hxsl.Const:3:1d1e-005ggoR14oR15i247R16i254R17R18gR19r3R20jR21:11:0gnghgR12ahghy4:varsar31r26r5hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey19:h3d.shader.ColorKeyy4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:1:0y3:refoR0y8:fragmenty2:idi-490R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini167y3:maxi260y4:filey73:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FColorKey.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i173R16i209R17R18gR19r3R20jR21:7:2oR0y5:cdiffR9i-491R5jR10:4:0R11jR4:5:2i4jy12:hxsl.VecType:1:0goR14oR15i185R16i208R17R18gR19r19R20jR21:5:3jy16:haxe.macro.Binop:3:0oR14oR15i185R16i197R17R18gR19jR4:5:2i4r18R20jR21:1:1oR0y12:textureColorR9i-489R5r17R11r25ggoR14oR15i200R16i208R17R18gR19jR4:5:2i4r18R20jR21:1:1oR0y8:colorKeyR9i-488R5jR10:2:0R11r30ggggoR14oR15i214R16i254R17R18gR19r3R20jR21:10:3oR14oR15i218R16i244R17R18gR19jR4:2:0R20jR21:5:3jR24:9:0oR14oR15i218R16i234R17R18gR19jR4:3:0R20jR21:8:2oR14oR15i218R16i223R17R18gR19jR4:14:1aoR3r44R12aoR0y1:_R11r19goR0y1:bR11jR4:5:2i4r18ghghR20jR21:2:1jy12:hxsl.TGlobal:29:0gaoR14oR15i218R16i223R17R18gR19r19R20jR21:1:1r16goR14oR15i228R16i233R17R18gR19r19R20jR21:1:1r16ghgoR14oR15i237R16i244R17R18gR19r44R20jR21:0:1jy10:hxsl.Const:3:1d1e-005ggoR14oR15i247R16i254R17R18gR19r3R20jR21:11:0gnghgR12ahghy4:varsar31r26r5hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<colorKey public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></colorKey>
		<colorKey__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</colorKey__>
		<get_colorKey get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_colorKey>
		<set_colorKey get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_colorKey>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="15">
			<f a="?v" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ v : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@param var colorKey:Vec4;
	var textureColor:Vec4;
	function fragment() {
		var cdiff = textureColor - colorKey;
		if (cdiff.dot(cdiff) < 0.00001) discard;
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.ColorMatrix" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/ColorMatrix.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey22:h3d.shader.ColorMatrixy4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:1:0y3:refoR0y8:fragmenty2:idi-69R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini168y3:maxi263y4:filey76:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FColorMatrix.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i174R16i257R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i174R16i184R17R18gR19r17R20jR21:1:1oR0y10:pixelColorR9i-67R5jR10:4:0R11r17ggoR14oR15i187R16i257R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i187R16i191R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i193R16i231R17R18gR19jR4:5:2i3r16R20jR21:9:2oR14oR15i193R16i227R17R18gR19jR4:5:2i4r16R20jR21:3:1oR14oR15i194R16i226R17R18gR19r39R20jR21:5:3jR23:1:0oR14oR15i194R16i217R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i194R16i198R17R18gR19r30R20jR21:2:1r31gaoR14oR15i199R16i213R17R18gR19jR4:5:2i3r16R20jR21:9:2oR14oR15i199R16i209R17R18gR19r17R20jR21:1:1r21gajy14:hxsl.Component:0:0jR26:1:0jR26:2:0hgoR14oR15i214R16i216R17R18gR19jR4:3:0R20jR21:0:1jy10:hxsl.Const:3:1d1ghgoR14oR15i220R16i226R17R18gR19jR4:7:0R20jR21:1:1oR0y6:matrixR9i-68R5jR10:2:0R11r69ggggar57r58r59hgoR14oR15i233R16i256R17R18gR19r63R20jR21:9:2oR14oR15i233R16i254R17R18gR19r39R20jR21:3:1oR14oR15i234R16i253R17R18gR19r39R20jR21:5:3r42oR14oR15i234R16i244R17R18gR19r17R20jR21:1:1r21goR14oR15i247R16i253R17R18gR19r69R20jR21:1:1r70gggajR26:3:0hghgghgR12ahghy4:varsar21r70r5hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey22:h3d.shader.ColorMatrixy4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:1:0y3:refoR0y8:fragmenty2:idi-69R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini168y3:maxi263y4:filey76:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FColorMatrix.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i174R16i257R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i174R16i184R17R18gR19r17R20jR21:1:1oR0y10:pixelColorR9i-67R5jR10:4:0R11r17ggoR14oR15i187R16i257R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i187R16i191R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i193R16i231R17R18gR19jR4:5:2i3r16R20jR21:9:2oR14oR15i193R16i227R17R18gR19jR4:5:2i4r16R20jR21:3:1oR14oR15i194R16i226R17R18gR19r39R20jR21:5:3jR23:1:0oR14oR15i194R16i217R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i194R16i198R17R18gR19r30R20jR21:2:1r31gaoR14oR15i199R16i213R17R18gR19jR4:5:2i3r16R20jR21:9:2oR14oR15i199R16i209R17R18gR19r17R20jR21:1:1r21gajy14:hxsl.Component:0:0jR26:1:0jR26:2:0hgoR14oR15i214R16i216R17R18gR19jR4:3:0R20jR21:0:1jy10:hxsl.Const:3:1d1ghgoR14oR15i220R16i226R17R18gR19jR4:7:0R20jR21:1:1oR0y6:matrixR9i-68R5jR10:2:0R11r69ggggar57r58r59hgoR14oR15i233R16i256R17R18gR19r63R20jR21:9:2oR14oR15i233R16i254R17R18gR19r39R20jR21:3:1oR14oR15i234R16i253R17R18gR19r39R20jR21:5:3r42oR14oR15i234R16i244R17R18gR19r17R20jR21:1:1r21goR14oR15i247R16i253R17R18gR19r69R20jR21:1:1r70gggajR26:3:0hghgghgR12ahghy4:varsar21r70r5hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<matrix public="1" get="accessor" set="accessor"><t path="hxsl.Matrix"/></matrix>
		<matrix__ expr="new hxsl.Types.Matrix()">
			<t path="hxsl.Matrix"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Matrix()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</matrix__>
		<get_matrix get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_matrix>
		<set_matrix get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Matrix"/>
				<t path="hxsl.Matrix"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_matrix>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="16"><f a="?m">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	var pixelColor:Vec4;
	@param var matrix:Mat4;
	function fragment() {
		pixelColor = vec4((vec4(pixelColor.rgb, 1.) * matrix).rgb, (pixelColor * matrix).a);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.DirShadow" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/DirShadow.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey20:h3d.shader.DirShadowy4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:1:0y3:refoR0y8:fragmenty2:idi-255R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini341y3:maxi634y4:filey74:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FDirShadow.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i347R16i629R17R18gR19r3R20jR21:10:3oR14oR15i351R16i357R17R18gR19jR4:2:0R20jR21:1:1oR0y6:enabley10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-248R5jR10:2:0R11r18ggoR14oR15i360R16i629R17R18gR19r3R20jR21:4:1aoR14oR15i367R16i416R17R18gR19r3R20jR21:7:2oR0y9:shadowPosR9i-256R5jR10:4:0R11jR4:5:2i3jy12:hxsl.VecType:1:0goR14oR15i383R16i415R17R18gR19r32R20jR21:5:3jy16:haxe.macro.Binop:1:0oR14oR15i383R16i402R17R18gR19jR4:5:2i3r31R20jR21:1:1oR0y19:transformedPositionR9i-253R5r30R11r38ggoR14oR15i405R16i415R17R18gR19jR4:8:0R20jR21:1:1oR0y10:shadowProjR9i-250R5r22R11r43ggggoR14oR15i422R16i474R17R18gR19r3R20jR21:7:2oR0y5:depthR9i-257R5r30R11jR4:3:0goR14oR15i434R16i473R17R18gR19r51R20jR21:8:2oR14oR15i434R16i443R17R18gR19jR4:14:1aoR3r51R12aoR0y1:_R11jR4:17:1i1goR0y2:uvR11jR4:5:2i2r31ghghR20jR21:2:1jy12:hxsl.TGlobal:61:0gaoR14oR15i434R16i443R17R18gR19r60R20jR21:1:1oR0y9:shadowMapR9i-249R5r22R11r60ggoR14oR15i448R16i472R17R18gR19r62R20jR21:8:2oR14oR15i448R16i458R17R18gR19jR4:14:1aoR3r62R12aoR0y9:screenPosR11r62ghghR20jR21:2:1jR33:56:0gaoR14oR15i459R16i471R17R18gR19jR4:5:2i2r31R20jR21:9:2oR14oR15i459R16i468R17R18gR19r32R20jR21:1:1r29gajy14:hxsl.Component:0:0jR36:1:0hghghggoR14oR15i480R16i514R17R18gR19r3R20jR21:7:2oR0y4:zMaxR9i-258R5r30R11r51goR14oR15i491R16i513R17R18gR19r51R20jR21:8:2oR14oR15i491R16i502R17R18gR19jR4:14:1aoR3r51R12aoR0R31R11r51ghghR20jR21:2:1jR33:51:0gaoR14oR15i491R16i502R17R18gR19r51R20jR21:9:2oR14oR15i491R16i500R17R18gR19r32R20jR21:1:1r29gajR36:2:0hghggoR14oR15i520R16i570R17R18gR19r3R20jR21:7:2oR0y5:deltaR9i-259R5r30R11r51goR14oR15i532R16i569R17R18gR19r51R20jR21:5:3jR27:3:0oR14oR15i532R16i562R17R18gR19r51R20jR21:8:2oR14oR15i532R16i552R17R18gR19jR4:14:1aoR3r51R12aoR0R31R11r51goR0y1:bR11r51ghghR20jR21:2:1jR33:21:0gaoR14oR15i532R16i552R17R18gR19r51R20jR21:3:1oR14oR15i533R16i551R17R18gR19r51R20jR21:5:3jR27:0:0oR14oR15i533R16i538R17R18gR19r51R20jR21:1:1r50goR14oR15i541R16i551R17R18gR19r51R20jR21:1:1oR0y10:shadowBiasR9i-252R5r22R11r51ggggoR14oR15i557R16i561R17R18gR19r51R20jR21:1:1r98ghgoR14oR15i565R16i569R17R18gR19r51R20jR21:1:1r98gggoR14oR15i576R16i622R17R18gR19r51R20jR21:5:3jR27:4:0oR14oR15i576R16i582R17R18gR19r51R20jR21:1:1oR0y6:shadowR9i-254R5r30R11r51ggoR14oR15i585R16i622R17R18gR19r51R20jR21:8:2oR14oR15i585R16i611R17R18gR19jR4:14:1aoR3r51R12aoR0R31R11r51ghghR20jR21:2:1r108gaoR14oR15i585R16i611R17R18gR19r51R20jR21:8:2oR14oR15i585R16i588R17R18gR19jR4:14:1aoR3r51R12aoR0y5:valueR11r51ghghR20jR21:2:1jR33:9:0gaoR14oR15i590R16i609R17R18gR19r51R20jR21:5:3r35oR14oR15i590R16i601R17R18gR19r51R20jR21:1:1oR0y11:shadowPowerR9i-251R5r22R11r51ggoR14oR15i604R16i609R17R18gR19r51R20jR21:1:1r123gghghgghgnghgR12ahghy4:varsar19r69r44r197r150r39r168r5hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey20:h3d.shader.DirShadowy4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:1:0y3:refoR0y8:fragmenty2:idi-255R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini341y3:maxi634y4:filey74:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FDirShadow.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i347R16i629R17R18gR19r3R20jR21:10:3oR14oR15i351R16i357R17R18gR19jR4:2:0R20jR21:1:1oR0y6:enabley10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-248R5jR10:2:0R11r18ggoR14oR15i360R16i629R17R18gR19r3R20jR21:4:1aoR14oR15i367R16i416R17R18gR19r3R20jR21:7:2oR0y9:shadowPosR9i-256R5jR10:4:0R11jR4:5:2i3jy12:hxsl.VecType:1:0goR14oR15i383R16i415R17R18gR19r32R20jR21:5:3jy16:haxe.macro.Binop:1:0oR14oR15i383R16i402R17R18gR19jR4:5:2i3r31R20jR21:1:1oR0y19:transformedPositionR9i-253R5r30R11r38ggoR14oR15i405R16i415R17R18gR19jR4:8:0R20jR21:1:1oR0y10:shadowProjR9i-250R5r22R11r43ggggoR14oR15i422R16i474R17R18gR19r3R20jR21:7:2oR0y5:depthR9i-257R5r30R11jR4:3:0goR14oR15i434R16i473R17R18gR19r51R20jR21:8:2oR14oR15i434R16i443R17R18gR19jR4:14:1aoR3r51R12aoR0y1:_R11jR4:17:1i1goR0y2:uvR11jR4:5:2i2r31ghghR20jR21:2:1jy12:hxsl.TGlobal:61:0gaoR14oR15i434R16i443R17R18gR19r60R20jR21:1:1oR0y9:shadowMapR9i-249R5r22R11r60ggoR14oR15i448R16i472R17R18gR19r62R20jR21:8:2oR14oR15i448R16i458R17R18gR19jR4:14:1aoR3r62R12aoR0y9:screenPosR11r62ghghR20jR21:2:1jR33:56:0gaoR14oR15i459R16i471R17R18gR19jR4:5:2i2r31R20jR21:9:2oR14oR15i459R16i468R17R18gR19r32R20jR21:1:1r29gajy14:hxsl.Component:0:0jR36:1:0hghghggoR14oR15i480R16i514R17R18gR19r3R20jR21:7:2oR0y4:zMaxR9i-258R5r30R11r51goR14oR15i491R16i513R17R18gR19r51R20jR21:8:2oR14oR15i491R16i502R17R18gR19jR4:14:1aoR3r51R12aoR0R31R11r51ghghR20jR21:2:1jR33:51:0gaoR14oR15i491R16i502R17R18gR19r51R20jR21:9:2oR14oR15i491R16i500R17R18gR19r32R20jR21:1:1r29gajR36:2:0hghggoR14oR15i520R16i570R17R18gR19r3R20jR21:7:2oR0y5:deltaR9i-259R5r30R11r51goR14oR15i532R16i569R17R18gR19r51R20jR21:5:3jR27:3:0oR14oR15i532R16i562R17R18gR19r51R20jR21:8:2oR14oR15i532R16i552R17R18gR19jR4:14:1aoR3r51R12aoR0R31R11r51goR0y1:bR11r51ghghR20jR21:2:1jR33:21:0gaoR14oR15i532R16i552R17R18gR19r51R20jR21:3:1oR14oR15i533R16i551R17R18gR19r51R20jR21:5:3jR27:0:0oR14oR15i533R16i538R17R18gR19r51R20jR21:1:1r50goR14oR15i541R16i551R17R18gR19r51R20jR21:1:1oR0y10:shadowBiasR9i-252R5r22R11r51ggggoR14oR15i557R16i561R17R18gR19r51R20jR21:1:1r98ghgoR14oR15i565R16i569R17R18gR19r51R20jR21:1:1r98gggoR14oR15i576R16i622R17R18gR19r51R20jR21:5:3jR27:4:0oR14oR15i576R16i582R17R18gR19r51R20jR21:1:1oR0y6:shadowR9i-254R5r30R11r51ggoR14oR15i585R16i622R17R18gR19r51R20jR21:8:2oR14oR15i585R16i611R17R18gR19jR4:14:1aoR3r51R12aoR0R31R11r51ghghR20jR21:2:1r108gaoR14oR15i585R16i611R17R18gR19r51R20jR21:8:2oR14oR15i585R16i588R17R18gR19jR4:14:1aoR3r51R12aoR0y5:valueR11r51ghghR20jR21:2:1jR33:9:0gaoR14oR15i590R16i609R17R18gR19r51R20jR21:5:3r35oR14oR15i590R16i601R17R18gR19r51R20jR21:1:1oR0y11:shadowPowerR9i-251R5r22R11r51ggoR14oR15i604R16i609R17R18gR19r51R20jR21:1:1r123gghghgghgnghgR12ahghy4:varsar19r69r44r197r150r39r168r5hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<enable public="1" get="accessor" set="accessor"><x path="Bool"/></enable>
		<enable__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</enable__>
		<get_enable get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_enable>
		<set_enable get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_enable>
		<shadowMap public="1" get="accessor" set="accessor"><t path="hxsl.ChannelTextureType"/></shadowMap>
		<shadowMap__>
			<t path="hxsl.ChannelTextureType"/>
			<meta><m n=":noCompletion"/></meta>
		</shadowMap__>
		<get_shadowMap get="inline" set="null" line="5">
			<f a=""><t path="hxsl.ChannelTextureType"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_shadowMap>
		<set_shadowMap get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.ChannelTextureType"/>
				<t path="hxsl.ChannelTextureType"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_shadowMap>
		<shadowMapChannel__ expr="Unknown">
			<e path="hxsl.Channel"/>
			<meta><m n=":value"><e>Unknown</e></m></meta>
		</shadowMapChannel__>
		<shadowMapChannel public="1" get="accessor" set="accessor"><e path="hxsl.Channel"/></shadowMapChannel>
		<get_shadowMapChannel get="inline" set="null" line="215"><f a=""><e path="hxsl.Channel"/></f></get_shadowMapChannel>
		<set_shadowMapChannel get="inline" set="null" line="216"><f a="v">
	<e path="hxsl.Channel"/>
	<e path="hxsl.Channel"/>
</f></set_shadowMapChannel>
		<shadowProj public="1" get="accessor" set="accessor"><t path="hxsl.Matrix"/></shadowProj>
		<shadowProj__ expr="new hxsl.Types.Matrix()">
			<t path="hxsl.Matrix"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Matrix()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</shadowProj__>
		<get_shadowProj get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_shadowProj>
		<set_shadowProj get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Matrix"/>
				<t path="hxsl.Matrix"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_shadowProj>
		<shadowPower public="1" get="accessor" set="accessor"><x path="Float"/></shadowPower>
		<shadowPower__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</shadowPower__>
		<get_shadowPower get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_shadowPower>
		<set_shadowPower get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_shadowPower>
		<shadowBias public="1" get="accessor" set="accessor"><x path="Float"/></shadowBias>
		<shadowBias__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</shadowBias__>
		<get_shadowBias get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_shadowBias>
		<set_shadowBias get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_shadowBias>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@const var enable:Bool;
	@param var shadowMap:Channel;
	@param var shadowProj:Mat3x4;
	@param var shadowPower:Float;
	@param var shadowBias:Float;
	var transformedPosition:Vec3;
	var shadow:Float;
	function fragment() {
		if (enable) {
			var shadowPos = transformedPosition * shadowProj;
			var depth = shadowMap.get(screenToUv(shadowPos.xy));
			var zMax = shadowPos.z.saturate();
			var delta = (depth + shadowBias).min(zMax) - zMax;
			shadow = exp(shadowPower * delta).saturate();
		};
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.LineShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/LineShader.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey21:h3d.shader.LineShadery4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-27R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini648y3:maxi958y4:filey75:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FLineShader.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i654R16i953R17R18gR19r3R20jR21:4:1aoR14oR15i661R16i710R17R18gR19r3R20jR21:7:2oR0y3:dirR9i-29R5jR10:4:0R11jR4:5:2i3jy12:hxsl.VecType:1:0goR14oR15i671R16i709R17R18gR19r22R20jR21:5:3jy16:haxe.macro.Binop:1:0oR14oR15i671R16i683R17R18gR19jR4:5:2i3r21R20jR21:1:1oR0y6:normalR9i-17y6:parentoR0y5:inputR9i-15R5jR10:1:0R11jR4:13:1aoR0y8:positionR9i-16R26r30R5r31R11jR4:5:2i3r21gr29oR0y2:uvR9i-18R26r30R5r31R11jR4:5:2i2r21ghgR5r31R11r28ggoR14oR15i686R16i709R17R18gR19jR4:6:0R20jR21:8:2oR14oR15i686R16i702R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:48:0gaoR14oR15i686R16i702R17R18gR19jR4:7:0R20jR21:1:1oR0y9:modelViewy10:qualifiersajy17:hxsl.VarQualifier:3:0hR9i-14R26oR0y6:globalR9i-12R5jR10:0:0R11jR4:13:1aoR0y9:pixelSizeR9i-13R26r55R5r56R11jR4:5:2i2r21gr52hgR5r56R11r51gghgggoR14oR15i730R16i783R17R18gR19jR4:5:2i4r21R20jR21:5:3jR24:4:0oR14oR15i730R16i734R17R18gR19r67R20jR21:1:1oR0y4:pdirR9i-26R5r20R11r67ggoR14oR15i737R16i783R17R18gR19jR4:5:2i4r21R20jR21:5:3r25oR14oR15i737R16i769R17R18gR19jR4:5:2i4r21R20jR21:8:2oR14oR15i737R16i741R17R18gR19jR4:14:1ahR20jR21:2:1jR30:40:0gaoR14oR15i742R16i765R17R18gR19r22R20jR21:5:3r25oR14oR15i742R16i745R17R18gR19r22R20jR21:1:1r19goR14oR15i748R16i765R17R18gR19r41R20jR21:8:2oR14oR15i748R16i752R17R18gR19jR4:14:1ahR20jR21:2:1r46gaoR14oR15i753R16i764R17R18gR19r51R20jR21:1:1oR0y4:viewR9i-9R26oR0y6:cameraR9i-8R5r56R11jR4:13:1ar101oR0y4:projR9i-10R26r102R5r56R11r51goR0y8:viewProjR9i-11R26r102R5r56R11r51ghgR5r56R11r51gghggoR14oR15i767R16i768R17R18gR19jR4:3:0R20jR21:0:1jy10:hxsl.Const:3:1i1ghgoR14oR15i772R16i783R17R18gR19r51R20jR21:1:1r104gggoR14oR15i790R16i844R17R18gR19jR4:5:2i2r21R20jR21:5:3jR24:20:1r25oR14oR15i790R16i797R17R18gR19r123R20jR21:9:2oR14oR15i790R16i794R17R18gR19r67R20jR21:1:1r71gajy14:hxsl.Component:0:0jR42:1:0hgoR14oR15i801R16i844R17R18gR19r112R20jR21:5:3jR24:2:0oR14oR15i801R16i802R17R18gR19r112R20jR21:0:1jR41:3:1i1goR14oR15i805R16i844R17R18gR19r112R20jR21:8:2oR14oR15i805R16i809R17R18gR19jR4:14:1aoR3r112R12aoR0y5:valueR11r112ghghR20jR21:2:1jR30:13:0gaoR14oR15i810R16i843R17R18gR19r112R20jR21:5:3jR24:0:0oR14oR15i810R16i825R17R18gR19r112R20jR21:5:3r25oR14oR15i810R16i816R17R18gR19r112R20jR21:9:2oR14oR15i810R16i814R17R18gR19r67R20jR21:1:1r71gar131hgoR14oR15i819R16i825R17R18gR19r112R20jR21:9:2oR14oR15i819R16i823R17R18gR19r67R20jR21:1:1r71gar131hggoR14oR15i828R16i843R17R18gR19r112R20jR21:5:3r25oR14oR15i828R16i834R17R18gR19r112R20jR21:9:2oR14oR15i828R16i832R17R18gR19r67R20jR21:1:1r71gar132hgoR14oR15i837R16i843R17R18gR19r112R20jR21:9:2oR14oR15i837R16i841R17R18gR19r67R20jR21:1:1r71gar132hggghgggoR14oR15i851R16i904R17R18gR19jR4:5:2i3r21R20jR21:5:3jR24:20:1r155oR14oR15i851R16i870R17R18gR19r196R20jR21:1:1oR0y19:transformedPositionR9i-22R5r20R11r196ggoR14oR15i874R16i904R17R18gR19r22R20jR21:5:3r25oR14oR15i874R16i890R17R18gR19r22R20jR21:5:3r25oR14oR15i874R16i877R17R18gR19r22R20jR21:1:1r19goR14oR15i880R16i890R17R18gR19r112R20jR21:9:2oR14oR15i880R16i888R17R18gR19r36R20jR21:1:1r35gar131hggoR14oR15i893R16i904R17R18gR19r112R20jR21:1:1oR0y11:lengthScaleR9i-24R5jR10:2:0R11r112ggggoR14oR15i911R16i946R17R18gR19jR4:5:2i3r21R20jR21:5:3r68oR14oR15i911R16i928R17R18gR19r226R20jR21:1:1oR0y17:transformedNormalR9i-21R5r20R11r226ggoR14oR15i931R16i946R17R18gR19r22R20jR21:8:2oR14oR15i931R16i934R17R18gR19jR4:14:1aoR3r22R12aoR0y1:_R11r22ghghR20jR21:2:1jR30:31:0gaoR14oR15i931R16i934R17R18gR19r22R20jR21:1:1r19ghgghghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-28R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i982R16i1110R17R18gR19r3R20jR21:4:1aoR14oR15i988R16i1104R17R18gR19jR4:5:2i2r21R20jR21:5:3jR24:20:1r155oR14oR15i988R16i1008R17R18gR19r263R20jR21:9:2oR14oR15i988R16i1005R17R18gR19jR4:5:2i4r21R20jR21:1:1oR0y17:projectedPositionR9i-23R5r20R11r269ggar131r132hgoR14oR15i1012R16i1104R17R18gR19jR4:5:2i2r21R20jR21:5:3r25oR14oR15i1012R16i1096R17R18gR19r276R20jR21:5:3r25oR14oR15i1012R16i1077R17R18gR19jR4:5:2i2r21R20jR21:5:3r25oR14oR15i1012R16i1055R17R18gR19r281R20jR21:5:3r25oR14oR15i1012R16i1034R17R18gR19r281R20jR21:3:1oR14oR15i1013R16i1033R17R18gR19r281R20jR21:5:3r25oR14oR15i1013R16i1020R17R18gR19jR4:5:2i2r21R20jR21:9:2oR14oR15i1013R16i1017R17R18gR19r67R20jR21:1:1r71gar132r131hgoR14oR15i1023R16i1033R17R18gR19jR4:5:2i2r21R20jR21:8:2oR14oR15i1023R16i1027R17R18gR19jR4:14:1ahR20jR21:2:1jR30:38:0gaoR14oR15i1028R16i1029R17R18gR19r112R20jR21:0:1jR41:3:1i1goR14oR15i1030R16i1032R17R18gR19r112R20jR21:0:1jR41:3:1i-1ghgggoR14oR15i1037R16i1055R17R18gR19r112R20jR21:3:1oR14oR15i1038R16i1054R17R18gR19r112R20jR21:5:3jR24:3:0oR14oR15i1038R16i1048R17R18gR19r112R20jR21:9:2oR14oR15i1038R16i1046R17R18gR19r36R20jR21:1:1r35gar132hgoR14oR15i1051R16i1054R17R18gR19r112R20jR21:0:1jR41:3:1d0.5ggggoR14oR15i1058R16i1077R17R18gR19r112R20jR21:9:2oR14oR15i1058R16i1075R17R18gR19r269R20jR21:1:1r270gajR42:2:0hggoR14oR15i1080R16i1096R17R18gR19r59R20jR21:1:1r58ggoR14oR15i1099R16i1104R17R18gR19r112R20jR21:1:1oR0y5:widthR9i-25R5r220R11r112gggghgR12ahghy4:varsar102r55r30oR0y6:outputR9i-19R5r20R11jR4:13:1aoR0R28R9i-20R26r358R5r20R11jR4:5:2i4r21ghgr229r200r270r219r351r71r5r253hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey21:h3d.shader.LineShadery4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-27R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini648y3:maxi958y4:filey75:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FLineShader.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i654R16i953R17R18gR19r3R20jR21:4:1aoR14oR15i661R16i710R17R18gR19r3R20jR21:7:2oR0y3:dirR9i-29R5jR10:4:0R11jR4:5:2i3jy12:hxsl.VecType:1:0goR14oR15i671R16i709R17R18gR19r22R20jR21:5:3jy16:haxe.macro.Binop:1:0oR14oR15i671R16i683R17R18gR19jR4:5:2i3r21R20jR21:1:1oR0y6:normalR9i-17y6:parentoR0y5:inputR9i-15R5jR10:1:0R11jR4:13:1aoR0y8:positionR9i-16R26r30R5r31R11jR4:5:2i3r21gr29oR0y2:uvR9i-18R26r30R5r31R11jR4:5:2i2r21ghgR5r31R11r28ggoR14oR15i686R16i709R17R18gR19jR4:6:0R20jR21:8:2oR14oR15i686R16i702R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:48:0gaoR14oR15i686R16i702R17R18gR19jR4:7:0R20jR21:1:1oR0y9:modelViewy10:qualifiersajy17:hxsl.VarQualifier:3:0hR9i-14R26oR0y6:globalR9i-12R5jR10:0:0R11jR4:13:1aoR0y9:pixelSizeR9i-13R26r55R5r56R11jR4:5:2i2r21gr52hgR5r56R11r51gghgggoR14oR15i730R16i783R17R18gR19jR4:5:2i4r21R20jR21:5:3jR24:4:0oR14oR15i730R16i734R17R18gR19r67R20jR21:1:1oR0y4:pdirR9i-26R5r20R11r67ggoR14oR15i737R16i783R17R18gR19jR4:5:2i4r21R20jR21:5:3r25oR14oR15i737R16i769R17R18gR19jR4:5:2i4r21R20jR21:8:2oR14oR15i737R16i741R17R18gR19jR4:14:1ahR20jR21:2:1jR30:40:0gaoR14oR15i742R16i765R17R18gR19r22R20jR21:5:3r25oR14oR15i742R16i745R17R18gR19r22R20jR21:1:1r19goR14oR15i748R16i765R17R18gR19r41R20jR21:8:2oR14oR15i748R16i752R17R18gR19jR4:14:1ahR20jR21:2:1r46gaoR14oR15i753R16i764R17R18gR19r51R20jR21:1:1oR0y4:viewR9i-9R26oR0y6:cameraR9i-8R5r56R11jR4:13:1ar101oR0y4:projR9i-10R26r102R5r56R11r51goR0y8:viewProjR9i-11R26r102R5r56R11r51ghgR5r56R11r51gghggoR14oR15i767R16i768R17R18gR19jR4:3:0R20jR21:0:1jy10:hxsl.Const:3:1i1ghgoR14oR15i772R16i783R17R18gR19r51R20jR21:1:1r104gggoR14oR15i790R16i844R17R18gR19jR4:5:2i2r21R20jR21:5:3jR24:20:1r25oR14oR15i790R16i797R17R18gR19r123R20jR21:9:2oR14oR15i790R16i794R17R18gR19r67R20jR21:1:1r71gajy14:hxsl.Component:0:0jR42:1:0hgoR14oR15i801R16i844R17R18gR19r112R20jR21:5:3jR24:2:0oR14oR15i801R16i802R17R18gR19r112R20jR21:0:1jR41:3:1i1goR14oR15i805R16i844R17R18gR19r112R20jR21:8:2oR14oR15i805R16i809R17R18gR19jR4:14:1aoR3r112R12aoR0y5:valueR11r112ghghR20jR21:2:1jR30:13:0gaoR14oR15i810R16i843R17R18gR19r112R20jR21:5:3jR24:0:0oR14oR15i810R16i825R17R18gR19r112R20jR21:5:3r25oR14oR15i810R16i816R17R18gR19r112R20jR21:9:2oR14oR15i810R16i814R17R18gR19r67R20jR21:1:1r71gar131hgoR14oR15i819R16i825R17R18gR19r112R20jR21:9:2oR14oR15i819R16i823R17R18gR19r67R20jR21:1:1r71gar131hggoR14oR15i828R16i843R17R18gR19r112R20jR21:5:3r25oR14oR15i828R16i834R17R18gR19r112R20jR21:9:2oR14oR15i828R16i832R17R18gR19r67R20jR21:1:1r71gar132hgoR14oR15i837R16i843R17R18gR19r112R20jR21:9:2oR14oR15i837R16i841R17R18gR19r67R20jR21:1:1r71gar132hggghgggoR14oR15i851R16i904R17R18gR19jR4:5:2i3r21R20jR21:5:3jR24:20:1r155oR14oR15i851R16i870R17R18gR19r196R20jR21:1:1oR0y19:transformedPositionR9i-22R5r20R11r196ggoR14oR15i874R16i904R17R18gR19r22R20jR21:5:3r25oR14oR15i874R16i890R17R18gR19r22R20jR21:5:3r25oR14oR15i874R16i877R17R18gR19r22R20jR21:1:1r19goR14oR15i880R16i890R17R18gR19r112R20jR21:9:2oR14oR15i880R16i888R17R18gR19r36R20jR21:1:1r35gar131hggoR14oR15i893R16i904R17R18gR19r112R20jR21:1:1oR0y11:lengthScaleR9i-24R5jR10:2:0R11r112ggggoR14oR15i911R16i946R17R18gR19jR4:5:2i3r21R20jR21:5:3r68oR14oR15i911R16i928R17R18gR19r226R20jR21:1:1oR0y17:transformedNormalR9i-21R5r20R11r226ggoR14oR15i931R16i946R17R18gR19r22R20jR21:8:2oR14oR15i931R16i934R17R18gR19jR4:14:1aoR3r22R12aoR0y1:_R11r22ghghR20jR21:2:1jR30:31:0gaoR14oR15i931R16i934R17R18gR19r22R20jR21:1:1r19ghgghghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-28R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i982R16i1110R17R18gR19r3R20jR21:4:1aoR14oR15i988R16i1104R17R18gR19jR4:5:2i2r21R20jR21:5:3jR24:20:1r155oR14oR15i988R16i1008R17R18gR19r263R20jR21:9:2oR14oR15i988R16i1005R17R18gR19jR4:5:2i4r21R20jR21:1:1oR0y17:projectedPositionR9i-23R5r20R11r269ggar131r132hgoR14oR15i1012R16i1104R17R18gR19jR4:5:2i2r21R20jR21:5:3r25oR14oR15i1012R16i1096R17R18gR19r276R20jR21:5:3r25oR14oR15i1012R16i1077R17R18gR19jR4:5:2i2r21R20jR21:5:3r25oR14oR15i1012R16i1055R17R18gR19r281R20jR21:5:3r25oR14oR15i1012R16i1034R17R18gR19r281R20jR21:3:1oR14oR15i1013R16i1033R17R18gR19r281R20jR21:5:3r25oR14oR15i1013R16i1020R17R18gR19jR4:5:2i2r21R20jR21:9:2oR14oR15i1013R16i1017R17R18gR19r67R20jR21:1:1r71gar132r131hgoR14oR15i1023R16i1033R17R18gR19jR4:5:2i2r21R20jR21:8:2oR14oR15i1023R16i1027R17R18gR19jR4:14:1ahR20jR21:2:1jR30:38:0gaoR14oR15i1028R16i1029R17R18gR19r112R20jR21:0:1jR41:3:1i1goR14oR15i1030R16i1032R17R18gR19r112R20jR21:0:1jR41:3:1i-1ghgggoR14oR15i1037R16i1055R17R18gR19r112R20jR21:3:1oR14oR15i1038R16i1054R17R18gR19r112R20jR21:5:3jR24:3:0oR14oR15i1038R16i1048R17R18gR19r112R20jR21:9:2oR14oR15i1038R16i1046R17R18gR19r36R20jR21:1:1r35gar132hgoR14oR15i1051R16i1054R17R18gR19r112R20jR21:0:1jR41:3:1d0.5ggggoR14oR15i1058R16i1077R17R18gR19r112R20jR21:9:2oR14oR15i1058R16i1075R17R18gR19r269R20jR21:1:1r270gajR42:2:0hggoR14oR15i1080R16i1096R17R18gR19r59R20jR21:1:1r58ggoR14oR15i1099R16i1104R17R18gR19r112R20jR21:1:1oR0y5:widthR9i-25R5r220R11r112gggghgR12ahghy4:varsar102r55r30oR0y6:outputR9i-19R5r20R11jR4:13:1aoR0R28R9i-20R26r358R5r20R11jR4:5:2i4r21ghgr229r200r270r219r351r71r5r253hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<lengthScale public="1" get="accessor" set="accessor"><x path="Float"/></lengthScale>
		<lengthScale__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</lengthScale__>
		<get_lengthScale get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_lengthScale>
		<set_lengthScale get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_lengthScale>
		<width public="1" get="accessor" set="accessor"><x path="Float"/></width>
		<width__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</width__>
		<get_width get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_width>
		<set_width get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_width>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="53">
			<f a="?width:?lengthScale" v="1.5:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ lengthScale : 1., width : 1.5 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@global var camera:{ var view : Mat4; var proj : Mat4; var viewProj : Mat4};
	@global var global:{ var pixelSize : Vec2; @perObject};
	@input var input:{ var position : Vec3; var normal : Vec3; var uv : Vec2};
	var output:{ var position : Vec4};
	var transformedNormal:Vec3;
	var transformedPosition:Vec3;
	var projectedPosition:Vec4;
	@param var lengthScale:Float;
	@param var width:Float;
	var pdir:Vec4;
	function __init__() {
		{
			var dir = input.normal * global.modelView.mat3();
			pdir = vec4(dir * mat3(camera.view), 1) * camera.proj;
			pdir.xy *= 1 / sqrt(pdir.x * pdir.x + pdir.y * pdir.y);
			transformedPosition += dir * input.uv.x * lengthScale;
			transformedNormal = dir.normalize();
		};
	};
	function vertex() {
		projectedPosition.xy += (pdir.yx * vec2(1, -1)) * (input.uv.y - 0.5) * projectedPosition.z * global.pixelSize * width;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.MinMaxShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/MinMaxShader.hx">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;oy4:namey23:h3d.shader.MinMaxShadery4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-353R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini330y3:maxi396y4:filey77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FScreenShader.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i336R16i361R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i336R16i348R17R18gR19r17R20jR21:1:1oR0y5:colorR9i-347y6:parentoR0y6:outputR9i-345R5jR10:4:0R11jR4:13:1aoR0y8:positionR9i-346R25r22R5r23R11jR4:5:2i4r16gr21hgR5r23R11r17ggoR14oR15i351R16i361R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y10:pixelColorR9i-348R5r23R11r31gggoR14oR15i367R16i390R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i367R16i379R17R18gR19r37R20jR21:1:1oR0y12:calculatedUVR9i-349R5r23R11r37ggoR14oR15i382R16i390R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y2:uvR9i-343R25oR0y5:inputR9i-341R5jR10:1:0R11jR4:13:1aoR0R27R9i-342R25r46R5r47R11jR4:5:2i2r16gr45hgR5r47R11r44ggghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-354R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i420R16i504R17R18gR19r3R20jR21:4:1aoR14oR15i426R16i498R17R18gR19r26R20jR21:5:3r18oR14oR15i426R16i441R17R18gR19r26R20jR21:1:1r25goR14oR15i444R16i498R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i444R16i448R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i449R16i465R17R18gR19jR4:3:0R20jR21:9:2oR14oR15i449R16i463R17R18gR19r50R20jR21:1:1r49gajy14:hxsl.Component:0:0hgoR14oR15i467R16i491R17R18gR19r83R20jR21:5:3jR23:1:0oR14oR15i467R16i483R17R18gR19r83R20jR21:9:2oR14oR15i467R16i481R17R18gR19r50R20jR21:1:1r49gajR34:1:0hgoR14oR15i486R16i491R17R18gR19r83R20jR21:1:1oR0y5:flipYR9i-344R5jR10:2:0R11r83gggoR14oR15i493R16i494R17R18gR19r83R20jR21:0:1jy10:hxsl.Const:3:1zgoR14oR15i496R16i497R17R18gR19r83R20jR21:0:1jR36:3:1i1ghgghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-355R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i207R16i331R17y77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FMinMaxShader.hxgR19r3R20jR21:4:1aoR14oR15i213R16i244R17R38gR19r3R20jR21:7:2oR0y1:aR9i-356R5r23R11jR4:5:2i4r16goR14oR15i221R16i243R17R38gR19r132R20jR21:8:2oR14oR15i221R16i225R17R38gR19jR4:14:1aoR3r132R12aoR0y1:_R11jR4:10:0goR0R30R11jR4:5:2i2r16ghghR20jR21:2:1jR33:33:0gaoR14oR15i221R16i225R17R38gR19r141R20jR21:1:1oR0y4:texAR9i-350R5r104R11r141ggoR14oR15i230R16i242R17R38gR19r37R20jR21:1:1r40ghggoR14oR15i249R16i280R17R38gR19r3R20jR21:7:2oR0y1:bR9i-357R5r23R11r132goR14oR15i257R16i279R17R38gR19r132R20jR21:8:2oR14oR15i257R16i261R17R38gR19jR4:14:1aoR3r132R12aoR0R40R11r141gr142hghR20jR21:2:1r145gaoR14oR15i257R16i261R17R38gR19r141R20jR21:1:1oR0y4:texBR9i-351R5r104R11r141ggoR14oR15i266R16i278R17R38gR19r37R20jR21:1:1r40ghggoR14oR15i285R16i325R17R38gR19r31R20jR21:5:3r18oR14oR15i285R16i295R17R38gR19r31R20jR21:1:1r32goR14oR15i298R16i325R17R38gR19r132R20jR21:10:3oR14oR15i298R16i303R17R38gR19jR4:2:0R20jR21:1:1oR0y5:isMaxy10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-352R5r104R11r189ggoR14oR15i306R16i314R17R38gR19r132R20jR21:8:2oR14oR15i306R16i309R17R38gR19jR4:14:1aoR3r132R12aoR0R39R11r132goR0R42R11r132ghghR20jR21:2:1jR33:22:0gaoR14oR15i310R16i311R17R38gR19r132R20jR21:1:1r131goR14oR15i312R16i313R17R38gR19r132R20jR21:1:1r159ghgoR14oR15i317R16i325R17R38gR19r132R20jR21:8:2oR14oR15i317R16i320R17R38gR19jR4:14:1ar199hR20jR21:2:1jR33:21:0gaoR14oR15i321R16i322R17R38gR19r132R20jR21:1:1r131goR14oR15i323R16i324R17R38gR19r132R20jR21:1:1r159ghggghgR12ahghy4:varsar46r103r22r32r40r150r173r190r5r58r121hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey23:h3d.shader.MinMaxShadery4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-353R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini330y3:maxi396y4:filey77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FScreenShader.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i336R16i361R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i336R16i348R17R18gR19r17R20jR21:1:1oR0y5:colorR9i-347y6:parentoR0y6:outputR9i-345R5jR10:4:0R11jR4:13:1aoR0y8:positionR9i-346R25r22R5r23R11jR4:5:2i4r16gr21hgR5r23R11r17ggoR14oR15i351R16i361R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y10:pixelColorR9i-348R5r23R11r31gggoR14oR15i367R16i390R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i367R16i379R17R18gR19r37R20jR21:1:1oR0y12:calculatedUVR9i-349R5r23R11r37ggoR14oR15i382R16i390R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y2:uvR9i-343R25oR0y5:inputR9i-341R5jR10:1:0R11jR4:13:1aoR0R27R9i-342R25r46R5r47R11jR4:5:2i2r16gr45hgR5r47R11r44ggghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-354R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i420R16i504R17R18gR19r3R20jR21:4:1aoR14oR15i426R16i498R17R18gR19r26R20jR21:5:3r18oR14oR15i426R16i441R17R18gR19r26R20jR21:1:1r25goR14oR15i444R16i498R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i444R16i448R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i449R16i465R17R18gR19jR4:3:0R20jR21:9:2oR14oR15i449R16i463R17R18gR19r50R20jR21:1:1r49gajy14:hxsl.Component:0:0hgoR14oR15i467R16i491R17R18gR19r83R20jR21:5:3jR23:1:0oR14oR15i467R16i483R17R18gR19r83R20jR21:9:2oR14oR15i467R16i481R17R18gR19r50R20jR21:1:1r49gajR34:1:0hgoR14oR15i486R16i491R17R18gR19r83R20jR21:1:1oR0y5:flipYR9i-344R5jR10:2:0R11r83gggoR14oR15i493R16i494R17R18gR19r83R20jR21:0:1jy10:hxsl.Const:3:1zgoR14oR15i496R16i497R17R18gR19r83R20jR21:0:1jR36:3:1i1ghgghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-355R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i207R16i331R17y77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FMinMaxShader.hxgR19r3R20jR21:4:1aoR14oR15i213R16i244R17R38gR19r3R20jR21:7:2oR0y1:aR9i-356R5r23R11jR4:5:2i4r16goR14oR15i221R16i243R17R38gR19r132R20jR21:8:2oR14oR15i221R16i225R17R38gR19jR4:14:1aoR3r132R12aoR0y1:_R11jR4:10:0goR0R30R11jR4:5:2i2r16ghghR20jR21:2:1jR33:33:0gaoR14oR15i221R16i225R17R38gR19r141R20jR21:1:1oR0y4:texAR9i-350R5r104R11r141ggoR14oR15i230R16i242R17R38gR19r37R20jR21:1:1r40ghggoR14oR15i249R16i280R17R38gR19r3R20jR21:7:2oR0y1:bR9i-357R5r23R11r132goR14oR15i257R16i279R17R38gR19r132R20jR21:8:2oR14oR15i257R16i261R17R38gR19jR4:14:1aoR3r132R12aoR0R40R11r141gr142hghR20jR21:2:1r145gaoR14oR15i257R16i261R17R38gR19r141R20jR21:1:1oR0y4:texBR9i-351R5r104R11r141ggoR14oR15i266R16i278R17R38gR19r37R20jR21:1:1r40ghggoR14oR15i285R16i325R17R38gR19r31R20jR21:5:3r18oR14oR15i285R16i295R17R38gR19r31R20jR21:1:1r32goR14oR15i298R16i325R17R38gR19r132R20jR21:10:3oR14oR15i298R16i303R17R38gR19jR4:2:0R20jR21:1:1oR0y5:isMaxy10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-352R5r104R11r189ggoR14oR15i306R16i314R17R38gR19r132R20jR21:8:2oR14oR15i306R16i309R17R38gR19jR4:14:1aoR3r132R12aoR0R39R11r132goR0R42R11r132ghghR20jR21:2:1jR33:22:0gaoR14oR15i310R16i311R17R38gR19r132R20jR21:1:1r131goR14oR15i312R16i313R17R38gR19r132R20jR21:1:1r159ghgoR14oR15i317R16i325R17R38gR19r132R20jR21:8:2oR14oR15i317R16i320R17R38gR19jR4:14:1ar199hR20jR21:2:1jR33:21:0gaoR14oR15i321R16i322R17R38gR19r132R20jR21:1:1r131goR14oR15i323R16i324R17R38gR19r132R20jR21:1:1r159ghggghgR12ahghy4:varsar46r103r22r32r40r150r173r190r5r58r121hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texA public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texA>
		<texA__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texA__>
		<get_texA get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texA>
		<set_texA get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texA>
		<texB public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texB>
		<texB__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texB__>
		<get_texB get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texB>
		<set_texB get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texB>
		<isMax public="1" get="accessor" set="accessor"><x path="Bool"/></isMax>
		<isMax__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</isMax__>
		<get_isMax get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isMax>
		<set_isMax get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isMax>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var texA:Sampler2D;
	@param var texB:Sampler2D;
	@const var isMax:Bool;
	function fragment() {
		var a = texA.get(calculatedUV);
		var b = texB.get(calculatedUV);
		pixelColor = isMax ? max(a, b) : min(a, b);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.CubeMinMaxShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/MinMaxShader.hx" module="h3d.shader.MinMaxShader">
		<extends path="h3d.shader.ScreenShader"/>
		<SRC expr="&quot;oy4:namey27:h3d.shader.CubeMinMaxShadery4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-334R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini330y3:maxi396y4:filey77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FScreenShader.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i336R16i361R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i336R16i348R17R18gR19r17R20jR21:1:1oR0y5:colorR9i-327y6:parentoR0y6:outputR9i-325R5jR10:4:0R11jR4:13:1aoR0y8:positionR9i-326R25r22R5r23R11jR4:5:2i4r16gr21hgR5r23R11r17ggoR14oR15i351R16i361R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y10:pixelColorR9i-328R5r23R11r31gggoR14oR15i367R16i390R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i367R16i379R17R18gR19r37R20jR21:1:1oR0y12:calculatedUVR9i-329R5r23R11r37ggoR14oR15i382R16i390R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y2:uvR9i-323R25oR0y5:inputR9i-321R5jR10:1:0R11jR4:13:1aoR0R27R9i-322R25r46R5r47R11jR4:5:2i2r16gr45hgR5r47R11r44ggghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-335R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i420R16i504R17R18gR19r3R20jR21:4:1aoR14oR15i426R16i498R17R18gR19r26R20jR21:5:3r18oR14oR15i426R16i441R17R18gR19r26R20jR21:1:1r25goR14oR15i444R16i498R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i444R16i448R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i449R16i465R17R18gR19jR4:3:0R20jR21:9:2oR14oR15i449R16i463R17R18gR19r50R20jR21:1:1r49gajy14:hxsl.Component:0:0hgoR14oR15i467R16i491R17R18gR19r83R20jR21:5:3jR23:1:0oR14oR15i467R16i483R17R18gR19r83R20jR21:9:2oR14oR15i467R16i481R17R18gR19r50R20jR21:1:1r49gajR34:1:0hgoR14oR15i486R16i491R17R18gR19r83R20jR21:1:1oR0y5:flipYR9i-324R5jR10:2:0R11r83gggoR14oR15i493R16i494R17R18gR19r83R20jR21:0:1jy10:hxsl.Const:3:1zgoR14oR15i496R16i497R17R18gR19r83R20jR21:0:1jR36:3:1i1ghgghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-336R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i561R16i740R17y77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FMinMaxShader.hxgR19r3R20jR21:4:1aoR14oR15i567R16i601R17R38gR19r3R20jR21:7:2oR0R30R9i-337R5r23R11r37goR14oR15i576R16i600R17R38gR19r37R20jR21:5:3jR23:3:0oR14oR15i576R16i594R17R38gR19r37R20jR21:5:3r92oR14oR15i576R16i588R17R38gR19r37R20jR21:1:1r40goR14oR15i591R16i594R17R38gR19r83R20jR21:0:1jR36:3:1d2ggoR14oR15i597R16i600R17R38gR19r83R20jR21:0:1jR36:3:1d1gggoR14oR15i606R16i635R17R38gR19r3R20jR21:7:2oR0y3:dirR9i-338R5r23R11jR4:5:2i3r16goR14oR15i616R16i634R17R38gR19r154R20jR21:5:3r92oR14oR15i616R16i628R17R38gR19jR4:5:2i3r16R20jR21:8:2oR14oR15i616R16i620R17R38gR19jR4:14:1ahR20jR21:2:1jR33:39:0gaoR14oR15i621R16i623R17R38gR19r37R20jR21:1:1r131goR14oR15i626R16i627R17R38gR19r83R20jR21:0:1jR36:3:1i1ghgoR14oR15i631R16i634R17R38gR19jR4:6:0R20jR21:1:1oR0y3:matR9i-333R5r104R11r177ggggoR14oR15i640R16i662R17R38gR19r3R20jR21:7:2oR0y1:aR9i-339R5r23R11jR4:5:2i4r16goR14oR15i648R16i661R17R38gR19r185R20jR21:8:2oR14oR15i648R16i652R17R38gR19jR4:14:1aoR3r185R12aoR0y1:_R11jR4:12:0goR0y6:normalR11r154ghghR20jR21:2:1jR33:33:0gaoR14oR15i648R16i652R17R38gR19r194R20jR21:1:1oR0y4:texAR9i-330R5r104R11r194ggoR14oR15i657R16i660R17R38gR19r154R20jR21:1:1r153ghggoR14oR15i667R16i689R17R38gR19r3R20jR21:7:2oR0y1:bR9i-340R5r23R11r185goR14oR15i675R16i688R17R38gR19r185R20jR21:8:2oR14oR15i675R16i679R17R38gR19jR4:14:1aoR3r185R12aoR0R42R11r194gr195hghR20jR21:2:1r197gaoR14oR15i675R16i679R17R38gR19r194R20jR21:1:1oR0y4:texBR9i-331R5r104R11r194ggoR14oR15i684R16i687R17R38gR19r154R20jR21:1:1r153ghggoR14oR15i694R16i734R17R38gR19r31R20jR21:5:3r18oR14oR15i694R16i704R17R38gR19r31R20jR21:1:1r32goR14oR15i707R16i734R17R38gR19r185R20jR21:10:3oR14oR15i707R16i712R17R38gR19jR4:2:0R20jR21:1:1oR0y5:isMaxy10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-332R5r104R11r241ggoR14oR15i715R16i723R17R38gR19r185R20jR21:8:2oR14oR15i715R16i718R17R38gR19jR4:14:1aoR3r185R12aoR0R41R11r185goR0R45R11r185ghghR20jR21:2:1jR33:22:0gaoR14oR15i719R16i720R17R38gR19r185R20jR21:1:1r184goR14oR15i721R16i722R17R38gR19r185R20jR21:1:1r211ghgoR14oR15i726R16i734R17R38gR19r185R20jR21:8:2oR14oR15i726R16i729R17R38gR19jR4:14:1ar251hR20jR21:2:1jR33:21:0gaoR14oR15i730R16i731R17R38gR19r185R20jR21:1:1r184goR14oR15i732R16i733R17R38gR19r185R20jR21:1:1r211ghggghgR12ahghy4:varsar46r103r22r32r40r202r225r242r178r5r58r121hg&quot;" line="21" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey27:h3d.shader.CubeMinMaxShadery4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y8:__init__y2:idi-334R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini330y3:maxi396y4:filey77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FScreenShader.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i336R16i361R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i336R16i348R17R18gR19r17R20jR21:1:1oR0y5:colorR9i-327y6:parentoR0y6:outputR9i-325R5jR10:4:0R11jR4:13:1aoR0y8:positionR9i-326R25r22R5r23R11jR4:5:2i4r16gr21hgR5r23R11r17ggoR14oR15i351R16i361R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y10:pixelColorR9i-328R5r23R11r31gggoR14oR15i367R16i390R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i367R16i379R17R18gR19r37R20jR21:1:1oR0y12:calculatedUVR9i-329R5r23R11r37ggoR14oR15i382R16i390R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y2:uvR9i-323R25oR0y5:inputR9i-321R5jR10:1:0R11jR4:13:1aoR0R27R9i-322R25r46R5r47R11jR4:5:2i2r16gr45hgR5r47R11r44ggghgR12ahgoR3r3R5jR6:0:0R7oR0y6:vertexR9i-335R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i420R16i504R17R18gR19r3R20jR21:4:1aoR14oR15i426R16i498R17R18gR19r26R20jR21:5:3r18oR14oR15i426R16i441R17R18gR19r26R20jR21:1:1r25goR14oR15i444R16i498R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i444R16i448R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i449R16i465R17R18gR19jR4:3:0R20jR21:9:2oR14oR15i449R16i463R17R18gR19r50R20jR21:1:1r49gajy14:hxsl.Component:0:0hgoR14oR15i467R16i491R17R18gR19r83R20jR21:5:3jR23:1:0oR14oR15i467R16i483R17R18gR19r83R20jR21:9:2oR14oR15i467R16i481R17R18gR19r50R20jR21:1:1r49gajR34:1:0hgoR14oR15i486R16i491R17R18gR19r83R20jR21:1:1oR0y5:flipYR9i-324R5jR10:2:0R11r83gggoR14oR15i493R16i494R17R18gR19r83R20jR21:0:1jy10:hxsl.Const:3:1zgoR14oR15i496R16i497R17R18gR19r83R20jR21:0:1jR36:3:1i1ghgghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-336R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i561R16i740R17y77:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FMinMaxShader.hxgR19r3R20jR21:4:1aoR14oR15i567R16i601R17R38gR19r3R20jR21:7:2oR0R30R9i-337R5r23R11r37goR14oR15i576R16i600R17R38gR19r37R20jR21:5:3jR23:3:0oR14oR15i576R16i594R17R38gR19r37R20jR21:5:3r92oR14oR15i576R16i588R17R38gR19r37R20jR21:1:1r40goR14oR15i591R16i594R17R38gR19r83R20jR21:0:1jR36:3:1d2ggoR14oR15i597R16i600R17R38gR19r83R20jR21:0:1jR36:3:1d1gggoR14oR15i606R16i635R17R38gR19r3R20jR21:7:2oR0y3:dirR9i-338R5r23R11jR4:5:2i3r16goR14oR15i616R16i634R17R38gR19r154R20jR21:5:3r92oR14oR15i616R16i628R17R38gR19jR4:5:2i3r16R20jR21:8:2oR14oR15i616R16i620R17R38gR19jR4:14:1ahR20jR21:2:1jR33:39:0gaoR14oR15i621R16i623R17R38gR19r37R20jR21:1:1r131goR14oR15i626R16i627R17R38gR19r83R20jR21:0:1jR36:3:1i1ghgoR14oR15i631R16i634R17R38gR19jR4:6:0R20jR21:1:1oR0y3:matR9i-333R5r104R11r177ggggoR14oR15i640R16i662R17R38gR19r3R20jR21:7:2oR0y1:aR9i-339R5r23R11jR4:5:2i4r16goR14oR15i648R16i661R17R38gR19r185R20jR21:8:2oR14oR15i648R16i652R17R38gR19jR4:14:1aoR3r185R12aoR0y1:_R11jR4:12:0goR0y6:normalR11r154ghghR20jR21:2:1jR33:33:0gaoR14oR15i648R16i652R17R38gR19r194R20jR21:1:1oR0y4:texAR9i-330R5r104R11r194ggoR14oR15i657R16i660R17R38gR19r154R20jR21:1:1r153ghggoR14oR15i667R16i689R17R38gR19r3R20jR21:7:2oR0y1:bR9i-340R5r23R11r185goR14oR15i675R16i688R17R38gR19r185R20jR21:8:2oR14oR15i675R16i679R17R38gR19jR4:14:1aoR3r185R12aoR0R42R11r194gr195hghR20jR21:2:1r197gaoR14oR15i675R16i679R17R38gR19r194R20jR21:1:1oR0y4:texBR9i-331R5r104R11r194ggoR14oR15i684R16i687R17R38gR19r154R20jR21:1:1r153ghggoR14oR15i694R16i734R17R38gR19r31R20jR21:5:3r18oR14oR15i694R16i704R17R38gR19r31R20jR21:1:1r32goR14oR15i707R16i734R17R38gR19r185R20jR21:10:3oR14oR15i707R16i712R17R38gR19jR4:2:0R20jR21:1:1oR0y5:isMaxy10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-332R5r104R11r241ggoR14oR15i715R16i723R17R38gR19r185R20jR21:8:2oR14oR15i715R16i718R17R38gR19jR4:14:1aoR3r185R12aoR0R41R11r185goR0R45R11r185ghghR20jR21:2:1jR33:22:0gaoR14oR15i719R16i720R17R38gR19r185R20jR21:1:1r184goR14oR15i721R16i722R17R38gR19r185R20jR21:1:1r211ghgoR14oR15i726R16i734R17R38gR19r185R20jR21:8:2oR14oR15i726R16i729R17R38gR19jR4:14:1ar251hR20jR21:2:1jR33:21:0gaoR14oR15i730R16i731R17R38gR19r185R20jR21:1:1r184goR14oR15i732R16i733R17R38gR19r185R20jR21:1:1r211ghggghgR12ahghy4:varsar46r103r22r32r40r202r225r242r178r5r58r121hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texA public="1" get="accessor" set="accessor"><t path="hxsl.SamplerCube"/></texA>
		<texA__>
			<t path="hxsl.SamplerCube"/>
			<meta><m n=":noCompletion"/></meta>
		</texA__>
		<get_texA get="inline" set="null" line="21">
			<f a=""><t path="hxsl.SamplerCube"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texA>
		<set_texA get="inline" set="null" line="21">
			<f a="_v">
				<t path="hxsl.SamplerCube"/>
				<t path="hxsl.SamplerCube"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texA>
		<texB public="1" get="accessor" set="accessor"><t path="hxsl.SamplerCube"/></texB>
		<texB__>
			<t path="hxsl.SamplerCube"/>
			<meta><m n=":noCompletion"/></meta>
		</texB__>
		<get_texB get="inline" set="null" line="21">
			<f a=""><t path="hxsl.SamplerCube"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texB>
		<set_texB get="inline" set="null" line="21">
			<f a="_v">
				<t path="hxsl.SamplerCube"/>
				<t path="hxsl.SamplerCube"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texB>
		<isMax public="1" get="accessor" set="accessor"><x path="Bool"/></isMax>
		<isMax__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</isMax__>
		<get_isMax get="inline" set="null" line="21">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isMax>
		<set_isMax get="inline" set="null" line="21">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isMax>
		<mat public="1" get="accessor" set="accessor"><t path="hxsl.Matrix"/></mat>
		<mat__ expr="new hxsl.Types.Matrix()">
			<t path="hxsl.Matrix"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Matrix()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</mat__>
		<get_mat get="inline" set="null" line="21">
			<f a=""><t path="hxsl.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_mat>
		<set_mat get="inline" set="null" line="21">
			<f a="_v">
				<t path="hxsl.Matrix"/>
				<t path="hxsl.Matrix"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_mat>
		<updateConstants public="1" set="method" line="21" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="21" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="21" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="21" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":src"><e>{
	@param var texA:SamplerCube;
	@param var texB:SamplerCube;
	@const var isMax:Bool;
	@param var mat:Mat3;
	function fragment() {
		var uv = calculatedUV * 2.0 - 1.0;
		var dir = vec3(uv, 1) * mat;
		var a = texA.get(dir);
		var b = texB.get(dir);
		pixelColor = isMax ? max(a, b) : min(a, b);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.NormalMap" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/NormalMap.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey20:h3d.shader.NormalMapy4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y14:__init__vertexy2:idi-169R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini588y3:maxi716y4:filey74:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FNormalMap.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i594R16i710R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i594R16i612R17R18gR19r17R20jR21:1:1oR0y18:transformedTangentR9i-168R5jR10:3:0R11r17ggoR14oR15i615R16i710R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i615R16i619R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i620R16i659R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:1:0oR14oR15i620R16i633R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y7:tangentR9i-163y6:parentoR0y5:inputR9i-161R5jR10:1:0R11jR4:13:1aoR0y6:normalR9i-162R27r42R5r43R11jR4:5:2i3r16gr41hgR5r43R11r40ggoR14oR15i636R16i659R17R18gR19jR4:6:0R20jR21:8:2oR14oR15i636R16i652R17R18gR19jR4:14:1ahR20jR21:2:1jR25:48:0gaoR14oR15i636R16i652R17R18gR19jR4:7:0R20jR21:1:1oR0y9:modelViewy10:qualifiersajy17:hxsl.VarQualifier:3:0hR9i-160R27oR0y6:globalR9i-159R5jR10:0:0R11jR4:13:1ar62hgR5r66R11r61gghggoR14oR15i660R16i709R17R18gR19jR4:3:0R20jR21:10:3oR14oR15i660R16i698R17R18gR19jR4:2:0R20jR21:5:3jR23:7:0oR14oR15i660R16i692R17R18gR19r74R20jR21:8:2oR14oR15i660R16i673R17R18gR19jR4:14:1aoR3r74R12aoR0y1:_R11r40goR0y1:bR11r36ghghR20jR21:2:1jR25:29:0gaoR14oR15i660R16i673R17R18gR19r40R20jR21:1:1r41goR14oR15i678R16i691R17R18gR19r40R20jR21:1:1r41ghgoR14oR15i695R16i698R17R18gR19r74R20jR21:0:1jy10:hxsl.Const:3:1d0.5ggoR14oR15i701R16i703R17R18gR19r74R20jR21:0:1jR36:3:1d1goR14oR15i706R16i709R17R18gR19r74R20jR21:0:1jR36:3:1d-1gghgghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-170R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i742R16i1014R17R18gR19r3R20jR21:4:1aoR14oR15i748R16i774R17R18gR19r3R20jR21:7:2oR0y1:nR9i-171R5jR10:4:0R11jR4:5:2i3r16goR14oR15i756R16i773R17R18gR19r131R20jR21:1:1oR0y17:transformedNormalR9i-167R5r130R11r131gggoR14oR15i779R16i828R17R18gR19r3R20jR21:7:2oR0y2:nfR9i-172R5r130R11r36goR14oR15i788R16i827R17R18gR19r36R20jR21:8:2oR14oR15i788R16i800R17R18gR19jR4:14:1aoR3r36R12aoR0y5:valueR11jR4:5:2i4r16ghghR20jR21:2:1jR25:55:0gaoR14oR15i801R16i826R17R18gR19r148R20jR21:8:2oR14oR15i801R16i808R17R18gR19jR4:14:1aoR3r148R12aoR0R34R11jR4:10:0goR0y2:uvR11jR4:5:2i2r16ghghR20jR21:2:1jR25:33:0gaoR14oR15i801R16i808R17R18gR19r161R20jR21:1:1oR0y7:textureR9i-164R5jR10:2:0R11r161ggoR14oR15i813R16i825R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y12:calculatedUVR9i-165R5r130R11r175gghghggoR14oR15i833R16i879R17R18gR19r3R20jR21:7:2oR0y4:tanXR9i-173R5r130R11r36goR14oR15i844R16i878R17R18gR19r36R20jR21:8:2oR14oR15i844R16i866R17R18gR19jR4:14:1aoR3r36R12aoR0R34R11jR4:5:2i3r16ghghR20jR21:2:1jR25:31:0gaoR14oR15i844R16i866R17R18gR19r192R20jR21:9:2oR14oR15i844R16i862R17R18gR19r17R20jR21:1:1r21gajy14:hxsl.Component:0:0jR46:1:0jR46:2:0hghggoR14oR15i884R16i933R17R18gR19r3R20jR21:7:2oR0y4:tanYR9i-174R5r130R11r36goR14oR15i895R16i932R17R18gR19r36R20jR21:5:3r37oR14oR15i895R16i908R17R18gR19r36R20jR21:8:2oR14oR15i895R16i896R17R18gR19jR4:14:1aoR3r36R12aoR0R34R11r131goR0R35R11r36ghghR20jR21:2:1jR25:30:0gaoR14oR15i895R16i896R17R18gR19r131R20jR21:1:1r129goR14oR15i903R16i907R17R18gR19r36R20jR21:1:1r183ghgoR14oR15i911R16i932R17R18gR19r74R20jR21:6:2jy15:haxe.macro.Unop:3:0oR14oR15i912R16i932R17R18gR19r74R20jR21:9:2oR14oR15i912R16i930R17R18gR19r17R20jR21:1:1r21gajR46:3:0hggggoR14oR15i938R16i1008R17R18gR19r131R20jR21:5:3r18oR14oR15i938R16i955R17R18gR19r131R20jR21:1:1r134goR14oR15i958R16i1008R17R18gR19r36R20jR21:8:2oR14oR15i958R16i996R17R18gR19jR4:14:1aoR3r36R12aoR0R34R11jR4:5:2i3r16ghghR20jR21:2:1r194gaoR14oR15i958R16i996R17R18gR19r261R20jR21:3:1oR14oR15i959R16i995R17R18gR19r261R20jR21:5:3jR23:0:0oR14oR15i959R16i984R17R18gR19jR4:5:2i3r16R20jR21:5:3r269oR14oR15i959R16i970R17R18gR19r36R20jR21:5:3r37oR14oR15i959R16i963R17R18gR19r74R20jR21:9:2oR14oR15i959R16i961R17R18gR19r36R20jR21:1:1r139gar203hgoR14oR15i966R16i970R17R18gR19r36R20jR21:1:1r183ggoR14oR15i973R16i984R17R18gR19r36R20jR21:5:3r37oR14oR15i973R16i977R17R18gR19r74R20jR21:9:2oR14oR15i973R16i975R17R18gR19r36R20jR21:1:1r139gar204hgoR14oR15i980R16i984R17R18gR19r36R20jR21:1:1r211gggoR14oR15i987R16i995R17R18gR19r131R20jR21:5:3r37oR14oR15i987R16i991R17R18gR19r74R20jR21:9:2oR14oR15i987R16i989R17R18gR19r36R20jR21:1:1r139gar205hgoR14oR15i994R16i995R17R18gR19r131R20jR21:1:1r129gggghgghgR12ahghy4:varsaoR0y6:cameraR9i-156R5r66R11jR4:13:1aoR0y8:positionR9i-157R27r320R5r66R11jR4:5:2i3r16goR0y3:dirR9i-158R27r320R5r22R11jR4:5:2i3r16ghgr65r42r170r176oR0y19:transformedPositionR9i-166R5r130R11jR4:5:2i3r16gr134r21r5r119hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey20:h3d.shader.NormalMapy4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y14:__init__vertexy2:idi-169R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini588y3:maxi716y4:filey74:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FNormalMap.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i594R16i710R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i594R16i612R17R18gR19r17R20jR21:1:1oR0y18:transformedTangentR9i-168R5jR10:3:0R11r17ggoR14oR15i615R16i710R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i615R16i619R17R18gR19jR4:14:1ahR20jR21:2:1jy12:hxsl.TGlobal:40:0gaoR14oR15i620R16i659R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:1:0oR14oR15i620R16i633R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y7:tangentR9i-163y6:parentoR0y5:inputR9i-161R5jR10:1:0R11jR4:13:1aoR0y6:normalR9i-162R27r42R5r43R11jR4:5:2i3r16gr41hgR5r43R11r40ggoR14oR15i636R16i659R17R18gR19jR4:6:0R20jR21:8:2oR14oR15i636R16i652R17R18gR19jR4:14:1ahR20jR21:2:1jR25:48:0gaoR14oR15i636R16i652R17R18gR19jR4:7:0R20jR21:1:1oR0y9:modelViewy10:qualifiersajy17:hxsl.VarQualifier:3:0hR9i-160R27oR0y6:globalR9i-159R5jR10:0:0R11jR4:13:1ar62hgR5r66R11r61gghggoR14oR15i660R16i709R17R18gR19jR4:3:0R20jR21:10:3oR14oR15i660R16i698R17R18gR19jR4:2:0R20jR21:5:3jR23:7:0oR14oR15i660R16i692R17R18gR19r74R20jR21:8:2oR14oR15i660R16i673R17R18gR19jR4:14:1aoR3r74R12aoR0y1:_R11r40goR0y1:bR11r36ghghR20jR21:2:1jR25:29:0gaoR14oR15i660R16i673R17R18gR19r40R20jR21:1:1r41goR14oR15i678R16i691R17R18gR19r40R20jR21:1:1r41ghgoR14oR15i695R16i698R17R18gR19r74R20jR21:0:1jy10:hxsl.Const:3:1d0.5ggoR14oR15i701R16i703R17R18gR19r74R20jR21:0:1jR36:3:1d1goR14oR15i706R16i709R17R18gR19r74R20jR21:0:1jR36:3:1d-1gghgghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-170R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i742R16i1014R17R18gR19r3R20jR21:4:1aoR14oR15i748R16i774R17R18gR19r3R20jR21:7:2oR0y1:nR9i-171R5jR10:4:0R11jR4:5:2i3r16goR14oR15i756R16i773R17R18gR19r131R20jR21:1:1oR0y17:transformedNormalR9i-167R5r130R11r131gggoR14oR15i779R16i828R17R18gR19r3R20jR21:7:2oR0y2:nfR9i-172R5r130R11r36goR14oR15i788R16i827R17R18gR19r36R20jR21:8:2oR14oR15i788R16i800R17R18gR19jR4:14:1aoR3r36R12aoR0y5:valueR11jR4:5:2i4r16ghghR20jR21:2:1jR25:55:0gaoR14oR15i801R16i826R17R18gR19r148R20jR21:8:2oR14oR15i801R16i808R17R18gR19jR4:14:1aoR3r148R12aoR0R34R11jR4:10:0goR0y2:uvR11jR4:5:2i2r16ghghR20jR21:2:1jR25:33:0gaoR14oR15i801R16i808R17R18gR19r161R20jR21:1:1oR0y7:textureR9i-164R5jR10:2:0R11r161ggoR14oR15i813R16i825R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y12:calculatedUVR9i-165R5r130R11r175gghghggoR14oR15i833R16i879R17R18gR19r3R20jR21:7:2oR0y4:tanXR9i-173R5r130R11r36goR14oR15i844R16i878R17R18gR19r36R20jR21:8:2oR14oR15i844R16i866R17R18gR19jR4:14:1aoR3r36R12aoR0R34R11jR4:5:2i3r16ghghR20jR21:2:1jR25:31:0gaoR14oR15i844R16i866R17R18gR19r192R20jR21:9:2oR14oR15i844R16i862R17R18gR19r17R20jR21:1:1r21gajy14:hxsl.Component:0:0jR46:1:0jR46:2:0hghggoR14oR15i884R16i933R17R18gR19r3R20jR21:7:2oR0y4:tanYR9i-174R5r130R11r36goR14oR15i895R16i932R17R18gR19r36R20jR21:5:3r37oR14oR15i895R16i908R17R18gR19r36R20jR21:8:2oR14oR15i895R16i896R17R18gR19jR4:14:1aoR3r36R12aoR0R34R11r131goR0R35R11r36ghghR20jR21:2:1jR25:30:0gaoR14oR15i895R16i896R17R18gR19r131R20jR21:1:1r129goR14oR15i903R16i907R17R18gR19r36R20jR21:1:1r183ghgoR14oR15i911R16i932R17R18gR19r74R20jR21:6:2jy15:haxe.macro.Unop:3:0oR14oR15i912R16i932R17R18gR19r74R20jR21:9:2oR14oR15i912R16i930R17R18gR19r17R20jR21:1:1r21gajR46:3:0hggggoR14oR15i938R16i1008R17R18gR19r131R20jR21:5:3r18oR14oR15i938R16i955R17R18gR19r131R20jR21:1:1r134goR14oR15i958R16i1008R17R18gR19r36R20jR21:8:2oR14oR15i958R16i996R17R18gR19jR4:14:1aoR3r36R12aoR0R34R11jR4:5:2i3r16ghghR20jR21:2:1r194gaoR14oR15i958R16i996R17R18gR19r261R20jR21:3:1oR14oR15i959R16i995R17R18gR19r261R20jR21:5:3jR23:0:0oR14oR15i959R16i984R17R18gR19jR4:5:2i3r16R20jR21:5:3r269oR14oR15i959R16i970R17R18gR19r36R20jR21:5:3r37oR14oR15i959R16i963R17R18gR19r74R20jR21:9:2oR14oR15i959R16i961R17R18gR19r36R20jR21:1:1r139gar203hgoR14oR15i966R16i970R17R18gR19r36R20jR21:1:1r183ggoR14oR15i973R16i984R17R18gR19r36R20jR21:5:3r37oR14oR15i973R16i977R17R18gR19r74R20jR21:9:2oR14oR15i973R16i975R17R18gR19r36R20jR21:1:1r139gar204hgoR14oR15i980R16i984R17R18gR19r36R20jR21:1:1r211gggoR14oR15i987R16i995R17R18gR19r131R20jR21:5:3r37oR14oR15i987R16i991R17R18gR19r74R20jR21:9:2oR14oR15i987R16i989R17R18gR19r36R20jR21:1:1r139gar205hgoR14oR15i994R16i995R17R18gR19r131R20jR21:1:1r129gggghgghgR12ahghy4:varsaoR0y6:cameraR9i-156R5r66R11jR4:13:1aoR0y8:positionR9i-157R27r320R5r66R11jR4:5:2i3r16goR0y3:dirR9i-158R27r320R5r22R11jR4:5:2i3r16ghgr65r42r170r176oR0y19:transformedPositionR9i-166R5r130R11jR4:5:2i3r16gr134r21r5r119hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture>
		<texture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="43"><f a="?texture">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@global var camera:{ var position : Vec3; @var};
	@global var global:{ @perObject};
	@input var input:{ var normal : Vec3; var tangent : Vec3};
	@param var texture:Sampler2D;
	var calculatedUV:Vec2;
	var transformedPosition:Vec3;
	var transformedNormal:Vec3;
	@var var transformedTangent:Vec4;
	function __init__vertex() {
		transformedTangent = vec4(input.tangent * global.modelView.mat3(), input.tangent.dot(input.tangent) > 0.5 ? 1. : -1.);
	};
	function fragment() {
		var n = transformedNormal;
		var nf = unpackNormal(texture.get(calculatedUV));
		var tanX = transformedTangent.xyz.normalize();
		var tanY = n.cross(tanX) * -transformedTangent.w;
		transformedNormal = (nf.x * tanX + nf.y * tanY + nf.z * n).normalize();
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.Shadow" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Shadow.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey17:h3d.shader.Shadowy4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:1:0y3:refoR0y8:fragmenty2:idi-396R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini366y3:maxi704y4:filey71:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FShadow.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i372R16i427R17R18gR19r3R20jR21:7:2oR0y9:shadowPosR9i-397R5jR10:4:0R11jR4:5:2i3jy12:hxsl.VecType:1:0goR14oR15i388R16i426R17R18gR19r19R20jR21:5:3jy16:haxe.macro.Binop:1:0oR14oR15i388R16i412R17R18gR19jR4:5:2i3r18R20jR21:1:1oR0y24:pixelTransformedPositionR9i-394R5r17R11r25ggoR14oR15i415R16i426R17R18gR19jR4:8:0R20jR21:1:1oR0y4:projR9i-388y6:parentoR0y6:shadowR9i-386R5jR10:0:0R11jR4:13:1aoR0y3:mapR9i-387R27r32R5r33R11jR4:17:1i1gr31oR0y5:colorR9i-389R27r32R5r33R11jR4:5:2i3r18goR0y5:powerR9i-390R27r32R5r33R11jR4:3:0goR0y4:biasR9i-391R27r32R5r33R11r40ghgR5r33R11r30ggggoR14oR15i432R16i485R17R18gR19r3R20jR21:7:2oR0y5:depthR9i-398R5r17R11r40goR14oR15i444R16i484R17R18gR19r40R20jR21:8:2oR14oR15i444R16i454R17R18gR19jR4:14:1aoR3r40R12aoR0y1:_R11r36goR0y2:uvR11jR4:5:2i2r18ghghR20jR21:2:1jy12:hxsl.TGlobal:61:0gaoR14oR15i444R16i454R17R18gR19r36R20jR21:1:1r35goR14oR15i459R16i483R17R18gR19r58R20jR21:8:2oR14oR15i459R16i469R17R18gR19jR4:14:1aoR3r58R12aoR0y9:screenPosR11r58ghghR20jR21:2:1jR36:56:0gaoR14oR15i470R16i482R17R18gR19jR4:5:2i2r18R20jR21:9:2oR14oR15i470R16i479R17R18gR19r19R20jR21:1:1r16gajy14:hxsl.Component:0:0jR38:1:0hghghggoR14oR15i490R16i524R17R18gR19r3R20jR21:7:2oR0y4:zMaxR9i-399R5r17R11r40goR14oR15i501R16i523R17R18gR19r40R20jR21:8:2oR14oR15i501R16i512R17R18gR19jR4:14:1aoR3r40R12aoR0R34R11r40ghghR20jR21:2:1jR36:51:0gaoR14oR15i501R16i512R17R18gR19r40R20jR21:9:2oR14oR15i501R16i510R17R18gR19r19R20jR21:1:1r16gajR38:2:0hghggoR14oR15i529R16i580R17R18gR19r3R20jR21:7:2oR0y5:deltaR9i-400R5r17R11r40goR14oR15i541R16i579R17R18gR19r40R20jR21:5:3jR24:3:0oR14oR15i541R16i572R17R18gR19r40R20jR21:8:2oR14oR15i541R16i562R17R18gR19jR4:14:1aoR3r40R12aoR0R34R11r40goR0y1:bR11r40ghghR20jR21:2:1jR36:21:0gaoR14oR15i541R16i562R17R18gR19r40R20jR21:3:1oR14oR15i542R16i561R17R18gR19r40R20jR21:5:3jR24:0:0oR14oR15i542R16i547R17R18gR19r40R20jR21:1:1r48goR14oR15i550R16i561R17R18gR19r40R20jR21:1:1r41gggoR14oR15i567R16i571R17R18gR19r40R20jR21:1:1r93ghgoR14oR15i575R16i579R17R18gR19r40R20jR21:1:1r93gggoR14oR15i585R16i637R17R18gR19r3R20jR21:7:2oR0y5:shadeR9i-401R5r17R11r40goR14oR15i597R16i636R17R18gR19r40R20jR21:8:2oR14oR15i597R16i625R17R18gR19jR4:14:1aoR3r40R12aoR0R34R11r40ghghR20jR21:2:1r103gaoR14oR15i597R16i625R17R18gR19r40R20jR21:8:2oR14oR15i597R16i600R17R18gR19jR4:14:1aoR3r40R12aoR0y5:valueR11r40ghghR20jR21:2:1jR36:9:0gaoR14oR15i602R16i622R17R18gR19r40R20jR21:5:3r22oR14oR15i602R16i614R17R18gR19r40R20jR21:1:1r39goR14oR15i617R16i622R17R18gR19r40R20jR21:1:1r118gghghggoR14oR15i642R16i698R17R18gR19jR4:5:2i3r18R20jR21:5:3jR24:20:1r22oR14oR15i642R16i656R17R18gR19r197R20jR21:9:2oR14oR15i642R16i652R17R18gR19jR4:5:2i4r18R20jR21:1:1oR0y10:pixelColorR9i-392R5r17R11r203ggar85r86r112hgoR14oR15i660R16i698R17R18gR19jR4:5:2i3r18R20jR21:5:3r139oR14oR15i660R16i690R17R18gR19r210R20jR21:5:3r22oR14oR15i660R16i671R17R18gR19r40R20jR21:3:1oR14oR15i661R16i670R17R18gR19r40R20jR21:5:3r121oR14oR15i661R16i662R17R18gR19r40R20jR21:0:1jy10:hxsl.Const:3:1i1goR14oR15i665R16i670R17R18gR19r40R20jR21:1:1r159gggoR14oR15i674R16i690R17R18gR19r210R20jR21:9:2oR14oR15i674R16i686R17R18gR19r38R20jR21:1:1r37gar85r86r112hggoR14oR15i693R16i698R17R18gR19r40R20jR21:1:1r159ggghgR12ahghy4:varsar32r204oR0y19:transformedPositionR9i-393R5r17R11jR4:5:2i3r18gr26oR0R22y10:qualifiersajy17:hxsl.VarQualifier:1:0hR9i-395R5jR10:3:0R11jR4:5:2i3r18gr5hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey17:h3d.shader.Shadowy4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:1:0y3:refoR0y8:fragmenty2:idi-396R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini366y3:maxi704y4:filey71:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FShadow.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i372R16i427R17R18gR19r3R20jR21:7:2oR0y9:shadowPosR9i-397R5jR10:4:0R11jR4:5:2i3jy12:hxsl.VecType:1:0goR14oR15i388R16i426R17R18gR19r19R20jR21:5:3jy16:haxe.macro.Binop:1:0oR14oR15i388R16i412R17R18gR19jR4:5:2i3r18R20jR21:1:1oR0y24:pixelTransformedPositionR9i-394R5r17R11r25ggoR14oR15i415R16i426R17R18gR19jR4:8:0R20jR21:1:1oR0y4:projR9i-388y6:parentoR0y6:shadowR9i-386R5jR10:0:0R11jR4:13:1aoR0y3:mapR9i-387R27r32R5r33R11jR4:17:1i1gr31oR0y5:colorR9i-389R27r32R5r33R11jR4:5:2i3r18goR0y5:powerR9i-390R27r32R5r33R11jR4:3:0goR0y4:biasR9i-391R27r32R5r33R11r40ghgR5r33R11r30ggggoR14oR15i432R16i485R17R18gR19r3R20jR21:7:2oR0y5:depthR9i-398R5r17R11r40goR14oR15i444R16i484R17R18gR19r40R20jR21:8:2oR14oR15i444R16i454R17R18gR19jR4:14:1aoR3r40R12aoR0y1:_R11r36goR0y2:uvR11jR4:5:2i2r18ghghR20jR21:2:1jy12:hxsl.TGlobal:61:0gaoR14oR15i444R16i454R17R18gR19r36R20jR21:1:1r35goR14oR15i459R16i483R17R18gR19r58R20jR21:8:2oR14oR15i459R16i469R17R18gR19jR4:14:1aoR3r58R12aoR0y9:screenPosR11r58ghghR20jR21:2:1jR36:56:0gaoR14oR15i470R16i482R17R18gR19jR4:5:2i2r18R20jR21:9:2oR14oR15i470R16i479R17R18gR19r19R20jR21:1:1r16gajy14:hxsl.Component:0:0jR38:1:0hghghggoR14oR15i490R16i524R17R18gR19r3R20jR21:7:2oR0y4:zMaxR9i-399R5r17R11r40goR14oR15i501R16i523R17R18gR19r40R20jR21:8:2oR14oR15i501R16i512R17R18gR19jR4:14:1aoR3r40R12aoR0R34R11r40ghghR20jR21:2:1jR36:51:0gaoR14oR15i501R16i512R17R18gR19r40R20jR21:9:2oR14oR15i501R16i510R17R18gR19r19R20jR21:1:1r16gajR38:2:0hghggoR14oR15i529R16i580R17R18gR19r3R20jR21:7:2oR0y5:deltaR9i-400R5r17R11r40goR14oR15i541R16i579R17R18gR19r40R20jR21:5:3jR24:3:0oR14oR15i541R16i572R17R18gR19r40R20jR21:8:2oR14oR15i541R16i562R17R18gR19jR4:14:1aoR3r40R12aoR0R34R11r40goR0y1:bR11r40ghghR20jR21:2:1jR36:21:0gaoR14oR15i541R16i562R17R18gR19r40R20jR21:3:1oR14oR15i542R16i561R17R18gR19r40R20jR21:5:3jR24:0:0oR14oR15i542R16i547R17R18gR19r40R20jR21:1:1r48goR14oR15i550R16i561R17R18gR19r40R20jR21:1:1r41gggoR14oR15i567R16i571R17R18gR19r40R20jR21:1:1r93ghgoR14oR15i575R16i579R17R18gR19r40R20jR21:1:1r93gggoR14oR15i585R16i637R17R18gR19r3R20jR21:7:2oR0y5:shadeR9i-401R5r17R11r40goR14oR15i597R16i636R17R18gR19r40R20jR21:8:2oR14oR15i597R16i625R17R18gR19jR4:14:1aoR3r40R12aoR0R34R11r40ghghR20jR21:2:1r103gaoR14oR15i597R16i625R17R18gR19r40R20jR21:8:2oR14oR15i597R16i600R17R18gR19jR4:14:1aoR3r40R12aoR0y5:valueR11r40ghghR20jR21:2:1jR36:9:0gaoR14oR15i602R16i622R17R18gR19r40R20jR21:5:3r22oR14oR15i602R16i614R17R18gR19r40R20jR21:1:1r39goR14oR15i617R16i622R17R18gR19r40R20jR21:1:1r118gghghggoR14oR15i642R16i698R17R18gR19jR4:5:2i3r18R20jR21:5:3jR24:20:1r22oR14oR15i642R16i656R17R18gR19r197R20jR21:9:2oR14oR15i642R16i652R17R18gR19jR4:5:2i4r18R20jR21:1:1oR0y10:pixelColorR9i-392R5r17R11r203ggar85r86r112hgoR14oR15i660R16i698R17R18gR19jR4:5:2i3r18R20jR21:5:3r139oR14oR15i660R16i690R17R18gR19r210R20jR21:5:3r22oR14oR15i660R16i671R17R18gR19r40R20jR21:3:1oR14oR15i661R16i670R17R18gR19r40R20jR21:5:3r121oR14oR15i661R16i662R17R18gR19r40R20jR21:0:1jy10:hxsl.Const:3:1i1goR14oR15i665R16i670R17R18gR19r40R20jR21:1:1r159gggoR14oR15i674R16i690R17R18gR19r210R20jR21:9:2oR14oR15i674R16i686R17R18gR19r38R20jR21:1:1r37gar85r86r112hggoR14oR15i693R16i698R17R18gR19r40R20jR21:1:1r159ggghgR12ahghy4:varsar32r204oR0y19:transformedPositionR9i-393R5r17R11jR4:5:2i3r18gr26oR0R22y10:qualifiersajy17:hxsl.VarQualifier:1:0hR9i-395R5jR10:3:0R11jR4:5:2i3r18gr5hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@global var shadow:{ var map : Channel; var proj : Mat3x4; var color : Vec3; var power : Float; var bias : Float};
	var pixelColor:Vec4;
	var transformedPosition:Vec3;
	var pixelTransformedPosition:Vec3;
	@private var shadowPos:Vec3;
	function fragment() {
		var shadowPos = pixelTransformedPosition * shadow.proj;
		var depth = shadow.map.get(screenToUv(shadowPos.xy));
		var zMax = shadowPos.z.saturate();
		var delta = (depth + shadow.bias).min(zMax) - zMax;
		var shade = exp(shadow.power * delta).saturate();
		pixelColor.rgb *= (1 - shade) * shadow.color.rgb + shade;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.SignedDistanceField" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/SignedDistanceField.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey30:h3d.shader.SignedDistanceFieldy4:funsaoy3:retjy9:hxsl.Type:3:0y4:kindjy17:hxsl.FunctionKind:3:0y3:refoR0y6:mediany2:idi-104R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsaoR0y1:rR11r3goR0y1:gR11r3goR0y1:bR11r3ghghgy4:exproy1:poy3:mini645y3:maxi697y4:filey84:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FSignedDistanceField.hxgy1:tjR4:0:0y1:ejy13:hxsl.TExprDef:4:1aoR17oR18i651R19i691R20R21gR22r16R23jR24:12:1oR17oR18i658R19i691R20R21gR22r3R23jR24:8:2oR17oR18i658R19i661R20R21gR22jR4:14:1aoR3r3R12aoR0y1:aR11r3goR0R15R11r3ghghR23jR24:2:1jy12:hxsl.TGlobal:22:0gaoR17oR18i662R19i671R20R21gR22r3R23jR24:8:2oR17oR18i662R19i665R20R21gR22jR4:14:1ar25hR23jR24:2:1jR26:21:0gaoR17oR18i666R19i667R20R21gR22r3R23jR24:1:1oR0R13R9i-101R5jR10:4:0R11r3ggoR17oR18i669R19i670R20R21gR22r3R23jR24:1:1oR0R14R9i-102R5r45R11r3gghgoR17oR18i673R19i690R20R21gR22r3R23jR24:8:2oR17oR18i673R19i676R20R21gR22jR4:14:1ar25hR23jR24:2:1r39gaoR17oR18i677R19i686R20R21gR22r3R23jR24:8:2oR17oR18i677R19i680R20R21gR22jR4:14:1ar25hR23jR24:2:1r30gaoR17oR18i681R19i682R20R21gR22r3R23jR24:1:1r44goR17oR18i684R19i685R20R21gR22r3R23jR24:1:1r49ghgoR17oR18i688R19i689R20R21gR22r3R23jR24:1:1oR0R15R9i-103R5r45R11r3gghghgghgR12ar44r49r77hgoR3r16R5jR6:1:0R7oR0y8:fragmentR9i-105R5r6R11jR4:14:1aoR3r16R12ahghgR16oR17oR18i723R19i1173R20R21gR22r16R23jR24:4:1aoR17oR18i729R19i769R20R21gR22r16R23jR24:7:2oR0y13:textureSampleR9i-106R5r45R11jR4:5:2i4jy12:hxsl.VecType:1:0goR17oR18i756R19i768R20R21gR22jR4:5:2i4r97R23jR24:1:1oR0y12:textureColorR9i-83R5r45R11r101gggoR17oR18i774R19i795R20R21gR22r16R23jR24:7:2oR0y8:distanceR9i-107R5r45R11r3gngoR17oR18i802R19i1050R20R21gR22r3R23jR24:5:3jy16:haxe.macro.Binop:4:0oR17oR18i802R19i810R20R21gR22r3R23jR24:1:1r107goR17oR18i813R19i1050R20R21gR22r3R23jR24:10:3oR17oR18i817R19i829R20R21gR22jR4:2:0R23jR24:5:3jR32:5:0oR17oR18i817R19i824R20R21gR22jR4:1:0R23jR24:1:1oR0y7:channely10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-98R5jR10:2:0R11r123ggoR17oR18i828R19i829R20R21gR22r123R23jR24:0:1jy10:hxsl.Const:2:1zggoR17oR18i831R19i846R20R21gR22r3R23jR24:9:2oR17oR18i831R19i844R20R21gR22r98R23jR24:1:1r96gajy14:hxsl.Component:0:0hgoR17oR18i858R19i1050R20R21gR22r3R23jR24:10:3oR17oR18i862R19i874R20R21gR22r119R23jR24:5:3r120oR17oR18i862R19i869R20R21gR22r123R23jR24:1:1r124goR17oR18i873R19i874R20R21gR22r123R23jR24:0:1jR36:2:1i1ggoR17oR18i876R19i891R20R21gR22r3R23jR24:9:2oR17oR18i876R19i889R20R21gR22r98R23jR24:1:1r96gajR37:1:0hgoR17oR18i903R19i1050R20R21gR22r3R23jR24:10:3oR17oR18i907R19i919R20R21gR22r119R23jR24:5:3r120oR17oR18i907R19i914R20R21gR22r123R23jR24:1:1r124goR17oR18i918R19i919R20R21gR22r123R23jR24:0:1jR36:2:1i2ggoR17oR18i921R19i936R20R21gR22r3R23jR24:9:2oR17oR18i921R19i934R20R21gR22r98R23jR24:1:1r96gajR37:2:0hgoR17oR18i948R19i1050R20R21gR22r3R23jR24:10:3oR17oR18i952R19i964R20R21gR22r119R23jR24:5:3r120oR17oR18i952R19i959R20R21gR22r123R23jR24:1:1r124goR17oR18i963R19i964R20R21gR22r123R23jR24:0:1jR36:2:1i3ggoR17oR18i966R19i981R20R21gR22r3R23jR24:9:2oR17oR18i966R19i979R20R21gR22r98R23jR24:1:1r96gajR37:3:0hgoR17oR18i993R19i1050R20R21gR22r3R23jR24:8:2oR17oR18i993R19i999R20R21gR22r13R23jR24:1:1r5gaoR17oR18i1000R19i1015R20R21gR22r3R23jR24:9:2oR17oR18i1000R19i1013R20R21gR22r98R23jR24:1:1r96gar140hgoR17oR18i1017R19i1032R20R21gR22r3R23jR24:9:2oR17oR18i1017R19i1030R20R21gR22r98R23jR24:1:1r96gar160hgoR17oR18i1034R19i1049R20R21gR22r3R23jR24:9:2oR17oR18i1034R19i1047R20R21gR22r98R23jR24:1:1r96gar180hghggggggoR17oR18i1061R19i1167R20R21gR22r101R23jR24:5:3r111oR17oR18i1061R19i1073R20R21gR22r101R23jR24:1:1r102goR17oR18i1076R19i1167R20R21gR22jR4:5:2i4r97R23jR24:8:2oR17oR18i1076R19i1080R20R21gR22jR4:14:1ahR23jR24:2:1jR26:40:0gaoR17oR18i1081R19i1084R20R21gR22r3R23jR24:0:1jR36:3:1d1goR17oR18i1086R19i1089R20R21gR22r3R23jR24:0:1jR36:3:1d1goR17oR18i1091R19i1094R20R21gR22r3R23jR24:0:1jR36:3:1d1goR17oR18i1096R19i1166R20R21gR22r3R23jR24:8:2oR17oR18i1096R19i1106R20R21gR22jR4:14:1aoR3r3R12aoR0y5:edge0R11r3goR0y5:edge1R11r3goR0y1:xR11r3ghghR23jR24:2:1jR26:26:0gaoR17oR18i1107R19i1130R20R21gR22r3R23jR24:5:3jR32:3:0oR17oR18i1107R19i1118R20R21gR22r3R23jR24:1:1oR0y11:alphaCutoffR9i-99R5r127R11r3ggoR17oR18i1121R19i1130R20R21gR22r3R23jR24:1:1oR0y9:smoothingR9i-100R5r127R11r3gggoR17oR18i1132R19i1155R20R21gR22r3R23jR24:5:3jR32:0:0oR17oR18i1132R19i1143R20R21gR22r3R23jR24:1:1r281goR17oR18i1146R19i1155R20R21gR22r3R23jR24:1:1r285ggoR17oR18i1157R19i1165R20R21gR22r3R23jR24:1:1r107ghghgghgR12ahghy4:varsaoR0y5:inputR9i-70R5jR10:1:0R11jR4:13:1aoR0y8:positionR9i-71y6:parentr307R5r308R11jR4:5:2i2r97goR0y2:uvR9i-72R46r307R5r308R11jR4:5:2i2r97goR0y5:colorR9i-73R46r307R5r308R11jR4:5:2i4r97ghgoR0y6:outputR9i-74R5r45R11jR4:13:1aoR0R45R9i-75R46r317R5r45R11jR4:5:2i4r97goR0R48R9i-76R46r317R5r45R11jR4:5:2i4r97ghgoR0y4:timeR9i-77R5jR10:0:0R11r3goR0y14:spritePositionR9i-80R5r45R11jR4:5:2i4r97goR0y16:absolutePositionR9i-81R5r45R11jR4:5:2i4r97goR0y10:pixelColorR9i-82R5r45R11jR4:5:2i4r97gr102oR0y12:calculatedUVR9i-84R5jR10:3:0R11jR4:5:2i2r97goR0y14:outputPositionR9i-97R5r45R11jR4:5:2i4r97gr124r281r285r5r86hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey30:h3d.shader.SignedDistanceFieldy4:funsaoy3:retjy9:hxsl.Type:3:0y4:kindjy17:hxsl.FunctionKind:3:0y3:refoR0y6:mediany2:idi-104R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsaoR0y1:rR11r3goR0y1:gR11r3goR0y1:bR11r3ghghgy4:exproy1:poy3:mini645y3:maxi697y4:filey84:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FSignedDistanceField.hxgy1:tjR4:0:0y1:ejy13:hxsl.TExprDef:4:1aoR17oR18i651R19i691R20R21gR22r16R23jR24:12:1oR17oR18i658R19i691R20R21gR22r3R23jR24:8:2oR17oR18i658R19i661R20R21gR22jR4:14:1aoR3r3R12aoR0y1:aR11r3goR0R15R11r3ghghR23jR24:2:1jy12:hxsl.TGlobal:22:0gaoR17oR18i662R19i671R20R21gR22r3R23jR24:8:2oR17oR18i662R19i665R20R21gR22jR4:14:1ar25hR23jR24:2:1jR26:21:0gaoR17oR18i666R19i667R20R21gR22r3R23jR24:1:1oR0R13R9i-101R5jR10:4:0R11r3ggoR17oR18i669R19i670R20R21gR22r3R23jR24:1:1oR0R14R9i-102R5r45R11r3gghgoR17oR18i673R19i690R20R21gR22r3R23jR24:8:2oR17oR18i673R19i676R20R21gR22jR4:14:1ar25hR23jR24:2:1r39gaoR17oR18i677R19i686R20R21gR22r3R23jR24:8:2oR17oR18i677R19i680R20R21gR22jR4:14:1ar25hR23jR24:2:1r30gaoR17oR18i681R19i682R20R21gR22r3R23jR24:1:1r44goR17oR18i684R19i685R20R21gR22r3R23jR24:1:1r49ghgoR17oR18i688R19i689R20R21gR22r3R23jR24:1:1oR0R15R9i-103R5r45R11r3gghghgghgR12ar44r49r77hgoR3r16R5jR6:1:0R7oR0y8:fragmentR9i-105R5r6R11jR4:14:1aoR3r16R12ahghgR16oR17oR18i723R19i1173R20R21gR22r16R23jR24:4:1aoR17oR18i729R19i769R20R21gR22r16R23jR24:7:2oR0y13:textureSampleR9i-106R5r45R11jR4:5:2i4jy12:hxsl.VecType:1:0goR17oR18i756R19i768R20R21gR22jR4:5:2i4r97R23jR24:1:1oR0y12:textureColorR9i-83R5r45R11r101gggoR17oR18i774R19i795R20R21gR22r16R23jR24:7:2oR0y8:distanceR9i-107R5r45R11r3gngoR17oR18i802R19i1050R20R21gR22r3R23jR24:5:3jy16:haxe.macro.Binop:4:0oR17oR18i802R19i810R20R21gR22r3R23jR24:1:1r107goR17oR18i813R19i1050R20R21gR22r3R23jR24:10:3oR17oR18i817R19i829R20R21gR22jR4:2:0R23jR24:5:3jR32:5:0oR17oR18i817R19i824R20R21gR22jR4:1:0R23jR24:1:1oR0y7:channely10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-98R5jR10:2:0R11r123ggoR17oR18i828R19i829R20R21gR22r123R23jR24:0:1jy10:hxsl.Const:2:1zggoR17oR18i831R19i846R20R21gR22r3R23jR24:9:2oR17oR18i831R19i844R20R21gR22r98R23jR24:1:1r96gajy14:hxsl.Component:0:0hgoR17oR18i858R19i1050R20R21gR22r3R23jR24:10:3oR17oR18i862R19i874R20R21gR22r119R23jR24:5:3r120oR17oR18i862R19i869R20R21gR22r123R23jR24:1:1r124goR17oR18i873R19i874R20R21gR22r123R23jR24:0:1jR36:2:1i1ggoR17oR18i876R19i891R20R21gR22r3R23jR24:9:2oR17oR18i876R19i889R20R21gR22r98R23jR24:1:1r96gajR37:1:0hgoR17oR18i903R19i1050R20R21gR22r3R23jR24:10:3oR17oR18i907R19i919R20R21gR22r119R23jR24:5:3r120oR17oR18i907R19i914R20R21gR22r123R23jR24:1:1r124goR17oR18i918R19i919R20R21gR22r123R23jR24:0:1jR36:2:1i2ggoR17oR18i921R19i936R20R21gR22r3R23jR24:9:2oR17oR18i921R19i934R20R21gR22r98R23jR24:1:1r96gajR37:2:0hgoR17oR18i948R19i1050R20R21gR22r3R23jR24:10:3oR17oR18i952R19i964R20R21gR22r119R23jR24:5:3r120oR17oR18i952R19i959R20R21gR22r123R23jR24:1:1r124goR17oR18i963R19i964R20R21gR22r123R23jR24:0:1jR36:2:1i3ggoR17oR18i966R19i981R20R21gR22r3R23jR24:9:2oR17oR18i966R19i979R20R21gR22r98R23jR24:1:1r96gajR37:3:0hgoR17oR18i993R19i1050R20R21gR22r3R23jR24:8:2oR17oR18i993R19i999R20R21gR22r13R23jR24:1:1r5gaoR17oR18i1000R19i1015R20R21gR22r3R23jR24:9:2oR17oR18i1000R19i1013R20R21gR22r98R23jR24:1:1r96gar140hgoR17oR18i1017R19i1032R20R21gR22r3R23jR24:9:2oR17oR18i1017R19i1030R20R21gR22r98R23jR24:1:1r96gar160hgoR17oR18i1034R19i1049R20R21gR22r3R23jR24:9:2oR17oR18i1034R19i1047R20R21gR22r98R23jR24:1:1r96gar180hghggggggoR17oR18i1061R19i1167R20R21gR22r101R23jR24:5:3r111oR17oR18i1061R19i1073R20R21gR22r101R23jR24:1:1r102goR17oR18i1076R19i1167R20R21gR22jR4:5:2i4r97R23jR24:8:2oR17oR18i1076R19i1080R20R21gR22jR4:14:1ahR23jR24:2:1jR26:40:0gaoR17oR18i1081R19i1084R20R21gR22r3R23jR24:0:1jR36:3:1d1goR17oR18i1086R19i1089R20R21gR22r3R23jR24:0:1jR36:3:1d1goR17oR18i1091R19i1094R20R21gR22r3R23jR24:0:1jR36:3:1d1goR17oR18i1096R19i1166R20R21gR22r3R23jR24:8:2oR17oR18i1096R19i1106R20R21gR22jR4:14:1aoR3r3R12aoR0y5:edge0R11r3goR0y5:edge1R11r3goR0y1:xR11r3ghghR23jR24:2:1jR26:26:0gaoR17oR18i1107R19i1130R20R21gR22r3R23jR24:5:3jR32:3:0oR17oR18i1107R19i1118R20R21gR22r3R23jR24:1:1oR0y11:alphaCutoffR9i-99R5r127R11r3ggoR17oR18i1121R19i1130R20R21gR22r3R23jR24:1:1oR0y9:smoothingR9i-100R5r127R11r3gggoR17oR18i1132R19i1155R20R21gR22r3R23jR24:5:3jR32:0:0oR17oR18i1132R19i1143R20R21gR22r3R23jR24:1:1r281goR17oR18i1146R19i1155R20R21gR22r3R23jR24:1:1r285ggoR17oR18i1157R19i1165R20R21gR22r3R23jR24:1:1r107ghghgghgR12ahghy4:varsaoR0y5:inputR9i-70R5jR10:1:0R11jR4:13:1aoR0y8:positionR9i-71y6:parentr307R5r308R11jR4:5:2i2r97goR0y2:uvR9i-72R46r307R5r308R11jR4:5:2i2r97goR0y5:colorR9i-73R46r307R5r308R11jR4:5:2i4r97ghgoR0y6:outputR9i-74R5r45R11jR4:13:1aoR0R45R9i-75R46r317R5r45R11jR4:5:2i4r97goR0R48R9i-76R46r317R5r45R11jR4:5:2i4r97ghgoR0y4:timeR9i-77R5jR10:0:0R11r3goR0y14:spritePositionR9i-80R5r45R11jR4:5:2i4r97goR0y16:absolutePositionR9i-81R5r45R11jR4:5:2i4r97goR0y10:pixelColorR9i-82R5r45R11jR4:5:2i4r97gr102oR0y12:calculatedUVR9i-84R5jR10:3:0R11jR4:5:2i2r97goR0y14:outputPositionR9i-97R5r45R11jR4:5:2i4r97gr124r281r285r5r86hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<channel public="1" get="accessor" set="accessor"><x path="Int"/></channel>
		<channel__ expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</channel__>
		<get_channel get="inline" set="null" line="5">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_channel>
		<set_channel get="inline" set="null" line="5">
			<f a="_v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_channel>
		<alphaCutoff public="1" get="accessor" set="accessor"><x path="Float"/></alphaCutoff>
		<alphaCutoff__ expr="0.5">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.5</e></m>
				<m n=":noCompletion"/>
			</meta>
		</alphaCutoff__>
		<get_alphaCutoff get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_alphaCutoff>
		<set_alphaCutoff get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_alphaCutoff>
		<smoothing public="1" get="accessor" set="accessor"><x path="Float"/></smoothing>
		<smoothing__ expr="0.041666666666666664">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0.041666666666666664</e></m>
				<m n=":noCompletion"/>
			</meta>
		</smoothing__>
		<get_smoothing get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_smoothing>
		<set_smoothing get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_smoothing>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@:import h3d.shader.Base2d;
	@const var channel:Int = 0;
	@param var alphaCutoff:Float = 0.5;
	@param var smoothing:Float = 0.04166666666666666666666666666667;
	function median(r:Float, g:Float, b:Float):Float {
		return max(min(r, g), min(max(r, g), b));
	};
	function fragment() {
		var textureSample:Vec4 = textureColor;
		var distance:Float;
		distance = if (channel == 0) textureSample.r else if (channel == 1) textureSample.g else if (channel == 2) textureSample.b else if (channel == 3) textureSample.a else median(textureSample.r, textureSample.g, textureSample.b);
		textureColor = vec4(1.0, 1.0, 1.0, smoothstep(alphaCutoff - smoothing, alphaCutoff + smoothing, distance));
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.SkinBase" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/SkinBase.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey19:h3d.shader.SkinBasey4:funsahy4:varsaoR0y16:relativePositiony2:idi-30y4:kindjy12:hxsl.VarKind:4:0y4:typejy9:hxsl.Type:5:2i3jy12:hxsl.VecType:1:0goR0y19:transformedPositionR5i-31R6r4R8jR9:5:2i3r5goR0y17:transformedNormalR5i-32R6r4R8jR9:5:2i3r5goR0y8:MaxBonesy10:qualifiersajy17:hxsl.VarQualifier:0:1nhR5i-33R6jR7:2:0R8jR9:1:0goR0y13:bonesMatrixesR14ajR15:8:0hR5i-34R6r14R8jR9:15:2jR9:8:0jy13:hxsl.SizeDecl:1:1r11ghg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey19:h3d.shader.SkinBasey4:funsahy4:varsaoR0y16:relativePositiony2:idi-30y4:kindjy12:hxsl.VarKind:4:0y4:typejy9:hxsl.Type:5:2i3jy12:hxsl.VecType:1:0goR0y19:transformedPositionR5i-31R6r4R8jR9:5:2i3r5goR0y17:transformedNormalR5i-32R6r4R8jR9:5:2i3r5goR0y8:MaxBonesy10:qualifiersajy17:hxsl.VarQualifier:0:1nhR5i-33R6jR7:2:0R8jR9:1:0goR0y13:bonesMatrixesR14ajR15:8:0hR5i-34R6r14R8jR9:15:2jR9:8:0jy13:hxsl.SizeDecl:1:1r11ghg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<MaxBones public="1" get="accessor" set="accessor"><x path="Int"/></MaxBones>
		<MaxBones__ expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</MaxBones__>
		<get_MaxBones get="inline" set="null" line="5">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_MaxBones>
		<set_MaxBones get="inline" set="null" line="5">
			<f a="_v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_MaxBones>
		<bonesMatrixes public="1" get="accessor" set="accessor"><c path="Array"><t path="hxsl.Matrix"/></c></bonesMatrixes>
		<bonesMatrixes__ expr="new Array()">
			<c path="Array"><t path="hxsl.Matrix"/></c>
			<meta>
				<m n=":value"><e>new Array()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</bonesMatrixes__>
		<get_bonesMatrixes get="inline" set="null" line="5">
			<f a=""><c path="Array"><t path="hxsl.Matrix"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_bonesMatrixes>
		<set_bonesMatrixes get="inline" set="null" line="5">
			<f a="_v">
				<c path="Array"><t path="hxsl.Matrix"/></c>
				<c path="Array"><t path="hxsl.Matrix"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_bonesMatrixes>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":src"><e><![CDATA[{
	var relativePosition:Vec3;
	var transformedPosition:Vec3;
	var transformedNormal:Vec3;
	@const var MaxBones:Int;
	@ignore @param var bonesMatrixes:Array<Mat3x4,MaxBones>;
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.Skin" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Skin.hx">
		<extends path="h3d.shader.SkinBase"/>
		<SRC expr="&quot;oy4:namey15:h3d.shader.Skiny4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:0:0y3:refoR0y6:vertexy2:idi-480R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini265y3:maxi799y4:filey69:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FSkin.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i271R16i521R17R18gR19jR4:5:2i3jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i271R16i290R17R18gR19r17R20jR21:1:1oR0y19:transformedPositionR9i-470R5jR10:4:0R11r17ggoR14oR15i298R16i521R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:0:0oR14oR15i298R16i444R17R18gR19jR4:5:2i3r16R20jR21:5:3r27oR14oR15i298R16i367R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:1:0oR14oR15i298R16i349R17R18gR19r33R20jR21:3:1oR14oR15i299R16i348R17R18gR19r33R20jR21:5:3r34oR14oR15i299R16i315R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y16:relativePositionR9i-469R5r22R11r41ggoR14oR15i318R16i348R17R18gR19jR4:8:0R20jR21:16:2oR14oR15i318R16i331R17R18gR19jR4:15:2r46jy13:hxsl.SizeDecl:1:1oR0y8:MaxBonesy10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-472R5jR10:2:0R11jR4:1:0gR20jR21:1:1oR0y13:bonesMatrixesR28ajR29:8:0hR9i-473R5r52R11r55ggoR14oR15i332R16i347R17R18gR19r53R20jR21:9:2oR14oR15i332R16i345R17R18gR19jR4:9:1i4R20jR21:1:1oR0y7:indexesR9i-478y6:parentoR0y5:inputR9i-474R5jR10:1:0R11jR4:13:1aoR0y8:positionR9i-475R32r66R5r67R11jR4:5:2i3r16goR0y6:normalR9i-476R32r66R5r67R11jR4:5:2i3r16goR0y7:weightsR9i-477R32r66R5r67R11jR4:5:2i3r16gr65hgR5r67R11r64ggajy14:hxsl.Component:0:0hggggoR14oR15i352R16i367R17R18gR19jR4:3:0R20jR21:9:2oR14oR15i352R16i365R17R18gR19r74R20jR21:1:1r73gar78hggoR14oR15i375R16i444R17R18gR19r33R20jR21:5:3r34oR14oR15i375R16i426R17R18gR19r33R20jR21:3:1oR14oR15i376R16i425R17R18gR19r33R20jR21:5:3r34oR14oR15i376R16i392R17R18gR19r41R20jR21:1:1r42goR14oR15i395R16i425R17R18gR19r46R20jR21:16:2oR14oR15i395R16i408R17R18gR19r55R20jR21:1:1r56goR14oR15i409R16i424R17R18gR19r53R20jR21:9:2oR14oR15i409R16i422R17R18gR19r64R20jR21:1:1r65gajR37:1:0hggggoR14oR15i429R16i444R17R18gR19r85R20jR21:9:2oR14oR15i429R16i442R17R18gR19r74R20jR21:1:1r73gar112hgggoR14oR15i452R16i521R17R18gR19r33R20jR21:5:3r34oR14oR15i452R16i503R17R18gR19r33R20jR21:3:1oR14oR15i453R16i502R17R18gR19r33R20jR21:5:3r34oR14oR15i453R16i469R17R18gR19r41R20jR21:1:1r42goR14oR15i472R16i502R17R18gR19r46R20jR21:16:2oR14oR15i472R16i485R17R18gR19r55R20jR21:1:1r56goR14oR15i486R16i501R17R18gR19r53R20jR21:9:2oR14oR15i486R16i499R17R18gR19r64R20jR21:1:1r65gajR37:2:0hggggoR14oR15i506R16i521R17R18gR19r85R20jR21:9:2oR14oR15i506R16i519R17R18gR19r74R20jR21:1:1r73gar146hggggoR14oR15i527R16i793R17R18gR19jR4:5:2i3r16R20jR21:5:3r18oR14oR15i527R16i544R17R18gR19r163R20jR21:1:1oR0y17:transformedNormalR9i-471R5r22R11r163ggoR14oR15i547R16i793R17R18gR19r33R20jR21:8:2oR14oR15i547R16i556R17R18gR19jR4:14:1aoR3r33R12aoR0y5:valueR11r33ghghR20jR21:2:1jy12:hxsl.TGlobal:31:0gaoR14oR15i563R16i792R17R18gR19jR4:5:2i3r16R20jR21:5:3r27oR14oR15i563R16i713R17R18gR19jR4:5:2i3r16R20jR21:5:3r27oR14oR15i563R16i634R17R18gR19r33R20jR21:5:3r34oR14oR15i563R16i616R17R18gR19r33R20jR21:3:1oR14oR15i564R16i615R17R18gR19r33R20jR21:5:3r34oR14oR15i564R16i576R17R18gR19r72R20jR21:1:1r71goR14oR15i579R16i615R17R18gR19jR4:6:0R20jR21:8:2oR14oR15i579R16i583R17R18gR19jR4:14:1ahR20jR21:2:1jR40:48:0gaoR14oR15i584R16i614R17R18gR19r46R20jR21:16:2oR14oR15i584R16i597R17R18gR19r55R20jR21:1:1r56goR14oR15i598R16i613R17R18gR19r53R20jR21:9:2oR14oR15i598R16i611R17R18gR19r64R20jR21:1:1r65gar78hgghgggoR14oR15i619R16i634R17R18gR19r85R20jR21:9:2oR14oR15i619R16i632R17R18gR19r74R20jR21:1:1r73gar78hggoR14oR15i642R16i713R17R18gR19r33R20jR21:5:3r34oR14oR15i642R16i695R17R18gR19r33R20jR21:3:1oR14oR15i643R16i694R17R18gR19r33R20jR21:5:3r34oR14oR15i643R16i655R17R18gR19r72R20jR21:1:1r71goR14oR15i658R16i694R17R18gR19r197R20jR21:8:2oR14oR15i658R16i662R17R18gR19r201R20jR21:2:1r202gaoR14oR15i663R16i693R17R18gR19r46R20jR21:16:2oR14oR15i663R16i676R17R18gR19r55R20jR21:1:1r56goR14oR15i677R16i692R17R18gR19r53R20jR21:9:2oR14oR15i677R16i690R17R18gR19r64R20jR21:1:1r65gar112hgghgggoR14oR15i698R16i713R17R18gR19r85R20jR21:9:2oR14oR15i698R16i711R17R18gR19r74R20jR21:1:1r73gar112hgggoR14oR15i721R16i792R17R18gR19r33R20jR21:5:3r34oR14oR15i721R16i774R17R18gR19r33R20jR21:3:1oR14oR15i722R16i773R17R18gR19r33R20jR21:5:3r34oR14oR15i722R16i734R17R18gR19r72R20jR21:1:1r71goR14oR15i737R16i773R17R18gR19r197R20jR21:8:2oR14oR15i737R16i741R17R18gR19r201R20jR21:2:1r202gaoR14oR15i742R16i772R17R18gR19r46R20jR21:16:2oR14oR15i742R16i755R17R18gR19r55R20jR21:1:1r56goR14oR15i756R16i771R17R18gR19r53R20jR21:9:2oR14oR15i756R16i769R17R18gR19r64R20jR21:1:1r65gar146hgghgggoR14oR15i777R16i792R17R18gR19r85R20jR21:9:2oR14oR15i777R16i790R17R18gR19r74R20jR21:1:1r73gar146hggghgghgR12ahghy4:varsar42r21r166r49r56r66oR0y18:transformedTangentR9i-479R5r22R11jR4:5:2i4r16gr5hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey15:h3d.shader.Skiny4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:0:0y3:refoR0y6:vertexy2:idi-480R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini265y3:maxi799y4:filey69:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FSkin.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i271R16i521R17R18gR19jR4:5:2i3jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i271R16i290R17R18gR19r17R20jR21:1:1oR0y19:transformedPositionR9i-470R5jR10:4:0R11r17ggoR14oR15i298R16i521R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:0:0oR14oR15i298R16i444R17R18gR19jR4:5:2i3r16R20jR21:5:3r27oR14oR15i298R16i367R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:1:0oR14oR15i298R16i349R17R18gR19r33R20jR21:3:1oR14oR15i299R16i348R17R18gR19r33R20jR21:5:3r34oR14oR15i299R16i315R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y16:relativePositionR9i-469R5r22R11r41ggoR14oR15i318R16i348R17R18gR19jR4:8:0R20jR21:16:2oR14oR15i318R16i331R17R18gR19jR4:15:2r46jy13:hxsl.SizeDecl:1:1oR0y8:MaxBonesy10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-472R5jR10:2:0R11jR4:1:0gR20jR21:1:1oR0y13:bonesMatrixesR28ajR29:8:0hR9i-473R5r52R11r55ggoR14oR15i332R16i347R17R18gR19r53R20jR21:9:2oR14oR15i332R16i345R17R18gR19jR4:9:1i4R20jR21:1:1oR0y7:indexesR9i-478y6:parentoR0y5:inputR9i-474R5jR10:1:0R11jR4:13:1aoR0y8:positionR9i-475R32r66R5r67R11jR4:5:2i3r16goR0y6:normalR9i-476R32r66R5r67R11jR4:5:2i3r16goR0y7:weightsR9i-477R32r66R5r67R11jR4:5:2i3r16gr65hgR5r67R11r64ggajy14:hxsl.Component:0:0hggggoR14oR15i352R16i367R17R18gR19jR4:3:0R20jR21:9:2oR14oR15i352R16i365R17R18gR19r74R20jR21:1:1r73gar78hggoR14oR15i375R16i444R17R18gR19r33R20jR21:5:3r34oR14oR15i375R16i426R17R18gR19r33R20jR21:3:1oR14oR15i376R16i425R17R18gR19r33R20jR21:5:3r34oR14oR15i376R16i392R17R18gR19r41R20jR21:1:1r42goR14oR15i395R16i425R17R18gR19r46R20jR21:16:2oR14oR15i395R16i408R17R18gR19r55R20jR21:1:1r56goR14oR15i409R16i424R17R18gR19r53R20jR21:9:2oR14oR15i409R16i422R17R18gR19r64R20jR21:1:1r65gajR37:1:0hggggoR14oR15i429R16i444R17R18gR19r85R20jR21:9:2oR14oR15i429R16i442R17R18gR19r74R20jR21:1:1r73gar112hgggoR14oR15i452R16i521R17R18gR19r33R20jR21:5:3r34oR14oR15i452R16i503R17R18gR19r33R20jR21:3:1oR14oR15i453R16i502R17R18gR19r33R20jR21:5:3r34oR14oR15i453R16i469R17R18gR19r41R20jR21:1:1r42goR14oR15i472R16i502R17R18gR19r46R20jR21:16:2oR14oR15i472R16i485R17R18gR19r55R20jR21:1:1r56goR14oR15i486R16i501R17R18gR19r53R20jR21:9:2oR14oR15i486R16i499R17R18gR19r64R20jR21:1:1r65gajR37:2:0hggggoR14oR15i506R16i521R17R18gR19r85R20jR21:9:2oR14oR15i506R16i519R17R18gR19r74R20jR21:1:1r73gar146hggggoR14oR15i527R16i793R17R18gR19jR4:5:2i3r16R20jR21:5:3r18oR14oR15i527R16i544R17R18gR19r163R20jR21:1:1oR0y17:transformedNormalR9i-471R5r22R11r163ggoR14oR15i547R16i793R17R18gR19r33R20jR21:8:2oR14oR15i547R16i556R17R18gR19jR4:14:1aoR3r33R12aoR0y5:valueR11r33ghghR20jR21:2:1jy12:hxsl.TGlobal:31:0gaoR14oR15i563R16i792R17R18gR19jR4:5:2i3r16R20jR21:5:3r27oR14oR15i563R16i713R17R18gR19jR4:5:2i3r16R20jR21:5:3r27oR14oR15i563R16i634R17R18gR19r33R20jR21:5:3r34oR14oR15i563R16i616R17R18gR19r33R20jR21:3:1oR14oR15i564R16i615R17R18gR19r33R20jR21:5:3r34oR14oR15i564R16i576R17R18gR19r72R20jR21:1:1r71goR14oR15i579R16i615R17R18gR19jR4:6:0R20jR21:8:2oR14oR15i579R16i583R17R18gR19jR4:14:1ahR20jR21:2:1jR40:48:0gaoR14oR15i584R16i614R17R18gR19r46R20jR21:16:2oR14oR15i584R16i597R17R18gR19r55R20jR21:1:1r56goR14oR15i598R16i613R17R18gR19r53R20jR21:9:2oR14oR15i598R16i611R17R18gR19r64R20jR21:1:1r65gar78hgghgggoR14oR15i619R16i634R17R18gR19r85R20jR21:9:2oR14oR15i619R16i632R17R18gR19r74R20jR21:1:1r73gar78hggoR14oR15i642R16i713R17R18gR19r33R20jR21:5:3r34oR14oR15i642R16i695R17R18gR19r33R20jR21:3:1oR14oR15i643R16i694R17R18gR19r33R20jR21:5:3r34oR14oR15i643R16i655R17R18gR19r72R20jR21:1:1r71goR14oR15i658R16i694R17R18gR19r197R20jR21:8:2oR14oR15i658R16i662R17R18gR19r201R20jR21:2:1r202gaoR14oR15i663R16i693R17R18gR19r46R20jR21:16:2oR14oR15i663R16i676R17R18gR19r55R20jR21:1:1r56goR14oR15i677R16i692R17R18gR19r53R20jR21:9:2oR14oR15i677R16i690R17R18gR19r64R20jR21:1:1r65gar112hgghgggoR14oR15i698R16i713R17R18gR19r85R20jR21:9:2oR14oR15i698R16i711R17R18gR19r74R20jR21:1:1r73gar112hgggoR14oR15i721R16i792R17R18gR19r33R20jR21:5:3r34oR14oR15i721R16i774R17R18gR19r33R20jR21:3:1oR14oR15i722R16i773R17R18gR19r33R20jR21:5:3r34oR14oR15i722R16i734R17R18gR19r72R20jR21:1:1r71goR14oR15i737R16i773R17R18gR19r197R20jR21:8:2oR14oR15i737R16i741R17R18gR19r201R20jR21:2:1r202gaoR14oR15i742R16i772R17R18gR19r46R20jR21:16:2oR14oR15i742R16i755R17R18gR19r55R20jR21:1:1r56goR14oR15i756R16i771R17R18gR19r53R20jR21:9:2oR14oR15i756R16i769R17R18gR19r64R20jR21:1:1r65gar146hgghgggoR14oR15i777R16i792R17R18gR19r85R20jR21:9:2oR14oR15i777R16i790R17R18gR19r74R20jR21:1:1r73gar146hggghgghgR12ahghy4:varsar42r21r166r49r56r66oR0y18:transformedTangentR9i-479R5r22R11jR4:5:2i4r16gr5hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@input var input:{ var position : Vec3; var normal : Vec3; var weights : Vec3; var indexes : Bytes4};
	var transformedTangent:Vec4;
	function vertex() {
		transformedPosition = (relativePosition * bonesMatrixes[input.indexes.x]) * input.weights.x + (relativePosition * bonesMatrixes[input.indexes.y]) * input.weights.y + (relativePosition * bonesMatrixes[input.indexes.z]) * input.weights.z;
		transformedNormal = normalize((input.normal * mat3(bonesMatrixes[input.indexes.x])) * input.weights.x + (input.normal * mat3(bonesMatrixes[input.indexes.y])) * input.weights.y + (input.normal * mat3(bonesMatrixes[input.indexes.z])) * input.weights.z);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.SkinTangent" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/SkinTangent.hx">
		<extends path="h3d.shader.SkinBase"/>
		<SRC expr="&quot;oy4:namey22:h3d.shader.SkinTangenty4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:0:0y3:refoR0y6:vertexy2:idi-468R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini296y3:maxi1151y4:filey76:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FSkinTangent.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i302R16i552R17R18gR19jR4:5:2i3jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i302R16i321R17R18gR19r17R20jR21:1:1oR0y19:transformedPositionR9i-457R5jR10:4:0R11r17ggoR14oR15i329R16i552R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:0:0oR14oR15i329R16i475R17R18gR19jR4:5:2i3r16R20jR21:5:3r27oR14oR15i329R16i398R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:1:0oR14oR15i329R16i380R17R18gR19r33R20jR21:3:1oR14oR15i330R16i379R17R18gR19r33R20jR21:5:3r34oR14oR15i330R16i346R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y16:relativePositionR9i-456R5r22R11r41ggoR14oR15i349R16i379R17R18gR19jR4:8:0R20jR21:16:2oR14oR15i349R16i362R17R18gR19jR4:15:2r46jy13:hxsl.SizeDecl:1:1oR0y8:MaxBonesy10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-459R5jR10:2:0R11jR4:1:0gR20jR21:1:1oR0y13:bonesMatrixesR28ajR29:8:0hR9i-460R5r52R11r55ggoR14oR15i363R16i378R17R18gR19r53R20jR21:9:2oR14oR15i363R16i376R17R18gR19jR4:9:1i4R20jR21:1:1oR0y7:indexesR9i-466y6:parentoR0y5:inputR9i-461R5jR10:1:0R11jR4:13:1aoR0y8:positionR9i-462R32r66R5r67R11jR4:5:2i3r16goR0y6:normalR9i-463R32r66R5r67R11jR4:5:2i3r16goR0y7:tangentR9i-464R32r66R5r67R11jR4:5:2i3r16goR0y7:weightsR9i-465R32r66R5r67R11jR4:5:2i3r16gr65hgR5r67R11r64ggajy14:hxsl.Component:0:0hggggoR14oR15i383R16i398R17R18gR19jR4:3:0R20jR21:9:2oR14oR15i383R16i396R17R18gR19r76R20jR21:1:1r75gar80hggoR14oR15i406R16i475R17R18gR19r33R20jR21:5:3r34oR14oR15i406R16i457R17R18gR19r33R20jR21:3:1oR14oR15i407R16i456R17R18gR19r33R20jR21:5:3r34oR14oR15i407R16i423R17R18gR19r41R20jR21:1:1r42goR14oR15i426R16i456R17R18gR19r46R20jR21:16:2oR14oR15i426R16i439R17R18gR19r55R20jR21:1:1r56goR14oR15i440R16i455R17R18gR19r53R20jR21:9:2oR14oR15i440R16i453R17R18gR19r64R20jR21:1:1r65gajR38:1:0hggggoR14oR15i460R16i475R17R18gR19r87R20jR21:9:2oR14oR15i460R16i473R17R18gR19r76R20jR21:1:1r75gar114hgggoR14oR15i483R16i552R17R18gR19r33R20jR21:5:3r34oR14oR15i483R16i534R17R18gR19r33R20jR21:3:1oR14oR15i484R16i533R17R18gR19r33R20jR21:5:3r34oR14oR15i484R16i500R17R18gR19r41R20jR21:1:1r42goR14oR15i503R16i533R17R18gR19r46R20jR21:16:2oR14oR15i503R16i516R17R18gR19r55R20jR21:1:1r56goR14oR15i517R16i532R17R18gR19r53R20jR21:9:2oR14oR15i517R16i530R17R18gR19r64R20jR21:1:1r65gajR38:2:0hggggoR14oR15i537R16i552R17R18gR19r87R20jR21:9:2oR14oR15i537R16i550R17R18gR19r76R20jR21:1:1r75gar148hggggoR14oR15i558R16i824R17R18gR19jR4:5:2i3r16R20jR21:5:3r18oR14oR15i558R16i575R17R18gR19r165R20jR21:1:1oR0y17:transformedNormalR9i-458R5r22R11r165ggoR14oR15i578R16i824R17R18gR19r33R20jR21:8:2oR14oR15i578R16i587R17R18gR19jR4:14:1aoR3r33R12aoR0y5:valueR11r33ghghR20jR21:2:1jy12:hxsl.TGlobal:31:0gaoR14oR15i594R16i823R17R18gR19jR4:5:2i3r16R20jR21:5:3r27oR14oR15i594R16i744R17R18gR19jR4:5:2i3r16R20jR21:5:3r27oR14oR15i594R16i665R17R18gR19r33R20jR21:5:3r34oR14oR15i594R16i647R17R18gR19r33R20jR21:3:1oR14oR15i595R16i646R17R18gR19r33R20jR21:5:3r34oR14oR15i595R16i607R17R18gR19r72R20jR21:1:1r71goR14oR15i610R16i646R17R18gR19jR4:6:0R20jR21:8:2oR14oR15i610R16i614R17R18gR19jR4:14:1ahR20jR21:2:1jR41:48:0gaoR14oR15i615R16i645R17R18gR19r46R20jR21:16:2oR14oR15i615R16i628R17R18gR19r55R20jR21:1:1r56goR14oR15i629R16i644R17R18gR19r53R20jR21:9:2oR14oR15i629R16i642R17R18gR19r64R20jR21:1:1r65gar80hgghgggoR14oR15i650R16i665R17R18gR19r87R20jR21:9:2oR14oR15i650R16i663R17R18gR19r76R20jR21:1:1r75gar80hggoR14oR15i673R16i744R17R18gR19r33R20jR21:5:3r34oR14oR15i673R16i726R17R18gR19r33R20jR21:3:1oR14oR15i674R16i725R17R18gR19r33R20jR21:5:3r34oR14oR15i674R16i686R17R18gR19r72R20jR21:1:1r71goR14oR15i689R16i725R17R18gR19r199R20jR21:8:2oR14oR15i689R16i693R17R18gR19r203R20jR21:2:1r204gaoR14oR15i694R16i724R17R18gR19r46R20jR21:16:2oR14oR15i694R16i707R17R18gR19r55R20jR21:1:1r56goR14oR15i708R16i723R17R18gR19r53R20jR21:9:2oR14oR15i708R16i721R17R18gR19r64R20jR21:1:1r65gar114hgghgggoR14oR15i729R16i744R17R18gR19r87R20jR21:9:2oR14oR15i729R16i742R17R18gR19r76R20jR21:1:1r75gar114hgggoR14oR15i752R16i823R17R18gR19r33R20jR21:5:3r34oR14oR15i752R16i805R17R18gR19r33R20jR21:3:1oR14oR15i753R16i804R17R18gR19r33R20jR21:5:3r34oR14oR15i753R16i765R17R18gR19r72R20jR21:1:1r71goR14oR15i768R16i804R17R18gR19r199R20jR21:8:2oR14oR15i768R16i772R17R18gR19r203R20jR21:2:1r204gaoR14oR15i773R16i803R17R18gR19r46R20jR21:16:2oR14oR15i773R16i786R17R18gR19r55R20jR21:1:1r56goR14oR15i787R16i802R17R18gR19r53R20jR21:9:2oR14oR15i787R16i800R17R18gR19r64R20jR21:1:1r65gar148hgghgggoR14oR15i808R16i823R17R18gR19r87R20jR21:9:2oR14oR15i808R16i821R17R18gR19r76R20jR21:1:1r75gar148hggghggoR14oR15i830R16i1145R17R18gR19jR4:5:2i4r16R20jR21:5:3r18oR14oR15i830R16i848R17R18gR19r315R20jR21:1:1oR0y18:transformedTangentR9i-467R5r22R11r315ggoR14oR15i851R16i1145R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i851R16i855R17R18gR19jR4:14:1ahR20jR21:2:1jR41:40:0gaoR14oR15i856R16i1122R17R18gR19r33R20jR21:8:2oR14oR15i856R16i865R17R18gR19jR4:14:1ar175hR20jR21:2:1r179gaoR14oR15i872R16i1116R17R18gR19jR4:5:2i3r16R20jR21:5:3r27oR14oR15i872R16i1032R17R18gR19jR4:5:2i3r16R20jR21:5:3r27oR14oR15i872R16i948R17R18gR19r33R20jR21:5:3r34oR14oR15i872R16i930R17R18gR19r33R20jR21:3:1oR14oR15i873R16i929R17R18gR19r33R20jR21:5:3r34oR14oR15i873R16i890R17R18gR19jR4:5:2i3r16R20jR21:9:2oR14oR15i873R16i886R17R18gR19r74R20jR21:1:1r73gar80r114r148hgoR14oR15i893R16i929R17R18gR19r199R20jR21:8:2oR14oR15i893R16i897R17R18gR19r203R20jR21:2:1r204gaoR14oR15i898R16i928R17R18gR19r46R20jR21:16:2oR14oR15i898R16i911R17R18gR19r55R20jR21:1:1r56goR14oR15i912R16i927R17R18gR19r53R20jR21:9:2oR14oR15i912R16i925R17R18gR19r64R20jR21:1:1r65gar80hgghgggoR14oR15i933R16i948R17R18gR19r87R20jR21:9:2oR14oR15i933R16i946R17R18gR19r76R20jR21:1:1r75gar80hggoR14oR15i956R16i1032R17R18gR19r33R20jR21:5:3r34oR14oR15i956R16i1014R17R18gR19r33R20jR21:3:1oR14oR15i957R16i1013R17R18gR19r33R20jR21:5:3r34oR14oR15i957R16i974R17R18gR19jR4:5:2i3r16R20jR21:9:2oR14oR15i957R16i970R17R18gR19r74R20jR21:1:1r73gar80r114r148hgoR14oR15i977R16i1013R17R18gR19r199R20jR21:8:2oR14oR15i977R16i981R17R18gR19r203R20jR21:2:1r204gaoR14oR15i982R16i1012R17R18gR19r46R20jR21:16:2oR14oR15i982R16i995R17R18gR19r55R20jR21:1:1r56goR14oR15i996R16i1011R17R18gR19r53R20jR21:9:2oR14oR15i996R16i1009R17R18gR19r64R20jR21:1:1r65gar114hgghgggoR14oR15i1017R16i1032R17R18gR19r87R20jR21:9:2oR14oR15i1017R16i1030R17R18gR19r76R20jR21:1:1r75gar114hgggoR14oR15i1040R16i1116R17R18gR19r33R20jR21:5:3r34oR14oR15i1040R16i1098R17R18gR19r33R20jR21:3:1oR14oR15i1041R16i1097R17R18gR19r33R20jR21:5:3r34oR14oR15i1041R16i1058R17R18gR19jR4:5:2i3r16R20jR21:9:2oR14oR15i1041R16i1054R17R18gR19r74R20jR21:1:1r73gar80r114r148hgoR14oR15i1061R16i1097R17R18gR19r199R20jR21:8:2oR14oR15i1061R16i1065R17R18gR19r203R20jR21:2:1r204gaoR14oR15i1066R16i1096R17R18gR19r46R20jR21:16:2oR14oR15i1066R16i1079R17R18gR19r55R20jR21:1:1r56goR14oR15i1080R16i1095R17R18gR19r53R20jR21:9:2oR14oR15i1080R16i1093R17R18gR19r64R20jR21:1:1r65gar148hgghgggoR14oR15i1101R16i1116R17R18gR19r87R20jR21:9:2oR14oR15i1101R16i1114R17R18gR19r76R20jR21:1:1r75gar148hggghgoR14oR15i1124R16i1144R17R18gR19r87R20jR21:9:2oR14oR15i1124R16i1142R17R18gR19r315R20jR21:1:1r318gajR38:3:0hghgghgR12ahghy4:varsar42r21r168r49r56r66r318r5hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey22:h3d.shader.SkinTangenty4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:0:0y3:refoR0y6:vertexy2:idi-468R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini296y3:maxi1151y4:filey76:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FSkinTangent.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i302R16i552R17R18gR19jR4:5:2i3jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i302R16i321R17R18gR19r17R20jR21:1:1oR0y19:transformedPositionR9i-457R5jR10:4:0R11r17ggoR14oR15i329R16i552R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:0:0oR14oR15i329R16i475R17R18gR19jR4:5:2i3r16R20jR21:5:3r27oR14oR15i329R16i398R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:1:0oR14oR15i329R16i380R17R18gR19r33R20jR21:3:1oR14oR15i330R16i379R17R18gR19r33R20jR21:5:3r34oR14oR15i330R16i346R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y16:relativePositionR9i-456R5r22R11r41ggoR14oR15i349R16i379R17R18gR19jR4:8:0R20jR21:16:2oR14oR15i349R16i362R17R18gR19jR4:15:2r46jy13:hxsl.SizeDecl:1:1oR0y8:MaxBonesy10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-459R5jR10:2:0R11jR4:1:0gR20jR21:1:1oR0y13:bonesMatrixesR28ajR29:8:0hR9i-460R5r52R11r55ggoR14oR15i363R16i378R17R18gR19r53R20jR21:9:2oR14oR15i363R16i376R17R18gR19jR4:9:1i4R20jR21:1:1oR0y7:indexesR9i-466y6:parentoR0y5:inputR9i-461R5jR10:1:0R11jR4:13:1aoR0y8:positionR9i-462R32r66R5r67R11jR4:5:2i3r16goR0y6:normalR9i-463R32r66R5r67R11jR4:5:2i3r16goR0y7:tangentR9i-464R32r66R5r67R11jR4:5:2i3r16goR0y7:weightsR9i-465R32r66R5r67R11jR4:5:2i3r16gr65hgR5r67R11r64ggajy14:hxsl.Component:0:0hggggoR14oR15i383R16i398R17R18gR19jR4:3:0R20jR21:9:2oR14oR15i383R16i396R17R18gR19r76R20jR21:1:1r75gar80hggoR14oR15i406R16i475R17R18gR19r33R20jR21:5:3r34oR14oR15i406R16i457R17R18gR19r33R20jR21:3:1oR14oR15i407R16i456R17R18gR19r33R20jR21:5:3r34oR14oR15i407R16i423R17R18gR19r41R20jR21:1:1r42goR14oR15i426R16i456R17R18gR19r46R20jR21:16:2oR14oR15i426R16i439R17R18gR19r55R20jR21:1:1r56goR14oR15i440R16i455R17R18gR19r53R20jR21:9:2oR14oR15i440R16i453R17R18gR19r64R20jR21:1:1r65gajR38:1:0hggggoR14oR15i460R16i475R17R18gR19r87R20jR21:9:2oR14oR15i460R16i473R17R18gR19r76R20jR21:1:1r75gar114hgggoR14oR15i483R16i552R17R18gR19r33R20jR21:5:3r34oR14oR15i483R16i534R17R18gR19r33R20jR21:3:1oR14oR15i484R16i533R17R18gR19r33R20jR21:5:3r34oR14oR15i484R16i500R17R18gR19r41R20jR21:1:1r42goR14oR15i503R16i533R17R18gR19r46R20jR21:16:2oR14oR15i503R16i516R17R18gR19r55R20jR21:1:1r56goR14oR15i517R16i532R17R18gR19r53R20jR21:9:2oR14oR15i517R16i530R17R18gR19r64R20jR21:1:1r65gajR38:2:0hggggoR14oR15i537R16i552R17R18gR19r87R20jR21:9:2oR14oR15i537R16i550R17R18gR19r76R20jR21:1:1r75gar148hggggoR14oR15i558R16i824R17R18gR19jR4:5:2i3r16R20jR21:5:3r18oR14oR15i558R16i575R17R18gR19r165R20jR21:1:1oR0y17:transformedNormalR9i-458R5r22R11r165ggoR14oR15i578R16i824R17R18gR19r33R20jR21:8:2oR14oR15i578R16i587R17R18gR19jR4:14:1aoR3r33R12aoR0y5:valueR11r33ghghR20jR21:2:1jy12:hxsl.TGlobal:31:0gaoR14oR15i594R16i823R17R18gR19jR4:5:2i3r16R20jR21:5:3r27oR14oR15i594R16i744R17R18gR19jR4:5:2i3r16R20jR21:5:3r27oR14oR15i594R16i665R17R18gR19r33R20jR21:5:3r34oR14oR15i594R16i647R17R18gR19r33R20jR21:3:1oR14oR15i595R16i646R17R18gR19r33R20jR21:5:3r34oR14oR15i595R16i607R17R18gR19r72R20jR21:1:1r71goR14oR15i610R16i646R17R18gR19jR4:6:0R20jR21:8:2oR14oR15i610R16i614R17R18gR19jR4:14:1ahR20jR21:2:1jR41:48:0gaoR14oR15i615R16i645R17R18gR19r46R20jR21:16:2oR14oR15i615R16i628R17R18gR19r55R20jR21:1:1r56goR14oR15i629R16i644R17R18gR19r53R20jR21:9:2oR14oR15i629R16i642R17R18gR19r64R20jR21:1:1r65gar80hgghgggoR14oR15i650R16i665R17R18gR19r87R20jR21:9:2oR14oR15i650R16i663R17R18gR19r76R20jR21:1:1r75gar80hggoR14oR15i673R16i744R17R18gR19r33R20jR21:5:3r34oR14oR15i673R16i726R17R18gR19r33R20jR21:3:1oR14oR15i674R16i725R17R18gR19r33R20jR21:5:3r34oR14oR15i674R16i686R17R18gR19r72R20jR21:1:1r71goR14oR15i689R16i725R17R18gR19r199R20jR21:8:2oR14oR15i689R16i693R17R18gR19r203R20jR21:2:1r204gaoR14oR15i694R16i724R17R18gR19r46R20jR21:16:2oR14oR15i694R16i707R17R18gR19r55R20jR21:1:1r56goR14oR15i708R16i723R17R18gR19r53R20jR21:9:2oR14oR15i708R16i721R17R18gR19r64R20jR21:1:1r65gar114hgghgggoR14oR15i729R16i744R17R18gR19r87R20jR21:9:2oR14oR15i729R16i742R17R18gR19r76R20jR21:1:1r75gar114hgggoR14oR15i752R16i823R17R18gR19r33R20jR21:5:3r34oR14oR15i752R16i805R17R18gR19r33R20jR21:3:1oR14oR15i753R16i804R17R18gR19r33R20jR21:5:3r34oR14oR15i753R16i765R17R18gR19r72R20jR21:1:1r71goR14oR15i768R16i804R17R18gR19r199R20jR21:8:2oR14oR15i768R16i772R17R18gR19r203R20jR21:2:1r204gaoR14oR15i773R16i803R17R18gR19r46R20jR21:16:2oR14oR15i773R16i786R17R18gR19r55R20jR21:1:1r56goR14oR15i787R16i802R17R18gR19r53R20jR21:9:2oR14oR15i787R16i800R17R18gR19r64R20jR21:1:1r65gar148hgghgggoR14oR15i808R16i823R17R18gR19r87R20jR21:9:2oR14oR15i808R16i821R17R18gR19r76R20jR21:1:1r75gar148hggghggoR14oR15i830R16i1145R17R18gR19jR4:5:2i4r16R20jR21:5:3r18oR14oR15i830R16i848R17R18gR19r315R20jR21:1:1oR0y18:transformedTangentR9i-467R5r22R11r315ggoR14oR15i851R16i1145R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i851R16i855R17R18gR19jR4:14:1ahR20jR21:2:1jR41:40:0gaoR14oR15i856R16i1122R17R18gR19r33R20jR21:8:2oR14oR15i856R16i865R17R18gR19jR4:14:1ar175hR20jR21:2:1r179gaoR14oR15i872R16i1116R17R18gR19jR4:5:2i3r16R20jR21:5:3r27oR14oR15i872R16i1032R17R18gR19jR4:5:2i3r16R20jR21:5:3r27oR14oR15i872R16i948R17R18gR19r33R20jR21:5:3r34oR14oR15i872R16i930R17R18gR19r33R20jR21:3:1oR14oR15i873R16i929R17R18gR19r33R20jR21:5:3r34oR14oR15i873R16i890R17R18gR19jR4:5:2i3r16R20jR21:9:2oR14oR15i873R16i886R17R18gR19r74R20jR21:1:1r73gar80r114r148hgoR14oR15i893R16i929R17R18gR19r199R20jR21:8:2oR14oR15i893R16i897R17R18gR19r203R20jR21:2:1r204gaoR14oR15i898R16i928R17R18gR19r46R20jR21:16:2oR14oR15i898R16i911R17R18gR19r55R20jR21:1:1r56goR14oR15i912R16i927R17R18gR19r53R20jR21:9:2oR14oR15i912R16i925R17R18gR19r64R20jR21:1:1r65gar80hgghgggoR14oR15i933R16i948R17R18gR19r87R20jR21:9:2oR14oR15i933R16i946R17R18gR19r76R20jR21:1:1r75gar80hggoR14oR15i956R16i1032R17R18gR19r33R20jR21:5:3r34oR14oR15i956R16i1014R17R18gR19r33R20jR21:3:1oR14oR15i957R16i1013R17R18gR19r33R20jR21:5:3r34oR14oR15i957R16i974R17R18gR19jR4:5:2i3r16R20jR21:9:2oR14oR15i957R16i970R17R18gR19r74R20jR21:1:1r73gar80r114r148hgoR14oR15i977R16i1013R17R18gR19r199R20jR21:8:2oR14oR15i977R16i981R17R18gR19r203R20jR21:2:1r204gaoR14oR15i982R16i1012R17R18gR19r46R20jR21:16:2oR14oR15i982R16i995R17R18gR19r55R20jR21:1:1r56goR14oR15i996R16i1011R17R18gR19r53R20jR21:9:2oR14oR15i996R16i1009R17R18gR19r64R20jR21:1:1r65gar114hgghgggoR14oR15i1017R16i1032R17R18gR19r87R20jR21:9:2oR14oR15i1017R16i1030R17R18gR19r76R20jR21:1:1r75gar114hgggoR14oR15i1040R16i1116R17R18gR19r33R20jR21:5:3r34oR14oR15i1040R16i1098R17R18gR19r33R20jR21:3:1oR14oR15i1041R16i1097R17R18gR19r33R20jR21:5:3r34oR14oR15i1041R16i1058R17R18gR19jR4:5:2i3r16R20jR21:9:2oR14oR15i1041R16i1054R17R18gR19r74R20jR21:1:1r73gar80r114r148hgoR14oR15i1061R16i1097R17R18gR19r199R20jR21:8:2oR14oR15i1061R16i1065R17R18gR19r203R20jR21:2:1r204gaoR14oR15i1066R16i1096R17R18gR19r46R20jR21:16:2oR14oR15i1066R16i1079R17R18gR19r55R20jR21:1:1r56goR14oR15i1080R16i1095R17R18gR19r53R20jR21:9:2oR14oR15i1080R16i1093R17R18gR19r64R20jR21:1:1r65gar148hgghgggoR14oR15i1101R16i1116R17R18gR19r87R20jR21:9:2oR14oR15i1101R16i1114R17R18gR19r76R20jR21:1:1r75gar148hggghgoR14oR15i1124R16i1144R17R18gR19r87R20jR21:9:2oR14oR15i1124R16i1142R17R18gR19r315R20jR21:1:1r318gajR38:3:0hghgghgR12ahghy4:varsar42r21r168r49r56r66r318r5hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@input var input:{ var position : Vec3; var normal : Vec3; var tangent : Vec3; var weights : Vec3; var indexes : Bytes4};
	var transformedTangent:Vec4;
	function vertex() {
		transformedPosition = (relativePosition * bonesMatrixes[input.indexes.x]) * input.weights.x + (relativePosition * bonesMatrixes[input.indexes.y]) * input.weights.y + (relativePosition * bonesMatrixes[input.indexes.z]) * input.weights.z;
		transformedNormal = normalize((input.normal * mat3(bonesMatrixes[input.indexes.x])) * input.weights.x + (input.normal * mat3(bonesMatrixes[input.indexes.y])) * input.weights.y + (input.normal * mat3(bonesMatrixes[input.indexes.z])) * input.weights.z);
		transformedTangent = vec4(normalize((input.tangent.xyz * mat3(bonesMatrixes[input.indexes.x])) * input.weights.x + (input.tangent.xyz * mat3(bonesMatrixes[input.indexes.y])) * input.weights.y + (input.tangent.xyz * mat3(bonesMatrixes[input.indexes.z])) * input.weights.z), transformedTangent.w);
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.SpecularTexture" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/SpecularTexture.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey26:h3d.shader.SpecularTexturey4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:1:0y3:refoR0y8:fragmenty2:idi-142R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini203y3:maxi257y4:filey80:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FSpecularTexture.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i209R16i251R17R18gR19jR4:5:2i3jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:20:1jR23:1:0oR14oR15i209R16i218R17R18gR19r17R20jR21:1:1oR0y9:specColorR9i-141R5jR10:4:0R11r17ggoR14oR15i222R16i251R17R18gR19jR4:5:2i3r16R20jR21:9:2oR14oR15i222R16i247R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i222R16i229R17R18gR19jR4:14:1aoR3r30R12aoR0y1:_R11jR4:10:0goR0y2:uvR11jR4:5:2i2r16ghghR20jR21:2:1jy12:hxsl.TGlobal:33:0gaoR14oR15i222R16i229R17R18gR19r37R20jR21:1:1oR0y7:textureR9i-139R5jR10:2:0R11r37ggoR14oR15i234R16i246R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y12:calculatedUVR9i-140R5r23R11r51gghgajy14:hxsl.Component:0:0jR30:1:0jR30:2:0hgghgR12ahghy4:varsar46r52r22r5hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey26:h3d.shader.SpecularTexturey4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:1:0y3:refoR0y8:fragmenty2:idi-142R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini203y3:maxi257y4:filey80:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FSpecularTexture.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i209R16i251R17R18gR19jR4:5:2i3jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:20:1jR23:1:0oR14oR15i209R16i218R17R18gR19r17R20jR21:1:1oR0y9:specColorR9i-141R5jR10:4:0R11r17ggoR14oR15i222R16i251R17R18gR19jR4:5:2i3r16R20jR21:9:2oR14oR15i222R16i247R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i222R16i229R17R18gR19jR4:14:1aoR3r30R12aoR0y1:_R11jR4:10:0goR0y2:uvR11jR4:5:2i2r16ghghR20jR21:2:1jy12:hxsl.TGlobal:33:0gaoR14oR15i222R16i229R17R18gR19r37R20jR21:1:1oR0y7:textureR9i-139R5jR10:2:0R11r37ggoR14oR15i234R16i246R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y12:calculatedUVR9i-140R5r23R11r51gghgajy14:hxsl.Component:0:0jR30:1:0jR30:2:0hgghgR12ahghy4:varsar46r52r22r5hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture>
		<texture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="15"><f a="?tex">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var texture:Sampler2D;
	var calculatedUV:Vec2;
	var specColor:Vec3;
	function fragment() {
		specColor *= texture.get(calculatedUV).rgb;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.Texture" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/Texture.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey18:h3d.shader.Texturey4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:0:0y3:refoR0y6:vertexy2:idi-153R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini425y3:maxi460y4:filey72:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FTexture.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i431R16i454R17R18gR19jR4:5:2i2jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i431R16i443R17R18gR19r17R20jR21:1:1oR0y12:calculatedUVR9i-150R5jR10:4:0R11r17ggoR14oR15i446R16i454R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y2:uvR9i-144y6:parentoR0y5:inputR9i-143R5jR10:1:0R11jR4:13:1ar27hgR5r29R11r26ggghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-154R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i486R16i713R17R18gR19r3R20jR21:4:1aoR14oR15i492R16i526R17R18gR19r3R20jR21:7:2oR0y1:cR9i-155R5r22R11jR4:5:2i4r16goR14oR15i500R16i525R17R18gR19r49R20jR21:8:2oR14oR15i500R16i507R17R18gR19jR4:14:1aoR3r49R12aoR0y1:_R11jR4:10:0goR0R25R11jR4:5:2i2r16ghghR20jR21:2:1jy12:hxsl.TGlobal:33:0gaoR14oR15i500R16i507R17R18gR19r58R20jR21:1:1oR0y7:textureR9i-149R5jR10:2:0R11r58ggoR14oR15i512R16i524R17R18gR19r17R20jR21:1:1r21ghggoR14oR15i531R16i586R17R18gR19r3R20jR21:10:3oR14oR15i535R16i576R17R18gR19jR4:2:0R20jR21:5:3jR23:14:0oR14oR15i535R16i544R17R18gR19r79R20jR21:1:1oR0y9:killAlphay10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-146R5r68R11r79ggoR14oR15i548R16i576R17R18gR19r79R20jR21:5:3jR23:9:0oR14oR15i548R16i572R17R18gR19jR4:3:0R20jR21:5:3jR23:3:0oR14oR15i548R16i551R17R18gR19r92R20jR21:9:2oR14oR15i548R16i549R17R18gR19r49R20jR21:1:1r48gajy14:hxsl.Component:3:0hgoR14oR15i554R16i572R17R18gR19r92R20jR21:1:1oR0y18:killAlphaThresholdR34ajR35:7:2d0d1hR9i-148R5r68R11r92gggoR14oR15i575R16i576R17R18gR19r92R20jR21:0:1jy10:hxsl.Const:3:1zgggoR14oR15i579R16i586R17R18gR19r3R20jR21:11:0gngoR14oR15i592R16i658R17R18gR19r3R20jR21:10:3oR14oR15i596R16i604R17R18gR19r79R20jR21:1:1oR0y8:additiveR34ajR35:0:1nhR9i-145R5r68R11r79ggoR14oR15i612R16i627R17R18gR19jR4:5:2i4r16R20jR21:5:3jR23:20:1jR23:0:0oR14oR15i612R16i622R17R18gR19r129R20jR21:1:1oR0y10:pixelColorR9i-151R5r22R11r129ggoR14oR15i626R16i627R17R18gR19r49R20jR21:1:1r48ggoR14oR15i643R16i658R17R18gR19r129R20jR21:5:3jR23:20:1jR23:1:0oR14oR15i643R16i653R17R18gR19r129R20jR21:1:1r134goR14oR15i657R16i658R17R18gR19r49R20jR21:1:1r48gggoR14oR15i664R16i707R17R18gR19r3R20jR21:10:3oR14oR15i668R16i681R17R18gR19r79R20jR21:1:1oR0y13:specularAlphaR34ajR35:0:1nhR9i-147R5r68R11r79ggoR14oR15i689R16i707R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:20:1r142oR14oR15i689R16i698R17R18gR19r162R20jR21:1:1oR0y9:specColorR9i-152R5r22R11r162ggoR14oR15i702R16i707R17R18gR19jR4:5:2i3r16R20jR21:9:2oR14oR15i702R16i703R17R18gR19r49R20jR21:1:1r48gar100r100r100hggnghgR12ahghy4:varsar28r123r83r156r104r67r21r134r166r5r38hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey18:h3d.shader.Texturey4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:0:0y3:refoR0y6:vertexy2:idi-153R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini425y3:maxi460y4:filey72:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FTexture.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i431R16i454R17R18gR19jR4:5:2i2jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i431R16i443R17R18gR19r17R20jR21:1:1oR0y12:calculatedUVR9i-150R5jR10:4:0R11r17ggoR14oR15i446R16i454R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y2:uvR9i-144y6:parentoR0y5:inputR9i-143R5jR10:1:0R11jR4:13:1ar27hgR5r29R11r26ggghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-154R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i486R16i713R17R18gR19r3R20jR21:4:1aoR14oR15i492R16i526R17R18gR19r3R20jR21:7:2oR0y1:cR9i-155R5r22R11jR4:5:2i4r16goR14oR15i500R16i525R17R18gR19r49R20jR21:8:2oR14oR15i500R16i507R17R18gR19jR4:14:1aoR3r49R12aoR0y1:_R11jR4:10:0goR0R25R11jR4:5:2i2r16ghghR20jR21:2:1jy12:hxsl.TGlobal:33:0gaoR14oR15i500R16i507R17R18gR19r58R20jR21:1:1oR0y7:textureR9i-149R5jR10:2:0R11r58ggoR14oR15i512R16i524R17R18gR19r17R20jR21:1:1r21ghggoR14oR15i531R16i586R17R18gR19r3R20jR21:10:3oR14oR15i535R16i576R17R18gR19jR4:2:0R20jR21:5:3jR23:14:0oR14oR15i535R16i544R17R18gR19r79R20jR21:1:1oR0y9:killAlphay10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-146R5r68R11r79ggoR14oR15i548R16i576R17R18gR19r79R20jR21:5:3jR23:9:0oR14oR15i548R16i572R17R18gR19jR4:3:0R20jR21:5:3jR23:3:0oR14oR15i548R16i551R17R18gR19r92R20jR21:9:2oR14oR15i548R16i549R17R18gR19r49R20jR21:1:1r48gajy14:hxsl.Component:3:0hgoR14oR15i554R16i572R17R18gR19r92R20jR21:1:1oR0y18:killAlphaThresholdR34ajR35:7:2d0d1hR9i-148R5r68R11r92gggoR14oR15i575R16i576R17R18gR19r92R20jR21:0:1jy10:hxsl.Const:3:1zgggoR14oR15i579R16i586R17R18gR19r3R20jR21:11:0gngoR14oR15i592R16i658R17R18gR19r3R20jR21:10:3oR14oR15i596R16i604R17R18gR19r79R20jR21:1:1oR0y8:additiveR34ajR35:0:1nhR9i-145R5r68R11r79ggoR14oR15i612R16i627R17R18gR19jR4:5:2i4r16R20jR21:5:3jR23:20:1jR23:0:0oR14oR15i612R16i622R17R18gR19r129R20jR21:1:1oR0y10:pixelColorR9i-151R5r22R11r129ggoR14oR15i626R16i627R17R18gR19r49R20jR21:1:1r48ggoR14oR15i643R16i658R17R18gR19r129R20jR21:5:3jR23:20:1jR23:1:0oR14oR15i643R16i653R17R18gR19r129R20jR21:1:1r134goR14oR15i657R16i658R17R18gR19r49R20jR21:1:1r48gggoR14oR15i664R16i707R17R18gR19r3R20jR21:10:3oR14oR15i668R16i681R17R18gR19r79R20jR21:1:1oR0y13:specularAlphaR34ajR35:0:1nhR9i-147R5r68R11r79ggoR14oR15i689R16i707R17R18gR19jR4:5:2i3r16R20jR21:5:3jR23:20:1r142oR14oR15i689R16i698R17R18gR19r162R20jR21:1:1oR0y9:specColorR9i-152R5r22R11r162ggoR14oR15i702R16i707R17R18gR19jR4:5:2i3r16R20jR21:9:2oR14oR15i702R16i703R17R18gR19r49R20jR21:1:1r48gar100r100r100hggnghgR12ahghy4:varsar28r123r83r156r104r67r21r134r166r5r38hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<additive public="1" get="accessor" set="accessor"><x path="Bool"/></additive>
		<additive__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</additive__>
		<get_additive get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_additive>
		<set_additive get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_additive>
		<killAlpha public="1" get="accessor" set="accessor"><x path="Bool"/></killAlpha>
		<killAlpha__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</killAlpha__>
		<get_killAlpha get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_killAlpha>
		<set_killAlpha get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_killAlpha>
		<specularAlpha public="1" get="accessor" set="accessor"><x path="Bool"/></specularAlpha>
		<specularAlpha__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</specularAlpha__>
		<get_specularAlpha get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_specularAlpha>
		<set_specularAlpha get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_specularAlpha>
		<killAlphaThreshold public="1" get="accessor" set="accessor"><x path="Float"/></killAlphaThreshold>
		<killAlphaThreshold__ expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
		</killAlphaThreshold__>
		<get_killAlphaThreshold get="inline" set="null" line="5">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_killAlphaThreshold>
		<set_killAlphaThreshold get="inline" set="null" line="5">
			<f a="_v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_killAlphaThreshold>
		<texture public="1" get="accessor" set="accessor"><t path="hxsl.Sampler2D"/></texture>
		<texture__>
			<t path="hxsl.Sampler2D"/>
			<meta><m n=":noCompletion"/></meta>
		</texture__>
		<get_texture get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Sampler2D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_texture>
		<set_texture get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Sampler2D"/>
				<t path="hxsl.Sampler2D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_texture>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="37"><f a="?tex">
	<c path="h3d.mat.Texture"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@input var input:{ var uv : Vec2};
	@const var additive:Bool;
	@const var killAlpha:Bool;
	@const var specularAlpha:Bool;
	@range(0, 1) @param var killAlphaThreshold:Float;
	@param var texture:Sampler2D;
	var calculatedUV:Vec2;
	var pixelColor:Vec4;
	var specColor:Vec3;
	function vertex() {
		calculatedUV = input.uv;
	};
	function fragment() {
		var c = texture.get(calculatedUV);
		if (killAlpha && c.a - killAlphaThreshold < 0) discard;
		if (additive) pixelColor += c else pixelColor *= c;
		if (specularAlpha) specColor *= c.aaa;
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.UVDelta" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/UVDelta.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey18:h3d.shader.UVDeltay4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:0:0y3:refoR0y6:vertexy2:idi-484R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini191y3:maxi250y4:filey72:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FUVDelta.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i197R16i244R17R18gR19jR4:5:2i2jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i197R16i209R17R18gR19r17R20jR21:1:1oR0y12:calculatedUVR9i-483R5jR10:4:0R11r17ggoR14oR15i212R16i244R17R18gR19jR4:5:2i2r16R20jR21:5:3jR23:0:0oR14oR15i212R16i234R17R18gR19jR4:5:2i2r16R20jR21:5:3jR23:1:0oR14oR15i212R16i224R17R18gR19r17R20jR21:1:1r21goR14oR15i227R16i234R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y7:uvScaleR9i-482R5jR10:2:0R11r37gggoR14oR15i237R16i244R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y7:uvDeltaR9i-481R5r39R11r44gggghgR12ahghy4:varsar45r38r21r5hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey18:h3d.shader.UVDeltay4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:0:0y3:refoR0y6:vertexy2:idi-484R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini191y3:maxi250y4:filey72:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FUVDelta.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i197R16i244R17R18gR19jR4:5:2i2jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i197R16i209R17R18gR19r17R20jR21:1:1oR0y12:calculatedUVR9i-483R5jR10:4:0R11r17ggoR14oR15i212R16i244R17R18gR19jR4:5:2i2r16R20jR21:5:3jR23:0:0oR14oR15i212R16i234R17R18gR19jR4:5:2i2r16R20jR21:5:3jR23:1:0oR14oR15i212R16i224R17R18gR19r17R20jR21:1:1r21goR14oR15i227R16i234R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y7:uvScaleR9i-482R5jR10:2:0R11r37gggoR14oR15i237R16i244R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y7:uvDeltaR9i-481R5r39R11r44gggghgR12ahghy4:varsar45r38r21r5hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<uvDelta public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></uvDelta>
		<uvDelta__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</uvDelta__>
		<get_uvDelta get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_uvDelta>
		<set_uvDelta get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_uvDelta>
		<uvScale public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></uvScale>
		<uvScale__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</uvScale__>
		<get_uvScale get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_uvScale>
		<set_uvScale get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_uvScale>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="14">
			<f a="?dx:?dy:?sx:?sy" v="0.:0.:1.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ sy : 1., sx : 1., dy : 0., dx : 0. }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@param var uvDelta:Vec2;
	@param var uvScale:Vec2;
	var calculatedUV:Vec2;
	function vertex() {
		calculatedUV = calculatedUV * uvScale + uvDelta;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.VertexColorAlpha" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/VertexColorAlpha.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey27:h3d.shader.VertexColorAlphay4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:1:0y3:refoR0y8:fragmenty2:idi-223R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini227y3:maxi325y4:filey81:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FVertexColorAlpha.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i233R16i319R17R18gR19r3R20jR21:10:3oR14oR15i237R16i245R17R18gR19jR4:2:0R20jR21:1:1oR0y8:additivey10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-222R5jR10:2:0R11r18ggoR14oR15i253R16i278R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:20:1jR26:0:0oR14oR15i253R16i263R17R18gR19r27R20jR21:1:1oR0y10:pixelColorR9i-221R5jR10:4:0R11r27ggoR14oR15i267R16i278R17R18gR19jR4:5:2i4r26R20jR21:1:1oR0y5:colorR9i-220y6:parentoR0y5:inputR9i-219R5jR10:1:0R11jR4:13:1ar38hgR5r40R11r37gggoR14oR15i294R16i319R17R18gR19r27R20jR21:5:3jR26:20:1jR26:1:0oR14oR15i294R16i304R17R18gR19r27R20jR21:1:1r32goR14oR15i308R16i319R17R18gR19r37R20jR21:1:1r38ggghgR12ahghy4:varsar39r32r19r5hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey27:h3d.shader.VertexColorAlphay4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:1:0y3:refoR0y8:fragmenty2:idi-223R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini227y3:maxi325y4:filey81:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FVertexColorAlpha.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i233R16i319R17R18gR19r3R20jR21:10:3oR14oR15i237R16i245R17R18gR19jR4:2:0R20jR21:1:1oR0y8:additivey10:qualifiersajy17:hxsl.VarQualifier:0:1nhR9i-222R5jR10:2:0R11r18ggoR14oR15i253R16i278R17R18gR19jR4:5:2i4jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:20:1jR26:0:0oR14oR15i253R16i263R17R18gR19r27R20jR21:1:1oR0y10:pixelColorR9i-221R5jR10:4:0R11r27ggoR14oR15i267R16i278R17R18gR19jR4:5:2i4r26R20jR21:1:1oR0y5:colorR9i-220y6:parentoR0y5:inputR9i-219R5jR10:1:0R11jR4:13:1ar38hgR5r40R11r37gggoR14oR15i294R16i319R17R18gR19r27R20jR21:5:3jR26:20:1jR26:1:0oR14oR15i294R16i304R17R18gR19r27R20jR21:1:1r32goR14oR15i308R16i319R17R18gR19r37R20jR21:1:1r38ggghgR12ahghy4:varsar39r32r19r5hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<additive public="1" get="accessor" set="accessor"><x path="Bool"/></additive>
		<additive__>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</additive__>
		<get_additive get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_additive>
		<set_additive get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_additive>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="3"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e>{
	@input var input:{ var color : Vec4};
	var pixelColor:Vec4;
	@const var additive:Bool;
	function fragment() {
		if (additive) pixelColor += input.color else pixelColor *= input.color;
	};
}</e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<class path="h3d.shader.VolumeDecal" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/h3d/shader/VolumeDecal.hx">
		<extends path="hxsl.Shader"/>
		<SRC expr="&quot;oy4:namey22:h3d.shader.VolumeDecaly4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y14:__init__vertexy2:idi-449R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini369y3:maxi530y4:filey76:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FVolumeDecal.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i375R16i441R17R18gR19jR4:5:2i3jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i375R16i392R17R18gR19r17R20jR21:1:1oR0y17:transformedNormalR9i-430R5jR10:4:0R11r17ggoR14oR15i395R16i441R17R18gR19jR4:5:2i3r16R20jR21:8:2oR14oR15i395R16i429R17R18gR19jR4:14:1aoR3r26R12aoR0y1:_R11r26ghghR20jR21:2:1jy12:hxsl.TGlobal:31:0gaoR14oR15i395R16i429R17R18gR19r26R20jR21:3:1oR14oR15i396R16i428R17R18gR19r26R20jR21:5:3jR23:1:0oR14oR15i396R16i402R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y6:normalR9i-444R5jR10:2:0R11r44ggoR14oR15i405R16i428R17R18gR19jR4:6:0R20jR21:8:2oR14oR15i405R16i421R17R18gR19jR4:14:1ahR20jR21:2:1jR26:48:0gaoR14oR15i405R16i421R17R18gR19jR4:7:0R20jR21:1:1oR0y9:modelViewy10:qualifiersajy17:hxsl.VarQualifier:3:0hR9i-416y6:parentoR0y6:globalR9i-413R5jR10:0:0R11jR4:13:1aoR0y4:timeR9i-414R31r64R5r65R11jR4:3:0goR0y9:pixelSizeR9i-415R31r64R5r65R11jR4:5:2i2r16gr61oR0y16:modelViewInverseR29ar63hR9i-417R31r64R5r65R11r60ghgR5r65R11r60gghggghggoR14oR15i447R16i524R17R18gR19jR4:5:2i4r16R20jR21:5:3r18oR14oR15i447R16i465R17R18gR19r82R20jR21:1:1oR0y18:transformedTangentR9i-448R5r22R11r82ggoR14oR15i468R16i524R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i468R16i472R17R18gR19jR4:14:1ahR20jR21:2:1jR26:40:0gaoR14oR15i473R16i520R17R18gR19r26R20jR21:8:2oR14oR15i473R16i508R17R18gR19jR4:14:1aoR3r26R12aoR0R25R11r26ghghR20jR21:2:1r34gaoR14oR15i473R16i508R17R18gR19r26R20jR21:3:1oR14oR15i474R16i507R17R18gR19r26R20jR21:5:3r41oR14oR15i474R16i481R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y7:tangentR9i-445R5r46R11r114ggoR14oR15i484R16i507R17R18gR19r50R20jR21:8:2oR14oR15i484R16i500R17R18gR19jR4:14:1ahR20jR21:2:1r55gaoR14oR15i484R16i500R17R18gR19r60R20jR21:1:1r61ghggghgoR14oR15i521R16i523R17R18gR19r68R20jR21:0:1jy10:hxsl.Const:3:1d1ghgghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-450R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i556R16i1112R17R18gR19r3R20jR21:4:1aoR14oR15i562R16i624R17R18gR19r3R20jR21:7:2oR0y6:matrixR9i-451R5r22R11r60goR14oR15i575R16i623R17R18gR19r60R20jR21:5:3r41oR14oR15i575R16i597R17R18gR19r60R20jR21:1:1oR0y15:inverseViewProjR9i-409R31oR0y6:cameraR9i-402R5r65R11jR4:13:1aoR0y4:viewR9i-403R31r158R5r65R11r60goR0y4:projR9i-404R31r158R5r65R11r60goR0y8:positionR9i-405R31r158R5r65R11jR4:5:2i3r16goR0y8:projFlipR9i-406R31r158R5r65R11r68goR0y8:projDiagR9i-407R31r158R5r65R11jR4:5:2i3r16goR0y8:viewProjR9i-408R31r158R5r65R11r60gr157oR0y5:zNearR9i-410R31r158R5r65R11r68goR0y4:zFarR9i-411R31r158R5r65R11r68goR0y3:dirR9i-412R31r158R5jR10:3:0R11jR4:5:2i3r16ghgR5r65R11r60ggoR14oR15i600R16i623R17R18gR19r60R20jR21:1:1r71gggoR14oR15i629R16i688R17R18gR19r3R20jR21:7:2oR0y9:screenPosR9i-452R5r22R11jR4:5:2i2r16goR14oR15i645R16i687R17R18gR19r183R20jR21:5:3jR23:2:0oR14oR15i645R16i665R17R18gR19r183R20jR21:9:2oR14oR15i645R16i662R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y17:projectedPositionR9i-431R5r22R11r191ggajy14:hxsl.Component:0:0jR54:1:0hgoR14oR15i668R16i687R17R18gR19r68R20jR21:9:2oR14oR15i668R16i685R17R18gR19r191R20jR21:1:1r192gajR54:3:0hgggoR14oR15i693R16i780R17R18gR19r3R20jR21:7:2oR0y3:ruvR9i-453R5r22R11jR4:5:2i4r16goR14oR15i703R16i779R17R18gR19r211R20jR21:8:2oR14oR15i703R16i707R17R18gR19r93R20jR21:2:1r94gaoR14oR15i714R16i723R17R18gR19r183R20jR21:1:1r182goR14oR15i730R16i765R17R18gR19r68R20jR21:8:2oR14oR15i730R16i738R17R18gR19jR4:14:1aoR3r68R12aoR0R25R11jR4:17:1i1goR0y2:uvR11jR4:5:2i2r16ghghR20jR21:2:1jR26:61:0gaoR14oR15i730R16i738R17R18gR19r229R20jR21:1:1oR0y8:depthMapR9i-442R5r65R11r229ggoR14oR15i743R16i764R17R18gR19r231R20jR21:8:2oR14oR15i743R16i753R17R18gR19jR4:14:1aoR3r231R12aoR0R52R11r231ghghR20jR21:2:1jR26:56:0gaoR14oR15i754R16i763R17R18gR19r183R20jR21:1:1r182ghghgoR14oR15i772R16i773R17R18gR19r68R20jR21:0:1jR38:3:1i1ghggoR14oR15i785R16i809R17R18gR19r3R20jR21:7:2oR0y4:wposR9i-454R5r22R11jR4:5:2i4r16goR14oR15i796R16i808R17R18gR19r266R20jR21:5:3r41oR14oR15i796R16i799R17R18gR19r211R20jR21:1:1r210goR14oR15i802R16i808R17R18gR19r60R20jR21:1:1r152gggoR14oR15i814R16i854R17R18gR19r3R20jR21:7:2oR0y4:pposR9i-455R5r22R11r266goR14oR15i825R16i853R17R18gR19r266R20jR21:5:3r41oR14oR15i825R16i828R17R18gR19r211R20jR21:1:1r210goR14oR15i831R16i853R17R18gR19r60R20jR21:1:1r157gggoR14oR15i859R16i903R17R18gR19jR4:5:2i3r16R20jR21:5:3r18oR14oR15i859R16i883R17R18gR19r292R20jR21:1:1oR0y24:pixelTransformedPositionR9i-429R5r22R11r292ggoR14oR15i886R16i903R17R18gR19jR4:5:2i3r16R20jR21:5:3r186oR14oR15i886R16i894R17R18gR19r299R20jR21:9:2oR14oR15i886R16i890R17R18gR19r266R20jR21:1:1r279gar195r196jR54:2:0hgoR14oR15i897R16i903R17R18gR19r68R20jR21:9:2oR14oR15i897R16i901R17R18gR19r266R20jR21:1:1r279gar204hgggoR14oR15i909R16i950R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i909R16i921R17R18gR19r319R20jR21:1:1oR0y12:calculatedUVR9i-447R5r22R11r319ggoR14oR15i924R16i950R17R18gR19jR4:5:2i2r16R20jR21:5:3r41oR14oR15i924R16i929R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y5:scaleR9i-443R5r46R11r329ggoR14oR15i932R16i950R17R18gR19jR4:5:2i2r16R20jR21:3:1oR14oR15i933R16i949R17R18gR19r334R20jR21:5:3r186oR14oR15i933R16i940R17R18gR19r334R20jR21:9:2oR14oR15i933R16i937R17R18gR19r266R20jR21:1:1r265gar195r196hgoR14oR15i943R16i949R17R18gR19r68R20jR21:9:2oR14oR15i943R16i947R17R18gR19r266R20jR21:1:1r265gar204hgggggoR14oR15i956R16i992R17R18gR19r3R20jR21:10:3oR14oR15i960R16i970R17R18gR19jR4:2:0R20jR21:1:1oR0y10:isCenteredR29ajR30:0:1nhR9i-446R5r46R11r359ggoR14oR15i973R16i992R17R18gR19r319R20jR21:5:3jR23:20:1jR23:0:0oR14oR15i973R16i985R17R18gR19r319R20jR21:1:1r322goR14oR15i989R16i992R17R18gR19r68R20jR21:0:1jR38:3:1d0.5ggngoR14oR15i998R16i1106R17R18gR19r3R20jR21:10:3oR14oR15i1002R16i1091R17R18gR19r359R20jR21:5:3jR23:9:0oR14oR15i1002R16i1087R17R18gR19r68R20jR21:8:2oR14oR15i1002R16i1005R17R18gR19jR4:14:1aoR3r68R12aoR0y1:aR11r68goR0y1:bR11r68ghghR20jR21:2:1jR26:21:0gaoR14oR15i1006R16i1041R17R18gR19r68R20jR21:8:2oR14oR15i1006R16i1009R17R18gR19jR4:14:1ar387hR20jR21:2:1r392gaoR14oR15i1010R16i1024R17R18gR19r68R20jR21:9:2oR14oR15i1010R16i1022R17R18gR19r319R20jR21:1:1r322gar195hgoR14oR15i1026R16i1040R17R18gR19r68R20jR21:9:2oR14oR15i1026R16i1038R17R18gR19r319R20jR21:1:1r322gar196hghgoR14oR15i1043R16i1086R17R18gR19r68R20jR21:8:2oR14oR15i1043R16i1046R17R18gR19jR4:14:1ar387hR20jR21:2:1r392gaoR14oR15i1047R16i1065R17R18gR19r68R20jR21:5:3jR23:3:0oR14oR15i1047R16i1048R17R18gR19r68R20jR21:0:1jR38:3:1i1goR14oR15i1051R16i1065R17R18gR19r68R20jR21:9:2oR14oR15i1051R16i1063R17R18gR19r319R20jR21:1:1r322gar195hggoR14oR15i1067R16i1085R17R18gR19r68R20jR21:5:3r428oR14oR15i1067R16i1068R17R18gR19r68R20jR21:0:1jR38:3:1i1goR14oR15i1071R16i1085R17R18gR19r68R20jR21:9:2oR14oR15i1071R16i1083R17R18gR19r319R20jR21:1:1r322gar196hgghghgoR14oR15i1090R16i1091R17R18gR19r68R20jR21:0:1jR38:3:1zggoR14oR15i1099R16i1106R17R18gR19r3R20jR21:11:0gnghgR12ahghy4:varsar158r64oR0y5:inputR9i-418R5jR10:1:0R11jR4:13:1aoR0R45R9i-419R31r469R5r470R11jR4:5:2i3r16goR0R27R9i-420R31r469R5r470R11jR4:5:2i3r16ghgoR0y6:outputR9i-421R5r22R11jR4:13:1aoR0R45R9i-422R31r477R5r22R11jR4:5:2i4r16goR0y5:colorR9i-423R31r477R5r22R11jR4:5:2i4r16goR0y5:depthR9i-424R31r477R5r22R11r68goR0R27R9i-425R31r477R5r22R11jR4:5:2i3r16goR0y9:worldDistR9i-426R31r477R5r22R11r68ghgoR0y16:relativePositionR9i-427R5r22R11jR4:5:2i3r16goR0y19:transformedPositionR9i-428R5r22R11jR4:5:2i3r16gr295r21r192oR0y10:pixelColorR9i-432R5r22R11jR4:5:2i4r16goR0R70R9i-433R5r22R11r68goR0y8:screenUVR9i-434R5r22R11jR4:5:2i2r16goR0y9:specPowerR9i-435R5r22R11r68goR0y9:specColorR9i-436R5r22R11jR4:5:2i3r16goR0R71R9i-437R5r22R11r68gr238r330r45r115r360r322r85r5r142hg&quot;" line="5" static="1">
			<c path="String"/>
			<meta>
				<m n=":value"><e>"oy4:namey22:h3d.shader.VolumeDecaly4:funsaoy3:retjy9:hxsl.Type:0:0y4:kindjy17:hxsl.FunctionKind:2:0y3:refoR0y14:__init__vertexy2:idi-449R5jy12:hxsl.VarKind:6:0y4:typejR4:14:1aoR3r3y4:argsahghgy4:exproy1:poy3:mini369y3:maxi530y4:filey76:E%3A%5CHaxeToolkit%5Clib_haxe4%5Cheaps%2Fgit%2Fh3d%2Fshader%2FVolumeDecal.hxgy1:tr3y1:ejy13:hxsl.TExprDef:4:1aoR14oR15i375R16i441R17R18gR19jR4:5:2i3jy12:hxsl.VecType:1:0R20jR21:5:3jy16:haxe.macro.Binop:4:0oR14oR15i375R16i392R17R18gR19r17R20jR21:1:1oR0y17:transformedNormalR9i-430R5jR10:4:0R11r17ggoR14oR15i395R16i441R17R18gR19jR4:5:2i3r16R20jR21:8:2oR14oR15i395R16i429R17R18gR19jR4:14:1aoR3r26R12aoR0y1:_R11r26ghghR20jR21:2:1jy12:hxsl.TGlobal:31:0gaoR14oR15i395R16i429R17R18gR19r26R20jR21:3:1oR14oR15i396R16i428R17R18gR19r26R20jR21:5:3jR23:1:0oR14oR15i396R16i402R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y6:normalR9i-444R5jR10:2:0R11r44ggoR14oR15i405R16i428R17R18gR19jR4:6:0R20jR21:8:2oR14oR15i405R16i421R17R18gR19jR4:14:1ahR20jR21:2:1jR26:48:0gaoR14oR15i405R16i421R17R18gR19jR4:7:0R20jR21:1:1oR0y9:modelViewy10:qualifiersajy17:hxsl.VarQualifier:3:0hR9i-416y6:parentoR0y6:globalR9i-413R5jR10:0:0R11jR4:13:1aoR0y4:timeR9i-414R31r64R5r65R11jR4:3:0goR0y9:pixelSizeR9i-415R31r64R5r65R11jR4:5:2i2r16gr61oR0y16:modelViewInverseR29ar63hR9i-417R31r64R5r65R11r60ghgR5r65R11r60gghggghggoR14oR15i447R16i524R17R18gR19jR4:5:2i4r16R20jR21:5:3r18oR14oR15i447R16i465R17R18gR19r82R20jR21:1:1oR0y18:transformedTangentR9i-448R5r22R11r82ggoR14oR15i468R16i524R17R18gR19jR4:5:2i4r16R20jR21:8:2oR14oR15i468R16i472R17R18gR19jR4:14:1ahR20jR21:2:1jR26:40:0gaoR14oR15i473R16i520R17R18gR19r26R20jR21:8:2oR14oR15i473R16i508R17R18gR19jR4:14:1aoR3r26R12aoR0R25R11r26ghghR20jR21:2:1r34gaoR14oR15i473R16i508R17R18gR19r26R20jR21:3:1oR14oR15i474R16i507R17R18gR19r26R20jR21:5:3r41oR14oR15i474R16i481R17R18gR19jR4:5:2i3r16R20jR21:1:1oR0y7:tangentR9i-445R5r46R11r114ggoR14oR15i484R16i507R17R18gR19r50R20jR21:8:2oR14oR15i484R16i500R17R18gR19jR4:14:1ahR20jR21:2:1r55gaoR14oR15i484R16i500R17R18gR19r60R20jR21:1:1r61ghggghgoR14oR15i521R16i523R17R18gR19r68R20jR21:0:1jy10:hxsl.Const:3:1d1ghgghgR12ahgoR3r3R5jR6:1:0R7oR0y8:fragmentR9i-450R5r6R11jR4:14:1aoR3r3R12ahghgR13oR14oR15i556R16i1112R17R18gR19r3R20jR21:4:1aoR14oR15i562R16i624R17R18gR19r3R20jR21:7:2oR0y6:matrixR9i-451R5r22R11r60goR14oR15i575R16i623R17R18gR19r60R20jR21:5:3r41oR14oR15i575R16i597R17R18gR19r60R20jR21:1:1oR0y15:inverseViewProjR9i-409R31oR0y6:cameraR9i-402R5r65R11jR4:13:1aoR0y4:viewR9i-403R31r158R5r65R11r60goR0y4:projR9i-404R31r158R5r65R11r60goR0y8:positionR9i-405R31r158R5r65R11jR4:5:2i3r16goR0y8:projFlipR9i-406R31r158R5r65R11r68goR0y8:projDiagR9i-407R31r158R5r65R11jR4:5:2i3r16goR0y8:viewProjR9i-408R31r158R5r65R11r60gr157oR0y5:zNearR9i-410R31r158R5r65R11r68goR0y4:zFarR9i-411R31r158R5r65R11r68goR0y3:dirR9i-412R31r158R5jR10:3:0R11jR4:5:2i3r16ghgR5r65R11r60ggoR14oR15i600R16i623R17R18gR19r60R20jR21:1:1r71gggoR14oR15i629R16i688R17R18gR19r3R20jR21:7:2oR0y9:screenPosR9i-452R5r22R11jR4:5:2i2r16goR14oR15i645R16i687R17R18gR19r183R20jR21:5:3jR23:2:0oR14oR15i645R16i665R17R18gR19r183R20jR21:9:2oR14oR15i645R16i662R17R18gR19jR4:5:2i4r16R20jR21:1:1oR0y17:projectedPositionR9i-431R5r22R11r191ggajy14:hxsl.Component:0:0jR54:1:0hgoR14oR15i668R16i687R17R18gR19r68R20jR21:9:2oR14oR15i668R16i685R17R18gR19r191R20jR21:1:1r192gajR54:3:0hgggoR14oR15i693R16i780R17R18gR19r3R20jR21:7:2oR0y3:ruvR9i-453R5r22R11jR4:5:2i4r16goR14oR15i703R16i779R17R18gR19r211R20jR21:8:2oR14oR15i703R16i707R17R18gR19r93R20jR21:2:1r94gaoR14oR15i714R16i723R17R18gR19r183R20jR21:1:1r182goR14oR15i730R16i765R17R18gR19r68R20jR21:8:2oR14oR15i730R16i738R17R18gR19jR4:14:1aoR3r68R12aoR0R25R11jR4:17:1i1goR0y2:uvR11jR4:5:2i2r16ghghR20jR21:2:1jR26:61:0gaoR14oR15i730R16i738R17R18gR19r229R20jR21:1:1oR0y8:depthMapR9i-442R5r65R11r229ggoR14oR15i743R16i764R17R18gR19r231R20jR21:8:2oR14oR15i743R16i753R17R18gR19jR4:14:1aoR3r231R12aoR0R52R11r231ghghR20jR21:2:1jR26:56:0gaoR14oR15i754R16i763R17R18gR19r183R20jR21:1:1r182ghghgoR14oR15i772R16i773R17R18gR19r68R20jR21:0:1jR38:3:1i1ghggoR14oR15i785R16i809R17R18gR19r3R20jR21:7:2oR0y4:wposR9i-454R5r22R11jR4:5:2i4r16goR14oR15i796R16i808R17R18gR19r266R20jR21:5:3r41oR14oR15i796R16i799R17R18gR19r211R20jR21:1:1r210goR14oR15i802R16i808R17R18gR19r60R20jR21:1:1r152gggoR14oR15i814R16i854R17R18gR19r3R20jR21:7:2oR0y4:pposR9i-455R5r22R11r266goR14oR15i825R16i853R17R18gR19r266R20jR21:5:3r41oR14oR15i825R16i828R17R18gR19r211R20jR21:1:1r210goR14oR15i831R16i853R17R18gR19r60R20jR21:1:1r157gggoR14oR15i859R16i903R17R18gR19jR4:5:2i3r16R20jR21:5:3r18oR14oR15i859R16i883R17R18gR19r292R20jR21:1:1oR0y24:pixelTransformedPositionR9i-429R5r22R11r292ggoR14oR15i886R16i903R17R18gR19jR4:5:2i3r16R20jR21:5:3r186oR14oR15i886R16i894R17R18gR19r299R20jR21:9:2oR14oR15i886R16i890R17R18gR19r266R20jR21:1:1r279gar195r196jR54:2:0hgoR14oR15i897R16i903R17R18gR19r68R20jR21:9:2oR14oR15i897R16i901R17R18gR19r266R20jR21:1:1r279gar204hgggoR14oR15i909R16i950R17R18gR19jR4:5:2i2r16R20jR21:5:3r18oR14oR15i909R16i921R17R18gR19r319R20jR21:1:1oR0y12:calculatedUVR9i-447R5r22R11r319ggoR14oR15i924R16i950R17R18gR19jR4:5:2i2r16R20jR21:5:3r41oR14oR15i924R16i929R17R18gR19jR4:5:2i2r16R20jR21:1:1oR0y5:scaleR9i-443R5r46R11r329ggoR14oR15i932R16i950R17R18gR19jR4:5:2i2r16R20jR21:3:1oR14oR15i933R16i949R17R18gR19r334R20jR21:5:3r186oR14oR15i933R16i940R17R18gR19r334R20jR21:9:2oR14oR15i933R16i937R17R18gR19r266R20jR21:1:1r265gar195r196hgoR14oR15i943R16i949R17R18gR19r68R20jR21:9:2oR14oR15i943R16i947R17R18gR19r266R20jR21:1:1r265gar204hgggggoR14oR15i956R16i992R17R18gR19r3R20jR21:10:3oR14oR15i960R16i970R17R18gR19jR4:2:0R20jR21:1:1oR0y10:isCenteredR29ajR30:0:1nhR9i-446R5r46R11r359ggoR14oR15i973R16i992R17R18gR19r319R20jR21:5:3jR23:20:1jR23:0:0oR14oR15i973R16i985R17R18gR19r319R20jR21:1:1r322goR14oR15i989R16i992R17R18gR19r68R20jR21:0:1jR38:3:1d0.5ggngoR14oR15i998R16i1106R17R18gR19r3R20jR21:10:3oR14oR15i1002R16i1091R17R18gR19r359R20jR21:5:3jR23:9:0oR14oR15i1002R16i1087R17R18gR19r68R20jR21:8:2oR14oR15i1002R16i1005R17R18gR19jR4:14:1aoR3r68R12aoR0y1:aR11r68goR0y1:bR11r68ghghR20jR21:2:1jR26:21:0gaoR14oR15i1006R16i1041R17R18gR19r68R20jR21:8:2oR14oR15i1006R16i1009R17R18gR19jR4:14:1ar387hR20jR21:2:1r392gaoR14oR15i1010R16i1024R17R18gR19r68R20jR21:9:2oR14oR15i1010R16i1022R17R18gR19r319R20jR21:1:1r322gar195hgoR14oR15i1026R16i1040R17R18gR19r68R20jR21:9:2oR14oR15i1026R16i1038R17R18gR19r319R20jR21:1:1r322gar196hghgoR14oR15i1043R16i1086R17R18gR19r68R20jR21:8:2oR14oR15i1043R16i1046R17R18gR19jR4:14:1ar387hR20jR21:2:1r392gaoR14oR15i1047R16i1065R17R18gR19r68R20jR21:5:3jR23:3:0oR14oR15i1047R16i1048R17R18gR19r68R20jR21:0:1jR38:3:1i1goR14oR15i1051R16i1065R17R18gR19r68R20jR21:9:2oR14oR15i1051R16i1063R17R18gR19r319R20jR21:1:1r322gar195hggoR14oR15i1067R16i1085R17R18gR19r68R20jR21:5:3r428oR14oR15i1067R16i1068R17R18gR19r68R20jR21:0:1jR38:3:1i1goR14oR15i1071R16i1085R17R18gR19r68R20jR21:9:2oR14oR15i1071R16i1083R17R18gR19r319R20jR21:1:1r322gar196hgghghgoR14oR15i1090R16i1091R17R18gR19r68R20jR21:0:1jR38:3:1zggoR14oR15i1099R16i1106R17R18gR19r3R20jR21:11:0gnghgR12ahghy4:varsar158r64oR0y5:inputR9i-418R5jR10:1:0R11jR4:13:1aoR0R45R9i-419R31r469R5r470R11jR4:5:2i3r16goR0R27R9i-420R31r469R5r470R11jR4:5:2i3r16ghgoR0y6:outputR9i-421R5r22R11jR4:13:1aoR0R45R9i-422R31r477R5r22R11jR4:5:2i4r16goR0y5:colorR9i-423R31r477R5r22R11jR4:5:2i4r16goR0y5:depthR9i-424R31r477R5r22R11r68goR0R27R9i-425R31r477R5r22R11jR4:5:2i3r16goR0y9:worldDistR9i-426R31r477R5r22R11r68ghgoR0y16:relativePositionR9i-427R5r22R11jR4:5:2i3r16goR0y19:transformedPositionR9i-428R5r22R11jR4:5:2i3r16gr295r21r192oR0y10:pixelColorR9i-432R5r22R11jR4:5:2i4r16goR0R70R9i-433R5r22R11r68goR0y8:screenUVR9i-434R5r22R11jR4:5:2i2r16goR0y9:specPowerR9i-435R5r22R11r68goR0y9:specColorR9i-436R5r22R11jR4:5:2i3r16goR0R71R9i-437R5r22R11r68gr238r330r45r115r360r322r85r5r142hg"</e></m>
				<m n=":keep"/>
			</meta>
		</SRC>
		<_SHADER static="1">
			<c path="hxsl.SharedShader"/>
			<meta><m n=":keep"/></meta>
		</_SHADER>
		<scale public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></scale>
		<scale__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</scale__>
		<get_scale get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_scale>
		<set_scale get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_scale>
		<normal public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></normal>
		<normal__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</normal__>
		<get_normal get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_normal>
		<set_normal get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_normal>
		<tangent public="1" get="accessor" set="accessor"><t path="hxsl.Vec"/></tangent>
		<tangent__ expr="new hxsl.Types.Vec()">
			<t path="hxsl.Vec"/>
			<meta>
				<m n=":value"><e>new hxsl.Types.Vec()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</tangent__>
		<get_tangent get="inline" set="null" line="5">
			<f a=""><t path="hxsl.Vec"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_tangent>
		<set_tangent get="inline" set="null" line="5">
			<f a="_v">
				<t path="hxsl.Vec"/>
				<t path="hxsl.Vec"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_tangent>
		<isCentered public="1" get="accessor" set="accessor"><x path="Bool"/></isCentered>
		<isCentered__ expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":noCompletion"/>
			</meta>
		</isCentered__>
		<get_isCentered get="inline" set="null" line="5">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isCentered>
		<set_isCentered get="inline" set="null" line="5">
			<f a="_v">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_isCentered>
		<updateConstants public="1" set="method" line="5" override="1"><f a="globals">
	<c path="hxsl.Globals"/>
	<x path="Void"/>
</f></updateConstants>
		<getParamValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<d/>
</f></getParamValue>
		<getParamFloatValue public="1" set="method" line="5" override="1"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></getParamFloatValue>
		<clone public="1" set="method" line="5" override="1"><f a=""><c path="hxsl.Shader"/></f></clone>
		<new public="1" set="method" line="42"><f a="objectWidth:objectHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":src"><e><![CDATA[{
	@:import BaseMesh;
	@global var depthMap:Channel;
	@param var scale:Vec2;
	@param var normal:Vec3;
	@param var tangent:Vec3;
	@const var isCentered:Bool = true;
	var calculatedUV:Vec2;
	var transformedTangent:Vec4;
	function __init__vertex() {
		transformedNormal = (normal * global.modelView.mat3()).normalize();
		transformedTangent = vec4((tangent * global.modelView.mat3()).normalize(), 1.);
	};
	function fragment() {
		var matrix = camera.inverseViewProj * global.modelViewInverse;
		var screenPos = projectedPosition.xy / projectedPosition.w;
		var ruv = vec4(screenPos, depthMap.get(screenToUv(screenPos)), 1);
		var wpos = ruv * matrix;
		var ppos = ruv * camera.inverseViewProj;
		pixelTransformedPosition = ppos.xyz / ppos.w;
		calculatedUV = scale * (wpos.xy / wpos.w);
		if (isCentered) calculatedUV += 0.5;
		if (min(min(calculatedUV.x, calculatedUV.y), min(1 - calculatedUV.x, 1 - calculatedUV.y)) < 0) discard;
	};
}]]></e></m>
			<m n=":build"><e>hxsl.Macros.buildShader()</e></m>
			<m n=":autoBuild"><e>hxsl.Macros.buildShader()</e></m>
		</meta>
	</class>
	<abstract path="haxe.Function" params="" file="E:\HaxeToolkit\haxe\std\haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="E:\HaxeToolkit\haxe\std\haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="E:\HaxeToolkit\haxe\std\haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is public and
	  * unifies with the type used for type parameter `T`.

	If a type parameter A is assigned to a type parameter B which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="E:\HaxeToolkit\haxe\std\haxe/Constraints.hx" module="haxe.Constraints" interface="1"><meta><m n=":keep"/></meta></class>
	<abstract path="haxe.DynamicAccess" params="T" file="E:\HaxeToolkit\haxe\std\haxe/DynamicAccess.hx">
		<from><icast><d><c path="haxe.DynamicAccess.T"/></d></icast></from>
		<this><d><c path="haxe.DynamicAccess.T"/></d></this>
		<to><icast><d><c path="haxe.DynamicAccess.T"/></d></icast></to>
		<haxe_doc>DynamicAccess is an abstract type for working with anonymous structures
	that are intended to hold collections of objects by the string key.

	For example, these types of structures are often created from JSON.

	Basically, it wraps `Reflect` calls in a `Map`-like interface.</haxe_doc>
		<impl><class path="haxe._DynamicAccess.DynamicAccess_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/DynamicAccess.hx" private="1" module="haxe.DynamicAccess"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.EntryPoint" params="" file="E:\HaxeToolkit\haxe\std\haxe/EntryPoint.hx">
		<pending expr="new Array&lt;Void&gt;()" line="49" static="1">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Array<Void>()]]></e></m></meta>
		</pending>
		<threadCount public="1" set="null" expr="0" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</threadCount>
		<processEvents set="method" line="91" static="1"><f a=""><x path="Float"/></f></processEvents>
		<run public="1" set="method" line="113" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Start the main loop. Depending on the platform, this can return immediately or will only return when the application exits.</haxe_doc>
		</run>
		<haxe_doc>If haxe.MainLoop is kept from DCE, then we will insert an haxe.EntryPoint.run() call just at then end of main().
	This class can be redefined by custom frameworks so they can handle their own main loop logic.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="haxe.EnumFlags" params="T" file="E:\HaxeToolkit\haxe\std\haxe/EnumFlags.hx">
		<this><x path="Int"/></this>
		<haxe_doc>A typed interface for bit flags. This is not a real object, only a typed
	interface for an actual Int. Each flag can be tested/set with the
	corresponding enum instance. Up to 32 flags can be stored that way.

	Enum constructor indices are preserved from Haxe syntax, so the first
	declared is index 0, the next index 1 etc. The methods are optimized if the
	enum instance is passed directly, e.g. as has(EnumCtor). Otherwise
	Type.enumIndex() reflection is used.</haxe_doc>
		<impl><class path="haxe._EnumFlags.EnumFlags_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/EnumFlags.hx" private="1" module="haxe.EnumFlags"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.EnumTools" params="" file="E:\HaxeToolkit\haxe\std\haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="50" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="63" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="79" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="96" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="108" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
  [extension](https://haxe.org/manual/lf-static-extension.html) to the
  `enum` types.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="E:\HaxeToolkit\haxe\std\haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="132" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="143" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="157" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="169" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
  [extension](https://haxe.org/manual/lf-static-extension.html) to the
  `EnumValue` types.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<abstract path="haxe.Int32" params="" file="E:\HaxeToolkit\haxe\std\haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
 	all platforms.</haxe_doc>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/Int32.hx" private="1" module="haxe.Int32"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Int64" params="" file="E:\HaxeToolkit\haxe\std\haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/Int64.hx" private="1" module="haxe.Int64">
	<high public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</high>
	<low public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</low>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="E:\HaxeToolkit\haxe\std\haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>* This typedef will fool @:coreApi into thinking that we are using
  * the same underlying type, even though it might be different on
  * specific platforms.</haxe_doc>
	</typedef>
	<class path="haxe._Int64.___Int64" params="" file="E:\HaxeToolkit\haxe\std\haxe/Int64.hx" private="1" module="haxe.Int64">
		<high public="1"><x path="haxe.Int32"/></high>
		<low public="1"><x path="haxe.Int32"/></low>
		<new public="1" get="inline" set="null" line="459"><f a="high:low">
	<x path="haxe.Int32"/>
	<x path="haxe.Int32"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.Log" params="" file="E:\HaxeToolkit\haxe\std\haxe/Log.hx">
		<formatOutput public="1" set="method" line="33" static="1">
			<f a="v:infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<c path="String"/>
			</f>
			<haxe_doc>Format the output of `trace` before printing it.</haxe_doc>
		</formatOutput>
		<trace public="1" set="dynamic" line="60" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the `trace()` call was made.

		This method can be rebound to a custom function:
		
			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v, ?infos) {
			  // handle trace
			}
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to `trace()` will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the `trace()` method, which is invoked upon a call to
	`trace()` in Haxe code.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.MainEvent" params="" file="E:\HaxeToolkit\haxe\std\haxe/MainLoop.hx" module="haxe.MainLoop">
		<f><f a=""><x path="Void"/></f></f>
		<prev><c path="haxe.MainEvent"/></prev>
		<next><c path="haxe.MainEvent"/></next>
		<isBlocking public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>Tells if the event can lock the process from exiting (default:true)</haxe_doc>
		</isBlocking>
		<nextRun public="1" set="null"><x path="Float"/></nextRun>
		<priority public="1" set="null"><x path="Int"/></priority>
		<delay public="1" set="method" line="26">
			<f a="t">
				<x path="Null"><x path="Float"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Delay the execution of the event for the given time, in seconds.
		If t is null, the event will be run at tick() time.</haxe_doc>
		</delay>
		<stop public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stop the event from firing anymore.</haxe_doc>
		</stop>
		<new set="method" line="16"><f a="f:p">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.MainLoop" params="" file="E:\HaxeToolkit\haxe\std\haxe/MainLoop.hx">
		<pending static="1"><c path="haxe.MainEvent"/></pending>
		<threadCount public="1" get="null" set="null" static="1"><x path="Int"/></threadCount>
		<hasEvents public="1" set="method" line="63" static="1"><f a=""><x path="Bool"/></f></hasEvents>
		<add public="1" set="method" line="84" static="1">
			<f a="f:?priority" v=":0">
				<f a=""><x path="Void"/></f>
				<x path="Int"/>
				<c path="haxe.MainEvent"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0 }</e></m></meta>
			<haxe_doc>Add a pending event to be run into the main loop.</haxe_doc>
		</add>
		<sortEvents set="method" line="95" static="1"><f a=""><x path="Void"/></f></sortEvents>
		<tick set="method" line="156" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Run the pending events. Return the time for next event.</haxe_doc>
		</tick>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":access"><e>haxe.MainEvent</e></m>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="E:\HaxeToolkit\haxe\std\haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<x path="Null"><c path="Array"><d/></c></x>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.Serializer" params="" file="E:\HaxeToolkit\haxe\std\haxe/Serializer.hx">
		<USE_CACHE public="1" expr="false" line="56" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>If the values you are serializing can contain circular references or
		objects repetitions, you should set `USE_CACHE` to true to prevent
		infinite loops.

		This may also reduce the size of serialization Strings at the expense of
		performance.

		This value can be changed for individual instances of Serializer by
		setting their useCache field.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" expr="false" line="68" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Use constructor indexes for enums instead of names.

		This may reduce the size of serialization Strings, but makes them less
		suited for long-term storage: If constructors are removed or added from
		the enum, the indices may no longer match.

		This value can be changed for individual instances of Serializer by
		setting their useEnumIndex field.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:&quot;" line="70" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"</e></m></meta>
		</BASE64>
		<BASE64_CODES expr="null" line="71" static="1">
			<x path="haxe.ds.Vector"><x path="Null"><x path="Int"/></x></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</BASE64_CODES>
		<run public="1" set="method" line="565" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Serializes `v` and returns the String representation.

		This is a convenience function for creating a new instance of
		Serializer, serialize `v` into it and obtain the result through a call
		to toString().</haxe_doc>
		</run>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="haxe.ds.StringMap"><x path="Int"/></c></shash>
		<scount><x path="Int"/></scount>
		<useCache public="1">
			<x path="Bool"/>
			<haxe_doc>The individual cache setting for `this` Serializer instance.

		See USE_CACHE for a complete description.</haxe_doc>
		</useCache>
		<useEnumIndex public="1">
			<x path="Bool"/>
			<haxe_doc>The individual enum index setting for `this` Serializer instance.

		See USE_ENUM_INDEX for a complete description.</haxe_doc>
		</useEnumIndex>
		<toString public="1" set="method" line="117">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return the String representation of `this` Serializer.

		The exact format specification can be found here:
		https://haxe.org/manual/serialization/format</haxe_doc>
		</toString>
		<serializeString set="method" line="154"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="173"><f a="v">
	<d/>
	<x path="Bool"/>
</f></serializeRef>
		<serializeFields set="method" line="210"><f a="v">
	<a/>
	<x path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="228">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Serializes `v`.

		All haxe-defined values and objects with the exception of functions can
		be serialized. Serialization of external/native objects is not
		guaranteed to work.

		The values of `this.useCache` and `this.useEnumIndex` may affect
		serialization output.</haxe_doc>
		</serialize>
		<new public="1" set="method" line="102">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Serializer instance.

		Subsequent calls to `this.serialize` will append values to the
		internal buffer of this String. Once complete, the contents can be
		retrieved through a call to `this.toString`.

		Each Serializer instance maintains its own cache if this.useCache` is
		true.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The Serializer class can be used to encode values and objects into a `String`,
	from which the `Unserializer` class can recreate the original representation.

	This class can be used in two ways:

	- create a `new Serializer()` instance, call its `serialize()` method with
		any argument and finally retrieve the String representation from
		`toString()`
	- call `Serializer.run()` to obtain the serialized representation of a
		single argument

	Serialization is guaranteed to work for all haxe-defined classes, but may
	or may not work for instances of external/native classes.

	The specification of the serialization format can be found here:
	<https://haxe.org/manual/std-serialization-format.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Timer" params="" file="E:\HaxeToolkit\haxe\std\haxe/Timer.hx">
		<delay public="1" set="method" line="136" static="1">
			<f a="f:time_ms">
				<f a=""><x path="Void"/></f>
				<x path="Int"/>
				<c path="haxe.Timer"/>
			</f>
			<haxe_doc>Invokes `f` after `time_ms` milliseconds.

		This is a convenience function for creating a new Timer instance with
		`time_ms` as argument, binding its run() method to `f` and then stopping
		`this` Timer upon the first invocation.

		If `f` is null, the result is unspecified.</haxe_doc>
		</delay>
		<event><c path="haxe.MainEvent"/></event>
		<stop public="1" set="method" line="88">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stops `this` Timer.

		After calling this method, no additional invocations of `this.run`
		will occur.

		It is not possible to restart `this` Timer once stopped.</haxe_doc>
		</stop>
		<run public="1" set="dynamic" line="123">
			<f a=""><x path="Void"/></f>
			<haxe_doc>This method is invoked repeatedly on `this` Timer.

		It can be overridden in a subclass, or rebound directly to a custom
		function:
			var timer = new haxe.Timer(1000); // 1000ms delay
			timer.run = function() { ... }

		Once bound, it can still be rebound to different functions until `this`
		Timer is stopped through a call to `this.stop`.</haxe_doc>
		</run>
		<new public="1" set="method" line="60">
			<f a="time_ms">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new timer that will run every `time_ms` milliseconds.

		After creating the Timer instance, it calls `this.run` repeatedly,
		with delays of `time_ms` milliseconds, until `this.stop` is called.

		The first invocation occurs after `time_ms` milliseconds, not
		immediately.

		The accuracy of this may be platform-dependent.</haxe_doc>
		</new>
		<haxe_doc>The Timer class allows you to create asynchronous timers on platforms that
	support events.

	The intended usage is to create an instance of the Timer class with a given
	interval, set its run() method to a custom function to be invoked and
	eventually call stop() to stop the Timer.

	Note that a running Timer may or may not prevent the program to exit
	automatically when main() returns.

	It is also possible to extend this class and override its run() method in
	the child class.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe._Unserializer.DefaultResolver" params="" file="E:\HaxeToolkit\haxe\std\haxe/Unserializer.hx" private="1" module="haxe.Unserializer">
		<resolveClass public="1" get="inline" set="null" line="479"><f a="name">
	<c path="String"/>
	<x path="Class"><d/></x>
</f></resolveClass>
		<resolveEnum public="1" get="inline" set="null" line="480"><f a="name">
	<c path="String"/>
	<x path="Enum"><d/></x>
</f></resolveEnum>
		<new public="1" set="method" line="478"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Unserializer" params="" file="E:\HaxeToolkit\haxe\std\haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" expr="new DefaultResolver()" line="65" static="1">
			<t path="haxe.TypeResolver"/>
			<meta><m n=":value"><e>new DefaultResolver()</e></m></meta>
			<haxe_doc><![CDATA[This value can be set to use custom type resolvers.

		A type resolver finds a `Class` or `Enum` instance from a given `String`.
		By default, the Haxe `Type` Api is used.

		A type resolver must provide two methods:

		1. `resolveClass(name:String):Class<Dynamic>` is called to determine a
				`Class` from a class name
		2. `resolveEnum(name:String):Enum<Dynamic>` is called to determine an
				`Enum` from an enum name

		This value is applied when a new `Unserializer` instance is created.
		Changing it afterwards has no effect on previously created instances.]]></haxe_doc>
		</DEFAULT_RESOLVER>
		<BASE64 expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:&quot;" line="67" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"</e></m></meta>
		</BASE64>
		<CODES expr="null" line="70" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</CODES>
		<initCodes set="method" line="72" static="1"><f a=""><c path="Array"><x path="Int"/></c></f></initCodes>
		<run public="1" set="method" line="467" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Unserializes `v` and returns the according value.

		This is a convenience function for creating a new instance of
		Unserializer with `v` as buffer and calling its unserialize() method
		once.</haxe_doc>
		</run>
		<buf><c path="String"/></buf>
		<pos><x path="Int"/></pos>
		<length><x path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<readDigits set="method" line="149"><f a=""><x path="Int"/></f></readDigits>
		<readFloat set="method" line="174"><f a=""><x path="Float"/></f></readFloat>
		<unserializeObject set="method" line="188"><f a="o">
	<a/>
	<x path="Void"/>
</f></unserializeObject>
		<unserializeEnum params="T" set="method" line="203"><f a="edecl:tag">
	<x path="Enum"><c path="unserializeEnum.T"/></x>
	<c path="String"/>
	<c path="unserializeEnum.T"/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="235">
			<f a=""><d/></f>
			<haxe_doc>Unserializes the next part of `this` Unserializer instance and returns
		the according value.

		This function may call `this.resolver.resolveClass` to determine a
		Class from a String, and `this.resolver.resolveEnum` to determine an
		Enum from a String.

		If `this` Unserializer instance contains no more or invalid data, an
		exception is thrown.

		This operation may fail on structurally valid data if a type cannot be
		resolved or if a field cannot be set. This can happen when unserializing
		Strings that were serialized on a different Haxe target, in which the
		serialization side has to make sure not to include platform-specific
		data.

		Classes are created from `Type.createEmptyInstance`, which means their
		constructors are not called.</haxe_doc>
		</unserialize>
		<new public="1" set="method" line="104">
			<f a="buf">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Unserializer instance, with its internal buffer
		initialized to `buf`.

		This does not parse `buf` immediately. It is parsed only when calls to
		`this.unserialize` are made.

		Each Unserializer instance maintains its own cache.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The `Unserializer` class is the complement to the `Serializer` class. It parses
	a serialization `String` and creates objects from the contained data.

	This class can be used in two ways:

	- create a `new Unserializer()` instance with a given serialization
		String, then call its `unserialize()` method until all values are
		extracted
	- call `Unserializer.run()`  to unserialize a single value from a given
		String

	The specification of the serialization format can be found here:
	<https://haxe.org/manual/serialization/format>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.Adler32" params="" file="E:\HaxeToolkit\haxe\std\haxe/crypto/Adler32.hx">
		<read public="1" set="method" line="60" static="1"><f a="i">
	<c path="haxe.io.Input"/>
	<c path="haxe.crypto.Adler32"/>
</f></read>
		<a1><x path="Int"/></a1>
		<a2><x path="Int"/></a2>
		<update public="1" set="method" line="41"><f a="b:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></update>
		<equals public="1" set="method" line="52"><f a="a">
	<c path="haxe.crypto.Adler32"/>
	<x path="Bool"/>
</f></equals>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Calculates the Adler32 of the given Bytes.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.Crc32" params="" file="E:\HaxeToolkit\haxe\std\haxe/crypto/Crc32.hx">
		<crc><x path="Int"/></crc>
		<byte public="1" set="method" line="35"><f a="b">
	<x path="Int"/>
	<x path="Void"/>
</f></byte>
		<update public="1" set="method" line="46"><f a="b:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></update>
		<get public="1" set="method" line="60"><f a=""><x path="Int"/></f></get>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Calculates the Crc32 of the given Bytes.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.Md5" params="" file="E:\HaxeToolkit\haxe\std\haxe/crypto/Md5.hx">
		<encode public="1" set="method" line="29" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<str2blks set="method" line="135" static="1"><f a="str">
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
</f></str2blks>
		<bitOR set="method" line="72"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitOR>
		<bitXOR set="method" line="78"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitXOR>
		<bitAND set="method" line="84"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bitAND>
		<addme set="method" line="90"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></addme>
		<hex set="method" line="96"><f a="a">
	<c path="Array"><x path="Int"/></c>
	<c path="String"/>
</f></hex>
		<rol set="method" line="168"><f a="num:cnt">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></rol>
		<cmn set="method" line="172"><f a="q:a:b:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></cmn>
		<ff set="method" line="176"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ff>
		<gg set="method" line="180"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gg>
		<hh set="method" line="184"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></hh>
		<ii set="method" line="188"><f a="a:b:c:d:x:s:t">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></ii>
		<doEncode set="method" line="192"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></doEncode>
		<new set="method" line="69"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Creates a MD5 of a String.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.Sha1" params="" file="E:\HaxeToolkit\haxe\std\haxe/crypto/Sha1.hx">
		<make public="1" set="method" line="35" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></make>
		<bytes2blks set="method" line="117" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="Array"><x path="Int"/></c>
</f></bytes2blks>
		<doEncode set="method" line="51"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></doEncode>
		<ft set="method" line="144">
			<f a="t:b:c:d">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Perform the appropriate triplet combination function for the current iteration</haxe_doc>
		</ft>
		<kt set="method" line="154">
			<f a="t">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Determine the appropriate additive constant for the current iteration</haxe_doc>
		</kt>
		<new set="method" line="48"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Creates a Sha1 of a String.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.ArraySort" params="" file="E:\HaxeToolkit\haxe\std\haxe/ds/ArraySort.hx">
		<sort public="1" params="T" set="method" line="43" static="1">
			<f a="a:cmp">
				<c path="Array"><c path="sort.T"/></c>
				<f a=":">
					<c path="sort.T"/>
					<c path="sort.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts Array `a` according to the comparison function `cmp`, where
		`cmp(x,y)` returns 0 if `x == y`, a positive Int if `x > y` and a
		negative Int if `x < y`.

		This operation modifies Array `a` in place.

		This operation is stable: The order of equal elements is preserved.

		If `a` or `cmp` are null, the result is unspecified.]]></haxe_doc>
		</sort>
		<rec params="T" set="method" line="47" static="1"><f a="a:cmp:from:to">
	<c path="Array"><c path="rec.T"/></c>
	<f a=":">
		<c path="rec.T"/>
		<c path="rec.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rec>
		<doMerge params="T" set="method" line="68" static="1"><f a="a:cmp:from:pivot:to:len1:len2">
	<c path="Array"><c path="doMerge.T"/></c>
	<f a=":">
		<c path="doMerge.T"/>
		<c path="doMerge.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></doMerge>
		<rotate params="T" set="method" line="94" static="1"><f a="a:cmp:from:mid:to">
	<c path="Array"><c path="rotate.T"/></c>
	<f a=":">
		<c path="rotate.T"/>
		<c path="rotate.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rotate>
		<gcd set="method" line="112" static="1"><f a="m:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gcd>
		<upper params="T" set="method" line="121" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="upper.T"/></c>
	<f a=":">
		<c path="upper.T"/>
		<c path="upper.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></upper>
		<lower params="T" set="method" line="136" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="lower.T"/></c>
	<f a=":">
		<c path="lower.T"/>
		<c path="lower.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lower>
		<swap params="T" set="method" line="150" static="1"><f a="a:i:j">
	<c path="Array"><c path="swap.T"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swap>
		<haxe_doc>ArraySort provides a stable implementation of merge sort through its `sort`
	method. It should be used instead of `Array.sort` in cases where the order
	of equal elements has to be retained on all targets.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="E:\HaxeToolkit\haxe\std\haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<haxe_doc>HashMap allows mapping of hashable objects to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.IntMap" params="T" file="E:\HaxeToolkit\haxe\std\haxe/ds/IntMap.hx" extern="1">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Null"><c path="haxe.ds.IntMap.T"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.IntMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<keyValueIterator public="1" set="method">
			<f a=""><t path="KeyValueIterator">
	<x path="Int"/>
	<c path="haxe.ds.IntMap.T"/>
</t></f>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method">
			<f a=""><c path="haxe.ds.IntMap"><c path="haxe.ds.IntMap.T"/></c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.ds.List" params="T" file="E:\HaxeToolkit\haxe\std\haxe/ds/List.hx">
		<h><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></h>
		<q><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<add public="1" set="method" line="53">
			<f a="item">
				<c path="haxe.ds.List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</add>
		<push public="1" set="method" line="68">
			<f a="item">
				<c path="haxe.ds.List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the beginning of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<first public="1" set="method" line="81">
			<f a=""><x path="Null"><c path="haxe.ds.List.T"/></x></f>
			<haxe_doc>Returns the first element of `this` List, or null if no elements exist.

		This function does not modify `this` List.</haxe_doc>
		</first>
		<pop public="1" set="method" line="100">
			<f a=""><x path="Null"><c path="haxe.ds.List.T"/></x></f>
			<haxe_doc>Returns the first element of `this` List, or null if no elements exist.

		The element is removed from `this` List.</haxe_doc>
		</pop>
		<clear public="1" set="method" line="124">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Empties `this` List.

		This function does not traverse the elements, but simply sets the
		internal references to null and `this.length` to 0.</haxe_doc>
		</clear>
		<remove public="1" set="method" line="138">
			<f a="v">
				<c path="haxe.ds.List.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `v` in `this` List.

		If `v` is found by checking standard equality, it is removed from `this`
		List and the function returns true.

		Otherwise, false is returned.</haxe_doc>
		</remove>
		<new public="1" set="method" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of element container objects
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole list content every time.

	@see https://haxe.org/manual/std-List.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds._List.ListNode" params="T" file="E:\HaxeToolkit\haxe\std\haxe/ds/List.hx" private="1" module="haxe.ds.List">
		<item public="1"><c path="haxe.ds._List.ListNode.T"/></item>
		<next public="1"><c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c></next>
		<new public="1" set="method" line="263"><f a="item:next">
	<c path="haxe.ds._List.ListNode.T"/>
	<c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.Map" params="K:V" file="E:\HaxeToolkit\haxe\std\haxe/ds/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="haxe.IMap">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `key1 => value1, key2 => value2` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta><m n=":multiType"><e>@:followWithAbstracts K</e></m></meta>
		<impl><class path="haxe.ds._Map.Map_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/ds/Map.hx" private="1" module="haxe.ds.Map"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.ObjectMap" params="K:V" file="E:\HaxeToolkit\haxe\std\haxe/ds/ObjectMap.hx" extern="1">
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Null"><c path="haxe.ds.ObjectMap.V"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<keyValueIterator public="1" set="method">
			<f a=""><t path="KeyValueIterator">
	<c path="haxe.ds.ObjectMap.K"/>
	<c path="haxe.ds.ObjectMap.V"/>
</t></f>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method">
			<f a=""><c path="haxe.ds.ObjectMap">
	<c path="haxe.ds.ObjectMap.K"/>
	<c path="haxe.ds.ObjectMap.V"/>
</c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.ds.StringMap" params="T" file="E:\HaxeToolkit\haxe\std\haxe/ds/StringMap.hx" extern="1">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Null"><c path="haxe.ds.StringMap.T"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<keyValueIterator public="1" set="method">
			<f a=""><t path="KeyValueIterator">
	<c path="String"/>
	<c path="haxe.ds.StringMap.T"/>
</t></f>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method">
			<f a=""><c path="haxe.ds.StringMap"><c path="haxe.ds.StringMap.T"/></c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="E:\HaxeToolkit\haxe\std\haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="Array"><c path="haxe.ds._Vector.VectorData.T"/></c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="E:\HaxeToolkit\haxe\std\haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.

	@see https://haxe.org/manual/std-vector.html</haxe_doc>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector">
	<length public="1" get="null" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the length of `this` Vector.</haxe_doc>
	</length>
	<blit public="1" params="T" set="method" line="149" static="1">
		<f a="src:srcPos:dest:destPos:len">
			<x path="haxe.ds.Vector"><c path="blit.T"/></x>
			<x path="Int"/>
			<x path="haxe.ds.Vector"><c path="blit.T"/></x>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Copies `length` of elements from `src` Vector, beginning at `srcPos` to
		`dest` Vector, beginning at `destPos`

		The results are unspecified if `length` results in out-of-bounds access,
		or if `src` or `dest` are null</haxe_doc>
	</blit>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.ds._Vector.Vector_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector">
		<length public="1" get="null" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns the length of `this` Vector.</haxe_doc>
		</length>
		<blit public="1" params="T" set="method" line="149" static="1">
			<f a="src:srcPos:dest:destPos:len">
				<x path="haxe.ds.Vector"><c path="blit.T"/></x>
				<x path="Int"/>
				<x path="haxe.ds.Vector"><c path="blit.T"/></x>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies `length` of elements from `src` Vector, beginning at `srcPos` to
		`dest` Vector, beginning at `destPos`

		The results are unspecified if `length` results in out-of-bounds access,
		or if `src` or `dest` are null</haxe_doc>
		</blit>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.format.JsonParser" params="" file="E:\HaxeToolkit\haxe\std\haxe/format/JsonParser.hx">
		<str><c path="String"/></str>
		<pos><x path="Int"/></pos>
		<doParse set="method" line="56"><f a=""><d/></f></doParse>
		<parseRec set="method" line="70"><f a=""><d/></f></parseRec>
		<parseString set="method" line="152"><f a=""><c path="String"/></f></parseString>
		<invalidChar set="method" line="264"><f a=""><x path="Void"/></f></invalidChar>
		<invalidNumber set="method" line="269"><f a="start">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidNumber>
		<new set="method" line="51"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An implementation of JSON parser in Haxe.

	This class is used by `haxe.Json` when native JSON implementation
	is not available.

	@see https://haxe.org/manual/std-Json-parsing.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.format.JsonPrinter" params="" file="E:\HaxeToolkit\haxe\std\haxe/format/JsonPrinter.hx">
		<print public="1" set="method" line="44" static="1">
			<f a="o:?replacer:?space">
				<d/>
				<f a="key:value">
					<d/>
					<d/>
					<d/>
				</f>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `o`'s value and returns the resulting JSON string.

		If `replacer` is given and is not null, it is used to retrieve
		actual object to be encoded. The `replacer` function takes two parameters,
		the key and the value being encoded. Initial key value is an empty string.

		If `space` is given and is not null, the result will be pretty-printed.
		Successive levels will be indented by this string.</haxe_doc>
		</print>
		<buf><c path="StringBuf"/></buf>
		<replacer><f a="key:value">
	<d/>
	<d/>
	<d/>
</f></replacer>
		<indent><c path="String"/></indent>
		<pretty><x path="Bool"/></pretty>
		<nind><x path="Int"/></nind>
		<write set="method" line="79"><f a="k:v">
	<d/>
	<d/>
	<x path="Void"/>
</f></write>
		<classString set="method" line="153"><f a="v">
	<d/>
	<x path="Void"/>
</f></classString>
		<fieldsString set="method" line="161"><f a="v:fields">
	<d/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></fieldsString>
		<quote set="method" line="187"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></quote>
		<new set="method" line="56"><f a="replacer:space">
	<f a="key:value">
		<d/>
		<d/>
		<d/>
	</f>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An implementation of JSON printer in Haxe.

	This class is used by `haxe.Json` when native JSON implementation
	is not available.

	@see https://haxe.org/manual/std-Json-encoding.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.ArrayBufferViewData" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/ArrayBufferView.hx" module="haxe.io.ArrayBufferView"><c path="haxe.io.ArrayBufferViewImpl"/></typedef>
	<class path="haxe.io.ArrayBufferViewImpl" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/ArrayBufferView.hx" module="haxe.io.ArrayBufferView">
		<bytes public="1"><c path="haxe.io.Bytes"/></bytes>
		<byteOffset public="1"><x path="Int"/></byteOffset>
		<byteLength public="1"><x path="Int"/></byteLength>
		<new public="1" set="method" line="30"><f a="bytes:pos:length">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="haxe.io.ArrayBufferView" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/ArrayBufferView.hx">
		<this><t path="haxe.io.ArrayBufferViewData"/></this>
		<impl><class path="haxe.io._ArrayBufferView.ArrayBufferView_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/ArrayBufferView.hx" private="1" module="haxe.io.ArrayBufferView">
	<buffer public="1" get="accessor" set="null" static="1">
		<c path="haxe.io.Bytes"/>
		<meta><m n=":impl"/></meta>
	</buffer>
	<byteOffset public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</byteOffset>
	<byteLength public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</byteLength>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.io.Bytes" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="471" static="1"><f a="length">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="500" static="1">
			<f a="s:?encoding">
				<c path="String"/>
				<e path="haxe.io.Encoding"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Returns bytes representation of the given String, using specific encoding (UTF-8 by default)</haxe_doc>
		</ofString>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<blit public="1" set="method" line="75"><f a="pos:src:srcpos:len">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blit>
		<fill public="1" set="method" line="108"><f a="pos:len:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fill>
		<sub public="1" set="method" line="127"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<getDouble public="1" set="method" line="203">
			<f a="pos">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the IEEE double precision value at given position (in low endian encoding).
		Result is unspecified if reading outside of the bounds</haxe_doc>
		</getDouble>
		<getFloat public="1" set="method" line="222">
			<f a="pos">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the IEEE single precision value at given position (in low endian encoding).
		Result is unspecified if reading outside of the bounds</haxe_doc>
		</getFloat>
		<setFloat public="1" set="method" line="264">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Store the IEEE single precision value at given position in low endian encoding.
		Result is unspecified if writing outside of the bounds.</haxe_doc>
		</setFloat>
		<getString public="1" set="method" line="349"><f a="pos:len:?encoding">
	<x path="Int"/>
	<x path="Int"/>
	<e path="haxe.io.Encoding"/>
	<c path="String"/>
</f></getString>
		<toString public="1" set="method" line="434">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns string representation of the bytes as UTF8</haxe_doc>
		</toString>
		<toHex public="1" set="method" line="453"><f a=""><c path="String"/></f></toHex>
		<new set="method" line="33"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/BytesBuffer.hx">
		<b><c path="Array"><x path="Int"/></c></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the buffer in bytes.</haxe_doc>
		</length>
		<addInt32 public="1" set="method" line="120"><f a="v">
	<x path="Int"/>
	<x path="Void"/>
</f></addInt32>
		<getBytes public="1" set="method" line="181">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer should no longer be used.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="43"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/BytesData.hx"><c path="Array"><x path="Int"/></c></typedef>
	<class path="haxe.io.Input" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Input.hx">
		<bigEndian public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Endianness (word byte order) used when reading numbers.

		If `true`, big-endian is used, otherwise `little-endian` is used.</haxe_doc>
		</bigEndian>
		<readByte public="1" set="method" line="49">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read and return one byte.</haxe_doc>
		</readByte>
		<readBytes public="1" set="method" line="64">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Returns the actual length of read data that can be smaller than `len`.

		See `readFullBytes` that tries to read the exact amount of specified bytes.</haxe_doc>
		</readBytes>
		<close public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the input source.

		Behaviour while reading after calling this method is unspecified.</haxe_doc>
		</close>
		<set_bigEndian set="method" line="95"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<readAll public="1" set="method" line="108">
			<f a="?bufsize">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Read and return all available data.

		The `bufsize` optional argument specifies the size of chunks by
		which data is read. Its default value is target-specific.</haxe_doc>
		</readAll>
		<readFullBytes public="1" set="method" line="134">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Unlike `readBytes`, this method tries to read the exact `len` amount of bytes.</haxe_doc>
		</readFullBytes>
		<read public="1" set="method" line="147">
			<f a="nbytes">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Read and return `nbytes` bytes.</haxe_doc>
		</read>
		<readUntil public="1" set="method" line="164">
			<f a="end">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Read a string until a character code specified by `end` is occurred.

		The final character is not included in the resulting string.</haxe_doc>
		</readUntil>
		<readFloat public="1" set="method" line="199">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Read a 32-bit floating point number.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readFloat>
		<readInt16 public="1" set="method" line="229">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 16-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readInt16>
		<readUInt16 public="1" set="method" line="243">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 16-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readUInt16>
		<readUInt24 public="1" set="method" line="269">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 24-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readUInt24>
		<readInt32 public="1" set="method" line="281">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 32-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readInt32>
		<readString public="1" set="method" line="303">
			<f a="len:?encoding">
				<x path="Int"/>
				<e path="haxe.io.Encoding"/>
				<c path="String"/>
			</f>
			<haxe_doc>Read and `len` bytes as a string.</haxe_doc>
		</readString>
		<haxe_doc>An Input is an abstract reader. See other classes in the `haxe.io` package
	for several possible implementations.

	All functions which read data throw `Eof` when the end of the stream
	is reached.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.BytesInput" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<b><t path="haxe.io.BytesData"/></b>
		<pos><x path="Int"/></pos>
		<len><x path="Int"/></len>
		<totlen><x path="Int"/></totlen>
		<position public="1" get="null" set="accessor">
			<x path="Int"/>
			<haxe_doc>The current position in the stream in bytes.</haxe_doc>
		</position>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<set_position set="method" line="79"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></set_position>
		<readByte public="1" set="method" line="90" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="109" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="38"><f a="b:?pos:?len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Output" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Output.hx">
		<bigEndian public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Endianness (word byte order) used when writing numbers.

		If `true`, big-endian is used, otherwise `little-endian` is used.</haxe_doc>
		</bigEndian>
		<writeByte public="1" set="method" line="46">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write one byte.</haxe_doc>
		</writeByte>
		<writeBytes public="1" set="method" line="57">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Returns the actual length of written data that can differ from `len`.

		See `writeFullBytes` that tries to write the exact amount of specified bytes.</haxe_doc>
		</writeBytes>
		<flush public="1" set="method" line="85">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Flush any buffered data.</haxe_doc>
		</flush>
		<close public="1" set="method" line="93">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the output.

		Behaviour while writing after calling this method is unspecified.</haxe_doc>
		</close>
		<set_bigEndian set="method" line="96"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<write public="1" set="method" line="106">
			<f a="s">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write all bytes stored in `s`.</haxe_doc>
		</write>
		<writeFullBytes public="1" set="method" line="122">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Unlike `writeBytes`, this method tries to write the exact `len` amount of bytes.</haxe_doc>
		</writeFullBytes>
		<writeFloat public="1" set="method" line="135">
			<f a="x">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 32-bit floating point number.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeFloat>
		<writeInt16 public="1" set="method" line="169">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 16-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeInt16>
		<writeUInt16 public="1" set="method" line="179">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 16-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeUInt16>
		<writeInt32 public="1" set="method" line="223">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 32-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeInt32>
		<writeString public="1" set="method" line="278">
			<f a="s:?encoding">
				<c path="String"/>
				<e path="haxe.io.Encoding"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `s` string.</haxe_doc>
		</writeString>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the `writeByte` and maybe the `write`, `flush` and `close`
	methods. See `File.write` and `String.write` for two ways of creating an
	Output.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.BytesOutput" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/BytesOutput.hx">
		<extends path="haxe.io.Output"/>
		<b><c path="haxe.io.BytesBuffer"/></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<writeByte public="1" set="method" line="51" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="59" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<getBytes public="1" set="method" line="134">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns the `Bytes` of this output.

		This function should not be called more than once on a given
		`BytesOutput` instance.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="35"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.io.Encoding" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Encoding.hx">
		<UTF8/>
		<RawNative><haxe_doc>Output the string the way the platform represent it in memory. This is the most efficient but is platform-specific</haxe_doc></RawNative>
		<haxe_doc>String binary encoding supported by Haxe I/O</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="haxe.io.Eof" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Eof.hx">
		<toString set="method" line="32">
			<f a=""><c path="String"/></f>
			<meta><m n=":ifFeature"><e>"haxe.io.Eof.*"</e></m></meta>
		</toString>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the `haxe.io.Input`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.io.Error" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="haxe.io.FPHelper" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/FPHelper.hx">
		<i32ToFloat public="1" set="method" line="134" static="1"><f a="i">
	<x path="Int"/>
	<x path="Float"/>
</f></i32ToFloat>
		<floatToI32 public="1" set="method" line="177" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></floatToI32>
		<i64ToDouble public="1" set="method" line="213" static="1"><f a="low:high">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></i64ToDouble>
		<haxe_doc>Helper that converts between floating point and binary representation.
	Always works in low-endian encoding.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.Float32ArrayData" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Float32Array.hx" module="haxe.io.Float32Array"><t path="haxe.io.ArrayBufferViewData"/></typedef>
	<abstract path="haxe.io.Float32Array" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Float32Array.hx">
		<this><t path="haxe.io.Float32ArrayData"/></this>
		<impl><class path="haxe.io._Float32Array.Float32Array_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Float32Array.hx" private="1" module="haxe.io.Float32Array">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<view public="1" get="accessor" set="null" static="1">
		<x path="haxe.io.ArrayBufferView"/>
		<meta><m n=":impl"/></meta>
	</view>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.io.Path" params="" file="E:\HaxeToolkit\haxe\std\haxe/io/Path.hx">
		<withoutDirectory public="1" set="method" line="134" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String representation of `path` without the directory.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</withoutDirectory>
		<directory public="1" set="method" line="147" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the directory of `path`.

		If the directory is `null`, the empty String `""` is returned.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</directory>
		<withExtension public="1" set="method" line="175" static="1">
			<f a="path:ext">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a String representation of `path` where the extension is `ext`.

		If `path` has no extension, `ext` is added as extension.

		If `path` or `ext` are `null`, the result is unspecified.</haxe_doc>
		</withExtension>
		<join public="1" set="method" line="189" static="1">
			<f a="paths">
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all paths in `paths` together.

		If `paths` is empty, the empty String `""` is returned. Otherwise the
		paths are joined with a slash between them.

		If `paths` is `null`, the result is unspecified.</haxe_doc>
		</join>
		<normalize public="1" set="method" line="210" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Normalize a given `path` (e.g. turn `'/usr/local/../lib'` into `'/usr/lib'`).

		Also replaces backslashes `\` with slashes `/` and afterwards turns
		multiple slashes into a single one.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</normalize>
		<addTrailingSlash public="1" set="method" line="264" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Adds a trailing slash to `path`, if it does not have one already.

		If the last slash in `path` is a backslash, a backslash is appended to
		`path`.

		If the last slash in `path` is a slash, or if no slash is found, a slash
		is appended to `path`. In particular, this applies to the empty String
		`""`.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</addTrailingSlash>
		<isAbsolute public="1" set="method" line="303" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":require"><e><![CDATA[haxe_ver >= 3.2]]></e></m></meta>
			<haxe_doc>Returns `true` if the path is an absolute path, and `false` otherwise.</haxe_doc>
		</isAbsolute>
		<dir public="1">
			<c path="String"/>
			<haxe_doc>The directory.

		This is the leading part of the path that is not part of the file name
		and the extension.

		Does not end with a `/` or `\` separator.

		If the path has no directory, the value is `null`.</haxe_doc>
		</dir>
		<file public="1">
			<c path="String"/>
			<haxe_doc>The file name.

		This is the part of the part between the directory and the extension.

		If there is no file name, e.g. for `".htaccess"` or `"/dir/"`, the value
		is the empty String `""`.</haxe_doc>
		</file>
		<ext public="1">
			<c path="String"/>
			<haxe_doc>The file extension.

		It is separated from the file name by a dot. This dot is not part of
		the extension.

		If the path has no extension, the value is `null`.</haxe_doc>
		</ext>
		<backslash public="1">
			<x path="Bool"/>
			<haxe_doc>`true` if the last directory separator is a backslash, `false` otherwise.</haxe_doc>
		</backslash>
		<toString public="1" set="method" line="114">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of `this` path.

		If `this.backslash` is `true`, backslash is used as directory separator,
		otherwise slash is used. This only affects the separator between
		`this.dir` and `this.file`.

		If `this.directory` or `this.extension` is `null`, their representation
		is the empty String `""`.</haxe_doc>
		</toString>
		<new public="1" set="method" line="76">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new `Path` instance by parsing `path`.

		Path information can be retrieved by accessing the `dir`, `file` and `ext`
		properties.</haxe_doc>
		</new>
		<haxe_doc>This class provides a convenient way of working with paths. It supports the
	common path formats:

	- `directory1/directory2/filename.extension`
	- `directory1\directory2\filename.extension`</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.macro.Position" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<min>
				<x path="Int"/>
				<haxe_doc>Position of the first character.</haxe_doc>
			</min>
			<max>
				<x path="Int"/>
				<haxe_doc>Position of the last character.</haxe_doc>
			</max>
			<file>
				<c path="String"/>
				<haxe_doc>Reference to the filename.</haxe_doc>
			</file>
		</a>
		<haxe_doc>Represents a position in a file.</haxe_doc>
	</typedef>
	<enum path="haxe.macro.Binop" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpAdd><haxe_doc>`+`</haxe_doc></OpAdd>
		<OpMult><haxe_doc>`*`</haxe_doc></OpMult>
		<OpDiv><haxe_doc>`/`</haxe_doc></OpDiv>
		<OpSub><haxe_doc>`-`</haxe_doc></OpSub>
		<OpAssign><haxe_doc>`=`</haxe_doc></OpAssign>
		<OpEq><haxe_doc>`==`</haxe_doc></OpEq>
		<OpNotEq><haxe_doc>`!=`</haxe_doc></OpNotEq>
		<OpGt><haxe_doc><![CDATA[`>`]]></haxe_doc></OpGt>
		<OpGte><haxe_doc><![CDATA[`>=`]]></haxe_doc></OpGte>
		<OpLt><haxe_doc><![CDATA[`<`]]></haxe_doc></OpLt>
		<OpLte><haxe_doc><![CDATA[`<=`]]></haxe_doc></OpLte>
		<OpAnd><haxe_doc><![CDATA[`&`]]></haxe_doc></OpAnd>
		<OpOr><haxe_doc>`|`</haxe_doc></OpOr>
		<OpXor><haxe_doc>`^`</haxe_doc></OpXor>
		<OpBoolAnd><haxe_doc><![CDATA[`&&`]]></haxe_doc></OpBoolAnd>
		<OpBoolOr><haxe_doc>`||`</haxe_doc></OpBoolOr>
		<OpShl><haxe_doc><![CDATA[`<<`]]></haxe_doc></OpShl>
		<OpShr><haxe_doc><![CDATA[`>>`]]></haxe_doc></OpShr>
		<OpUShr><haxe_doc><![CDATA[`>>>`]]></haxe_doc></OpUShr>
		<OpMod><haxe_doc>`%`</haxe_doc></OpMod>
		<OpAssignOp a="op">
			<e path="haxe.macro.Binop"/>
			<haxe_doc><![CDATA[`+=`
		`-=`
		`/=`
		`*=`
		`<<=`
		`>>=`
		`>>>=`
		`|=`
		`&=`
		`^=`
		`%=`]]></haxe_doc>
		</OpAssignOp>
		<OpInterval><haxe_doc>`...`</haxe_doc></OpInterval>
		<OpArrow><haxe_doc><![CDATA[`=>`]]></haxe_doc></OpArrow>
		<OpIn><haxe_doc>`in`</haxe_doc></OpIn>
		<haxe_doc>A binary operator.
	@see https://haxe.org/manual/types-numeric-operators.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="haxe.macro.Unop" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpIncrement><haxe_doc>`++`</haxe_doc></OpIncrement>
		<OpDecrement><haxe_doc>`--`</haxe_doc></OpDecrement>
		<OpNot><haxe_doc>`!`</haxe_doc></OpNot>
		<OpNeg><haxe_doc>`-`</haxe_doc></OpNeg>
		<OpNegBits><haxe_doc>`~`</haxe_doc></OpNegBits>
		<haxe_doc>A unary operator.
	@see https://haxe.org/manual/types-numeric-operators.html</haxe_doc>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<typedef path="haxe.macro.Expr" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the expression.</haxe_doc>
			</pos>
			<expr>
				<e path="haxe.macro.ExprDef"/>
				<haxe_doc>The expression kind.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a node in the AST.
	@see https://haxe.org/manual/macro-reification-expression.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<t path="haxe.macro.Expr"/>
		<haxe_doc>Represents a AST node identical to `Expr`, but it allows constraining the
	type of accepted expressions.
	@see https://haxe.org/manual/macro-ExprOf.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Case" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<values>
				<c path="Array"><t path="haxe.macro.Expr"/></c>
				<haxe_doc>The value expressions of the case.</haxe_doc>
			</values>
			<guard>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional guard expressions of the case, if available.</haxe_doc>
			</guard>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<haxe_doc>The expression of the case, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a switch case.
	@see https://haxe.org/manual/expression-switch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Var" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<haxe_doc>The type-hint of the variable, if available.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<isFinal>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the variable can be assigned to.</haxe_doc>
			</isFinal>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<haxe_doc>The expression of the variable, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a variable in the AST.
	@see https://haxe.org/manual/expression-var.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Catch" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<e path="haxe.macro.ComplexType"/>
				<haxe_doc>The type of the catch.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the catch variable.</haxe_doc>
			</name>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The expression of the catch.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a catch in the AST.
	@https://haxe.org/manual/expression-try-catch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ObjectField" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<quotes>
				<x path="Null"><e path="haxe.macro.QuoteStatus"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>How the field name is quoted.</haxe_doc>
			</quotes>
			<field>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</field>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The field expression.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents the field of an object declaration.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypePath" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<sub>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sub is set on module sub-type access:
		`pack.Module.Type` has name = Module, sub = Type, if available.</haxe_doc>
			</sub>
			<params>
				<x path="Null"><c path="Array"><e path="haxe.macro.TypeParam"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional parameters of the type path.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>Represents the package of the type path.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type path.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a type path in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeParamDecl" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the type parameter.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type parameter.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the type parameter.</haxe_doc>
			</meta>
			<constraints>
				<x path="Null"><c path="Array"><e path="haxe.macro.ComplexType"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional constraints of the type parameter.</haxe_doc>
			</constraints>
		</a>
		<haxe_doc>Represents a type parameter declaration in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Function" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<ret>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<haxe_doc>The return type-hint of the function, if available.</haxe_doc>
			</ret>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional list of function parameter type declarations.</haxe_doc>
			</params>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<haxe_doc>The expression of the function body, if available.</haxe_doc>
			</expr>
			<args>
				<c path="Array"><t path="haxe.macro.FunctionArg"/></c>
				<haxe_doc>A list of function arguments.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Represents a function in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<value>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional value of the function argument, if available.</haxe_doc>
			</value>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<haxe_doc>The type-hint of the function argument, if available.</haxe_doc>
			</type>
			<opt>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the function argument is optional.</haxe_doc>
			</opt>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the function argument.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the function argument.</haxe_doc>
			</meta>
		</a>
		<haxe_doc>Represents a function argument in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.MetadataEntry" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the metadata entry.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.Expr"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the metadata entry.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the metadata entry.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a metadata entry in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Metadata" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
		<haxe_doc>Represents metadata in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Field" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the field.</haxe_doc>
			</pos>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the field.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.FieldType"/>
				<haxe_doc>The kind of the field.</haxe_doc>
			</kind>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the field, if available. If the field has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
			<access>
				<x path="Null"><c path="Array"><e path="haxe.macro.Access"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The access modifiers of the field. By default fields have private access.
		@see https://haxe.org/manual/class-field-access-modifier.html</haxe_doc>
			</access>
		</a>
		<haxe_doc>Represents a field in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeDefinition" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position to the type definition.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The parameter type declarations of the type definition.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type definition.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type definition.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the type definition.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.TypeDefKind"/>
				<haxe_doc>The kind of the type definition.</haxe_doc>
			</kind>
			<isExtern>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<fields>
				<c path="Array"><t path="haxe.macro.Field"/></c>
				<haxe_doc>The fields of the type definition.</haxe_doc>
			</fields>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the type, if available. If the type has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a type definition.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ImportExpr" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<path>
				<c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
</a></c>
				<haxe_doc>The path to the import expression.</haxe_doc>
			</path>
			<mode>
				<e path="haxe.macro.ImportMode"/>
				<haxe_doc>The mode of the import expression.</haxe_doc>
			</mode>
		</a>
		<haxe_doc>Represents the import expression.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Ref" params="T" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<toString set="method"><f a=""><c path="String"/></f></toString>
			<get set="method"><f a=""><c path="haxe.macro.Ref.T"/></f></get>
		</a>
		<haxe_doc>Represents a reference to internal compiler structure. It exists to avoid
	expensive encoding if it is not required and to ensure that physical
	equality remains intact.

	A structure is only encoded when user requests it through `ref.get()`.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.AnonType" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<status>
				<e path="haxe.macro.AnonStatus"/>
				<haxe_doc>The status/kind of the structure.</haxe_doc>
			</status>
			<fields>
				<c path="Array"><t path="haxe.macro.ClassField"/></c>
				<haxe_doc>The class fields of the structure.</haxe_doc>
			</fields>
		</a>
		<haxe_doc>Represents information for anonymous structure types.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeParameter" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the type parameter. It is guaranteed to be a `TInst` with a
		`KTypeParameter` kind.</haxe_doc>
			</t>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type parameter.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents the declaration of type parameters.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ClassField" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the class field.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the class field.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the class field.</haxe_doc>
			</params>
			<overloads>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The overload fields of the class field.</haxe_doc>
			</overloads>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the class field.</haxe_doc>
			</name>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the class field.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.FieldKind"/>
				<haxe_doc>The class field kind.</haxe_doc>
			</kind>
			<isPublic>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is public.</haxe_doc>
			</isPublic>
			<isFinal>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is final.</haxe_doc>
			</isFinal>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is extern.</haxe_doc>
			</isExtern>
			<expr set="method">
				<f a=""><x path="Null"><t path="haxe.macro.TypedExpr"/></x></f>
				<haxe_doc>Returns the typed expression of the class field.</haxe_doc>
			</expr>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a class field.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.EnumField" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the enum constructor.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the enum constructor.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the enum constructor.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the enum constructor.</haxe_doc>
			</name>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the enum constructor.</haxe_doc>
			</meta>
			<index>
				<x path="Int"/>
				<haxe_doc>The index of the enum constructor, i.e. in which position it appears
		in the syntax.</haxe_doc>
			</index>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the enum constructor.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents an enum constructor.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.BaseType" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>The information that all types (`ClassType`, `EnumType`, `DefType`,
	`AbstractType`) have in common.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ClassType" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<superClass>
				<x path="Null"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></x>
				<haxe_doc>The parent class and its type parameters, if available.</haxe_doc>
			</superClass>
			<statics>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The static fields of the class.</haxe_doc>
			</statics>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<overrides>
				<c path="Array"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></c>
				<haxe_doc>The list of fields that have override status.</haxe_doc>
			</overrides>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.ClassKind"/>
				<haxe_doc>The kind of the class.</haxe_doc>
			</kind>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isInterface>
				<x path="Bool"/>
				<haxe_doc>If true the type is an interface, otherwise it is a class.</haxe_doc>
			</isInterface>
			<isFinal>
				<x path="Bool"/>
				<haxe_doc>If true the class is final and cannot be extended.</haxe_doc>
			</isFinal>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<interfaces>
				<c path="Array"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></c>
				<haxe_doc>The implemented interfaces and their type parameters.</haxe_doc>
			</interfaces>
			<init>
				<x path="Null"><t path="haxe.macro.TypedExpr"/></x>
				<haxe_doc>The `__init__` expression of the class, if available.</haxe_doc>
			</init>
			<fields>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The member fields of the class.</haxe_doc>
			</fields>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<constructor>
				<x path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></x>
				<haxe_doc>The constructor of the class, if available.</haxe_doc>
			</constructor>
		</a>
		<haxe_doc>Represents a class type.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.EnumType" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<names>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>An ordered list of enum constructor names.</haxe_doc>
			</names>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<constructs>
				<t path="Map">
					<c path="String"/>
					<t path="haxe.macro.EnumField"/>
				</t>
				<haxe_doc>The available enum constructors.</haxe_doc>
			</constructs>
		</a>
		<haxe_doc>Represents an enum type.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.DefType" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The target type of the typedef.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a typedef.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.AbstractType" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<unops>
				<c path="Array"><a>
	<postFix><x path="Bool"/></postFix>
	<op><e path="haxe.macro.Unop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c>
				<haxe_doc>The defined unary operators of the abstract.</haxe_doc>
			</unops>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The underlying type of the abstract.</haxe_doc>
			</type>
			<to>
				<c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><x path="Null"><t path="haxe.macro.ClassField"/></x></field>
</a></c>
				<haxe_doc>The available implicit to-casts of the abstract.

		@see https://haxe.org/manual/types-abstract-implicit-casts.html</haxe_doc>
			</to>
			<resolveWrite>
				<x path="Null"><t path="haxe.macro.ClassField"/></x>
				<meta><m n=":require"><e><![CDATA[haxe_ver >= 4.0]]></e></m></meta>
				<haxe_doc>The method used for resolving unknown field access, if available.</haxe_doc>
			</resolveWrite>
			<resolve>
				<x path="Null"><t path="haxe.macro.ClassField"/></x>
				<meta><m n=":require"><e><![CDATA[haxe_ver >= 3.3]]></e></m></meta>
				<haxe_doc>The method used for resolving unknown field access, if available.</haxe_doc>
			</resolve>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<impl>
				<x path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></x>
				<haxe_doc>The implementation class of the abstract, if available.</haxe_doc>
			</impl>
			<from>
				<c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><x path="Null"><t path="haxe.macro.ClassField"/></x></field>
</a></c>
				<haxe_doc>The available implicit from-casts of the abstract.

		@see https://haxe.org/manual/types-abstract-implicit-casts.html</haxe_doc>
			</from>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<binops>
				<c path="Array"><a>
	<op><e path="haxe.macro.Binop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c>
				<haxe_doc>The defined binary operators of the abstract.</haxe_doc>
			</binops>
			<array>
				<c path="Array"><t path="haxe.macro.ClassField"/></c>
				<haxe_doc>The defined array-access fields of the abstract.</haxe_doc>
			</array>
		</a>
		<haxe_doc>Represents an abstract type.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.MetaAccess" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<remove set="method">
				<f a="name">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Removes all `name` metadata entries from the origin of `this`
		MetaAccess.

		This method might clear several metadata entries of the same name.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `remove` has no effect on that array.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</remove>
			<has set="method">
				<f a="name">
					<c path="String"/>
					<x path="Bool"/>
				</f>
				<haxe_doc>Tells if the origin of `this` MetaAccess has a `name` metadata entry.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</has>
			<get set="method">
				<f a=""><t path="haxe.macro.Metadata"/></f>
				<haxe_doc>Return the wrapped `Metadata` array.

		Modifying this array has no effect on the origin of `this` MetaAccess.
		The `add` and `remove` methods can be used for that.</haxe_doc>
			</get>
			<extract set="method">
				<f a="name">
					<c path="String"/>
					<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
				</f>
				<haxe_doc>Extract metadata entries by given `name`.

		If there's no metadata with such name, empty array `[]` is returned.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</extract>
			<add set="method">
				<f a="name:params:pos">
					<c path="String"/>
					<c path="Array"><t path="haxe.macro.Expr"/></c>
					<t path="haxe.macro.Position"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Adds the metadata specified by `name`, `params` and `pos` to the origin
		of `this` MetaAccess.

		Metadata names are not unique during compilation, so this method never
		overwrites a previous metadata.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `add` has no effect on that array.

		If any argument is null, compilation fails with an error.</haxe_doc>
			</add>
		</a>
		<haxe_doc>MetaAccess is a wrapper for the `Metadata` array. It can be used to add
	metadata to and remove metadata from its origin.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TVar" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t set="null">
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the variable.</haxe_doc>
			</t>
			<name set="null">
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<meta set="null">
				<x path="Null"><t path="haxe.macro.MetaAccess"/></x>
				<haxe_doc>The metadata of the variable.</haxe_doc>
			</meta>
			<id set="null">
				<x path="Int"/>
				<haxe_doc>The unique ID of the variable.</haxe_doc>
			</id>
			<extra set="null">
				<x path="Null"><a>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<expr><x path="Null"><t path="haxe.macro.TypedExpr"/></x></expr>
</a></x>
				<haxe_doc>Special information which is internally used to keep track of closure.
		information</haxe_doc>
			</extra>
			<capture set="null">
				<x path="Bool"/>
				<haxe_doc>Whether or not the variable has been captured by a closure.</haxe_doc>
			</capture>
		</a>
		<haxe_doc>Represents a variable in the typed AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TFunc" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The return type of the function.</haxe_doc>
			</t>
			<expr>
				<t path="haxe.macro.TypedExpr"/>
				<haxe_doc>The expression of the function body.</haxe_doc>
			</expr>
			<args>
				<c path="Array"><a>
	<value><x path="Null"><t path="haxe.macro.TypedExpr"/></x></value>
	<v><t path="haxe.macro.TVar"/></v>
</a></c>
				<haxe_doc>A list of function arguments identified by an argument variable `v` and
		an optional initialization `value`.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Represents a function in the typed AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypedExpr" params="" file="E:\HaxeToolkit\haxe\std\haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the expression.</haxe_doc>
			</t>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the expression.</haxe_doc>
			</pos>
			<expr>
				<e path="haxe.macro.TypedExprDef"/>
				<haxe_doc>The expression kind.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a typed AST node.</haxe_doc>
	</typedef>
	<abstract path="haxe.xml._Access.NodeAccess" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.NodeAccess_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
	<resolve public="1" set="method" line="27" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<x path="haxe.xml.Access"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>a.b</e></m>
		</meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.NodeAccess_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<resolve public="1" set="method" line="27" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<x path="haxe.xml.Access"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>a.b</e></m>
			</meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.AttribAccess" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.AttribAccess_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
	<resolve public="1" set="method" line="41" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>a.b</e></m>
		</meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.AttribAccess_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<resolve public="1" set="method" line="41" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>a.b</e></m>
			</meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.HasAttribAccess" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.HasAttribAccess_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.xml._Access.HasNodeAccess" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.HasNodeAccess_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
	<resolve public="1" set="method" line="74" static="1">
		<f a="this:name">
			<c path="Xml"/>
			<c path="String"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e>a.b</e></m>
		</meta>
	</resolve>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.HasNodeAccess_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<resolve public="1" set="method" line="74" static="1">
			<f a="this:name">
				<c path="Xml"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e>a.b</e></m>
			</meta>
		</resolve>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.NodeListAccess" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.NodeListAccess_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.xml.Access" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx">
		<this><c path="Xml"/></this>
		<haxe_doc>The `haxe.xml.Access` API helps providing a fast dot-syntax access to the
	most common `Xml` methods.</haxe_doc>
		<impl><class path="haxe.xml._Access.Access_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
	<x public="1" get="null" set="null" static="1">
		<c path="Xml"/>
		<meta><m n=":impl"/></meta>
	</x>
	<name public="1" get="null" set="null" static="1">
		<c path="String"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The name of the current element. This is the same as `Xml.nodeName`.</haxe_doc>
	</name>
	<innerData public="1" get="accessor" set="null" static="1">
		<c path="String"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The inner PCDATA or CDATA of the node.

		An exception is thrown if there is no data or if there not only data
		but also other nodes.</haxe_doc>
	</innerData>
	<innerHTML public="1" get="null" set="null" static="1">
		<c path="String"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The XML string built with all the sub nodes, excluding the current one.</haxe_doc>
	</innerHTML>
	<node public="1" get="null" set="null" static="1">
		<x path="haxe.xml._Access.NodeAccess"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc><![CDATA[Access to the first sub element with the given name.

		An exception is thrown if the element doesn't exists.
		Use `hasNode` to check the existence of a node.

		```haxe
		var access = new haxe.xml.Access(Xml.parse("<user><name>John</name></user>"));
		var user = access.node.user;
		var name = user.node.name;
		trace(name.innerData); // John

		// Uncaught Error: Document is missing element password
		var password = user.node.password;
		```]]></haxe_doc>
	</node>
	<nodes public="1" get="null" set="null" static="1">
		<x path="haxe.xml._Access.NodeListAccess"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc><![CDATA[Access to the List of elements with the given name.
		```haxe
		var fast = new haxe.xml.Access(Xml.parse("
			<users>
				<user name='John'/>
				<user name='Andy'/>
				<user name='Dan'/>
			</users>"
		));

		var users = fast.node.users;
		for (user in users.nodes.user) {
			trace(user.att.name);
		}
		```]]></haxe_doc>
	</nodes>
	<att public="1" get="null" set="null" static="1">
		<x path="haxe.xml._Access.AttribAccess"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc><![CDATA[Access to a given attribute.

		An exception is thrown if the attribute doesn't exists.
		Use `has` to check the existence of an attribute.

		```haxe
		var f = new haxe.xml.Access(Xml.parse("<user name='Mark'></user>"));
		var user = f.node.user;
		if (user.has.name) {
			trace(user.att.name); // Mark
		}
		```]]></haxe_doc>
	</att>
	<has public="1" get="null" set="null" static="1">
		<x path="haxe.xml._Access.HasAttribAccess"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Check the existence of an attribute with the given name.</haxe_doc>
	</has>
	<hasNode public="1" get="null" set="null" static="1">
		<x path="haxe.xml._Access.HasNodeAccess"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc><![CDATA[Check the existence of a sub node with the given name.

		```haxe
		var f = new haxe.xml.Access(Xml.parse("<user><age>31</age></user>"));
		var user = f.node.user;
		if (user.hasNode.age) {
			trace(user.node.age.innerData); // 31
		}
		```]]></haxe_doc>
	</hasNode>
	<elements public="1" get="null" set="null" static="1">
		<t path="Iterator"><x path="haxe.xml.Access"/></t>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The list of all sub-elements which are the nodes with type `Xml.Element`.</haxe_doc>
	</elements>
	<get_innerData set="method" line="209" static="1">
		<f a="this">
			<c path="Xml"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_innerData>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.xml._Access.Access_Impl_" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<x public="1" get="null" set="null" static="1">
			<c path="Xml"/>
			<meta><m n=":impl"/></meta>
		</x>
		<name public="1" get="null" set="null" static="1">
			<c path="String"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The name of the current element. This is the same as `Xml.nodeName`.</haxe_doc>
		</name>
		<innerData public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The inner PCDATA or CDATA of the node.

		An exception is thrown if there is no data or if there not only data
		but also other nodes.</haxe_doc>
		</innerData>
		<innerHTML public="1" get="null" set="null" static="1">
			<c path="String"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The XML string built with all the sub nodes, excluding the current one.</haxe_doc>
		</innerHTML>
		<node public="1" get="null" set="null" static="1">
			<x path="haxe.xml._Access.NodeAccess"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc><![CDATA[Access to the first sub element with the given name.

		An exception is thrown if the element doesn't exists.
		Use `hasNode` to check the existence of a node.

		```haxe
		var access = new haxe.xml.Access(Xml.parse("<user><name>John</name></user>"));
		var user = access.node.user;
		var name = user.node.name;
		trace(name.innerData); // John

		// Uncaught Error: Document is missing element password
		var password = user.node.password;
		```]]></haxe_doc>
		</node>
		<nodes public="1" get="null" set="null" static="1">
			<x path="haxe.xml._Access.NodeListAccess"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc><![CDATA[Access to the List of elements with the given name.
		```haxe
		var fast = new haxe.xml.Access(Xml.parse("
			<users>
				<user name='John'/>
				<user name='Andy'/>
				<user name='Dan'/>
			</users>"
		));

		var users = fast.node.users;
		for (user in users.nodes.user) {
			trace(user.att.name);
		}
		```]]></haxe_doc>
		</nodes>
		<att public="1" get="null" set="null" static="1">
			<x path="haxe.xml._Access.AttribAccess"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc><![CDATA[Access to a given attribute.

		An exception is thrown if the attribute doesn't exists.
		Use `has` to check the existence of an attribute.

		```haxe
		var f = new haxe.xml.Access(Xml.parse("<user name='Mark'></user>"));
		var user = f.node.user;
		if (user.has.name) {
			trace(user.att.name); // Mark
		}
		```]]></haxe_doc>
		</att>
		<has public="1" get="null" set="null" static="1">
			<x path="haxe.xml._Access.HasAttribAccess"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Check the existence of an attribute with the given name.</haxe_doc>
		</has>
		<hasNode public="1" get="null" set="null" static="1">
			<x path="haxe.xml._Access.HasNodeAccess"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc><![CDATA[Check the existence of a sub node with the given name.

		```haxe
		var f = new haxe.xml.Access(Xml.parse("<user><age>31</age></user>"));
		var user = f.node.user;
		if (user.hasNode.age) {
			trace(user.node.age.innerData); // 31
		}
		```]]></haxe_doc>
		</hasNode>
		<elements public="1" get="null" set="null" static="1">
			<t path="Iterator"><x path="haxe.xml.Access"/></t>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The list of all sub-elements which are the nodes with type `Xml.Element`.</haxe_doc>
		</elements>
		<get_innerData set="method" line="209" static="1">
			<f a="this">
				<c path="Xml"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_innerData>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.xml._Parser.S" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser" extern="1">
		<IGNORE_SPACES public="1" get="inline" set="null" expr="0" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</IGNORE_SPACES>
		<BEGIN public="1" get="inline" set="null" expr="1" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BEGIN>
		<BEGIN_NODE public="1" get="inline" set="null" expr="2" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</BEGIN_NODE>
		<TAG_NAME public="1" get="inline" set="null" expr="3" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</TAG_NAME>
		<BODY public="1" get="inline" set="null" expr="4" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BODY>
		<ATTRIB_NAME public="1" get="inline" set="null" expr="5" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</ATTRIB_NAME>
		<EQUALS public="1" get="inline" set="null" expr="6" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</EQUALS>
		<ATTVAL_BEGIN public="1" get="inline" set="null" expr="7" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</ATTVAL_BEGIN>
		<ATTRIB_VAL public="1" get="inline" set="null" expr="8" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</ATTRIB_VAL>
		<CHILDS public="1" get="inline" set="null" expr="9" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</CHILDS>
		<CLOSE public="1" get="inline" set="null" expr="10" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</CLOSE>
		<WAIT_END public="1" get="inline" set="null" expr="11" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</WAIT_END>
		<WAIT_END_RET public="1" get="inline" set="null" expr="12" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</WAIT_END_RET>
		<PCDATA public="1" get="inline" set="null" expr="13" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</PCDATA>
		<HEADER public="1" get="inline" set="null" expr="14" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14</e></m></meta>
		</HEADER>
		<COMMENT public="1" get="inline" set="null" expr="15" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</COMMENT>
		<DOCTYPE public="1" get="inline" set="null" expr="16" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</DOCTYPE>
		<CDATA public="1" get="inline" set="null" expr="17" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>17</e></m></meta>
		</CDATA>
		<ESCAPE public="1" get="inline" set="null" expr="18" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</ESCAPE>
	</class>
	<class path="haxe.xml.XmlParserException" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Parser.hx" module="haxe.xml.Parser">
		<message public="1">
			<c path="String"/>
			<haxe_doc>* the XML parsing error message</haxe_doc>
		</message>
		<lineNumber public="1">
			<x path="Int"/>
			<haxe_doc>* the line number at which the XML parsing error occurred</haxe_doc>
		</lineNumber>
		<positionAtLine public="1">
			<x path="Int"/>
			<haxe_doc>* the character position in the reported line at which the parsing error occurred</haxe_doc>
		</positionAtLine>
		<position public="1">
			<x path="Int"/>
			<haxe_doc>* the character position in the XML string at which the parsing error occurred</haxe_doc>
		</position>
		<xml public="1">
			<c path="String"/>
			<haxe_doc>* the invalid XML string</haxe_doc>
		</xml>
		<toString public="1" set="method" line="96"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="76"><f a="message:xml:position">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.xml.Parser" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Parser.hx">
		<escapes expr="{
	var h = new haxe.ds.StringMap();
	h.set(&quot;lt&quot;, &quot;&lt;&quot;);
	h.set(&quot;gt&quot;, &quot;&gt;&quot;);
	h.set(&quot;amp&quot;, &quot;&amp;&quot;);
	h.set(&quot;quot&quot;, &quot;\&quot;&quot;);
	h.set(&quot;apos&quot;, &quot;&apos;&quot;);
	h;
}" line="104" static="1">
			<c path="haxe.ds.StringMap"><c path="String"/></c>
			<meta><m n=":value"><e><![CDATA[{
	var h = new haxe.ds.StringMap();
	h.set("lt", "<");
	h.set("gt", ">");
	h.set("amp", "&");
	h.set("quot", "\"");
	h.set("apos", "'");
	h;
}]]></e></m></meta>
		</escapes>
		<parse public="1" set="method" line="119" static="1">
			<f a="str:?strict" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="Xml"/>
			</f>
			<meta><m n=":value"><e>{ strict : false }</e></m></meta>
			<haxe_doc>* Parses the String into an XML Document. Set strict parsing to true in order to enable a strict check of XML attributes and entities.
	 *
	 * @throws haxe.xml.XmlParserException</haxe_doc>
		</parse>
		<doParse set="method" line="126" static="1">
			<f a="str:strict:?p:?parent" v="::0:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Xml"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ p : 0 }</e></m></meta>
		</doParse>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.xml.Printer" params="" file="E:\HaxeToolkit\haxe\std\haxe/xml/Printer.hx">
		<print public="1" set="method" line="35" static="1">
			<f a="xml:?pretty" v=":false">
				<c path="Xml"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ pretty : false }</e></m></meta>
			<haxe_doc>Convert `Xml` to string representation.

		Set `pretty` to `true` to prettify the result.</haxe_doc>
		</print>
		<output><c path="StringBuf"/></output>
		<pretty><x path="Bool"/></pretty>
		<writeNode set="method" line="49"><f a="value:tabs">
	<c path="Xml"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeNode>
		<hasChildren set="method" line="114"><f a="value">
	<c path="Xml"/>
	<x path="Bool"/>
</f></hasChildren>
		<new set="method" line="44"><f a="pretty">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>This class provides utility methods to convert Xml instances to
	String representation.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.zip.Compress" params="" file="E:\HaxeToolkit\haxe\std\haxe/zip/Compress.hx">
		<run public="1" set="method" line="40" static="1"><f a="s:level">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.zip.Huffman" params="" file="E:\HaxeToolkit\haxe\std\haxe/zip/Huffman.hx">
		<Found a="i"><x path="Int"/></Found>
		<NeedBit a="left:right">
			<e path="haxe.zip.Huffman"/>
			<e path="haxe.zip.Huffman"/>
		</NeedBit>
		<NeedBits a="n:table">
			<x path="Int"/>
			<c path="Array"><e path="haxe.zip.Huffman"/></c>
		</NeedBits>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="haxe.zip.HuffTools" params="" file="E:\HaxeToolkit\haxe\std\haxe/zip/Huffman.hx" module="haxe.zip.Huffman">
		<treeDepth set="method" line="35"><f a="t">
	<e path="haxe.zip.Huffman"/>
	<x path="Int"/>
</f></treeDepth>
		<treeCompress set="method" line="46"><f a="t">
	<e path="haxe.zip.Huffman"/>
	<e path="haxe.zip.Huffman"/>
</f></treeCompress>
		<treeWalk set="method" line="63"><f a="table:p:cd:d:t">
	<c path="Array"><e path="haxe.zip.Huffman"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="haxe.zip.Huffman"/>
	<x path="Void"/>
</f></treeWalk>
		<treeMake set="method" line="76"><f a="bits:maxbits:v:len">
	<c path="haxe.ds.IntMap"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="haxe.zip.Huffman"/>
</f></treeMake>
		<make public="1" set="method" line="86"><f a="lengths:pos:nlengths:maxbits">
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="haxe.zip.Huffman"/>
</f></make>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.zip._InflateImpl.Window" params="" file="E:\HaxeToolkit\haxe\std\haxe/zip/InflateImpl.hx" private="1" module="haxe.zip.InflateImpl">
		<buffer public="1"><c path="haxe.io.Bytes"/></buffer>
		<pos public="1"><x path="Int"/></pos>
		<crc><c path="haxe.crypto.Adler32"/></crc>
		<slide public="1" set="method" line="41"><f a=""><x path="Void"/></f></slide>
		<addBytes public="1" set="method" line="49"><f a="b:p:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBytes>
		<addByte public="1" set="method" line="55"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></addByte>
		<getLastChar public="1" set="method" line="61"><f a=""><x path="Int"/></f></getLastChar>
		<available public="1" set="method" line="65"><f a=""><x path="Int"/></f></available>
		<checksum public="1" set="method" line="69"><f a=""><c path="haxe.crypto.Adler32"/></f></checksum>
		<new public="1" set="method" line="35"><f a="hasCrc">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.zip._InflateImpl.State" params="" file="E:\HaxeToolkit\haxe\std\haxe/zip/InflateImpl.hx" private="1" module="haxe.zip.InflateImpl">
		<Head/>
		<Block/>
		<CData/>
		<Flat/>
		<Crc/>
		<Dist/>
		<DistOne/>
		<Done/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="haxe.zip.InflateImpl" params="" file="E:\HaxeToolkit\haxe\std\haxe/zip/InflateImpl.hx">
		<LEN_EXTRA_BITS_TBL expr="[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, -1, -1]" line="92" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, -1, -1]</e></m></meta>
		</LEN_EXTRA_BITS_TBL>
		<LEN_BASE_VAL_TBL expr="[3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258]" line="93" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258]</e></m></meta>
		</LEN_BASE_VAL_TBL>
		<DIST_EXTRA_BITS_TBL expr="[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, -1, -1]" line="94" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, -1, -1]</e></m></meta>
		</DIST_EXTRA_BITS_TBL>
		<DIST_BASE_VAL_TBL expr="[1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]" line="95" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]</e></m></meta>
		</DIST_BASE_VAL_TBL>
		<CODE_LENGTHS_POS expr="[16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]" line="96" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]</e></m></meta>
		</CODE_LENGTHS_POS>
		<FIXED_HUFFMAN expr="null" line="114" static="1">
			<e path="haxe.zip.Huffman"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</FIXED_HUFFMAN>
		<run public="1" set="method" line="363" static="1">
			<f a="i:?bufsize" v=":65536">
				<c path="haxe.io.Input"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ bufsize : 65536 }</e></m></meta>
		</run>
		<nbits><x path="Int"/></nbits>
		<bits><x path="Int"/></bits>
		<state><e path="haxe.zip._InflateImpl.State"/></state>
		<isFinal><x path="Bool"/></isFinal>
		<huffman><e path="haxe.zip.Huffman"/></huffman>
		<huffdist><x path="Null"><e path="haxe.zip.Huffman"/></x></huffdist>
		<htools><c path="haxe.zip.HuffTools"/></htools>
		<len><x path="Int"/></len>
		<dist><x path="Int"/></dist>
		<needed><x path="Int"/></needed>
		<output><c path="haxe.io.Bytes"/></output>
		<outpos><x path="Int"/></outpos>
		<input><c path="haxe.io.Input"/></input>
		<lengths><c path="Array"><x path="Int"/></c></lengths>
		<window><c path="haxe.zip._InflateImpl.Window"/></window>
		<buildFixedHuffman set="method" line="136"><f a=""><e path="haxe.zip.Huffman"/></f></buildFixedHuffman>
		<readBytes public="1" set="method" line="146"><f a="b:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<getBits set="method" line="156"><f a="n">
	<x path="Int"/>
	<x path="Int"/>
</f></getBits>
		<getBit set="method" line="167"><f a=""><x path="Bool"/></f></getBit>
		<getRevBits set="method" line="178"><f a="n">
	<x path="Int"/>
	<x path="Int"/>
</f></getRevBits>
		<resetBits set="method" line="187"><f a=""><x path="Void"/></f></resetBits>
		<addBytes set="method" line="192"><f a="b:p:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBytes>
		<addByte set="method" line="199"><f a="b">
	<x path="Int"/>
	<x path="Void"/>
</f></addByte>
		<addDistOne set="method" line="206"><f a="n">
	<x path="Int"/>
	<x path="Void"/>
</f></addDistOne>
		<addDist set="method" line="212"><f a="d:len">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addDist>
		<applyHuffman set="method" line="216"><f a="h">
	<e path="haxe.zip.Huffman"/>
	<x path="Int"/>
</f></applyHuffman>
		<inflateLengths set="method" line="224"><f a="a:max">
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></inflateLengths>
		<inflateLoop set="method" line="253"><f a=""><x path="Bool"/></f></inflateLoop>
		<new public="1" set="method" line="116">
			<f a="i:?header:?crc" v=":true:true">
				<c path="haxe.io.Input"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ crc : true, header : true }</e></m></meta>
		</new>
		<haxe_doc>A pure Haxe implementation of the ZLIB Inflate algorithm which allows reading compressed data without any platform-specific support.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.zip.Uncompress" params="" file="E:\HaxeToolkit\haxe\std\haxe/zip/Uncompress.hx">
		<run public="1" set="method" line="40" static="1"><f a="src:?bufsize">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="hxd.BitmapInnerData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/BitmapData.hx" module="hxd.BitmapData"><c path="hxd.BitmapInnerDataImpl"/></typedef>
	<class path="hxd.BitmapInnerDataImpl" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/BitmapData.hx" module="hxd.BitmapData">
		<pixels public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></pixels>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<new public="1" set="method" line="21"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.BitmapData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/BitmapData.hx">
		<notImplemented get="inline" set="null" line="82" static="1"><f a=""><x path="Void"/></f></notImplemented>
		<fromNative public="1" set="method" line="695" static="1"><f a="data">
	<t path="hxd.BitmapInnerData"/>
	<c path="hxd.BitmapData"/>
</f></fromNative>
		<data><t path="hxd.BitmapInnerData"/></data>
		<width public="1" get="accessor" set="null"><x path="Int"/></width>
		<height public="1" get="accessor" set="null"><x path="Int"/></height>
		<clear public="1" set="method" line="74"><f a="color">
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<fill public="1" set="method" line="86"><f a="x:y:width:height:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fill>
		<draw public="1" set="method" line="122"><f a="x:y:src:srcX:srcY:width:height:?blendMode">
	<x path="Int"/>
	<x path="Int"/>
	<c path="hxd.BitmapData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="h2d.BlendMode"/>
	<x path="Void"/>
</f></draw>
		<drawScaled public="1" set="method" line="177">
			<f a="x:y:width:height:src:srcX:srcY:srcWidth:srcHeight:?blendMode:?smooth" v="::::::::::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="hxd.BitmapData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<e path="h2d.BlendMode"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smooth : true }</e></m></meta>
		</drawScaled>
		<line public="1" set="method" line="235"><f a="x0:y0:x1:y1:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></line>
		<dispose public="1" get="inline" set="null" line="469"><f a=""><x path="Void"/></f></dispose>
		<clone public="1" set="method" line="480"><f a=""><c path="hxd.BitmapData"/></f></clone>
		<sub public="1" set="method" line="484"><f a="x:y:w:h">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="hxd.BitmapData"/>
</f></sub>
		<lock public="1" set="method" line="520">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Inform that we will perform several pixel operations on the BitmapData.</haxe_doc>
		</lock>
		<unlock public="1" set="method" line="532">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Inform that we have finished performing pixel operations on the BitmapData.</haxe_doc>
		</unlock>
		<getPixel public="1" set="method" line="546">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Access the pixel color value at the given position. Note : this function can be very slow if done many times and the BitmapData has not been locked.</haxe_doc>
		</getPixel>
		<setPixel public="1" set="method" line="569">
			<f a="x:y:c">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Modify the pixel color value at the given position. Note : this function can be very slow if done many times and the BitmapData has not been locked.</haxe_doc>
		</setPixel>
		<get_width get="inline" set="null" line="599"><f a=""><x path="Int"/></f></get_width>
		<get_height get="inline" set="null" line="609"><f a=""><x path="Int"/></f></get_height>
		<getPixels public="1" set="method" line="619"><f a=""><c path="hxd.Pixels"/></f></getPixels>
		<setPixels public="1" set="method" line="641"><f a="pixels">
	<c path="hxd.Pixels"/>
	<x path="Void"/>
</f></setPixels>
		<toNative public="1" get="inline" set="null" line="685"><f a=""><t path="hxd.BitmapInnerData"/></f></toNative>
		<toPNG public="1" set="method" line="707"><f a=""><c path="haxe.io.Bytes"/></f></toPNG>
		<new public="1" set="method" line="47"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.Charset" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Charset.hx">
		<ASCII public="1" expr="&quot; !\&quot;#$%&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~&quot;" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA[" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"]]></e></m></meta>
			<haxe_doc>Contains the whole ASCII charset.</haxe_doc>
		</ASCII>
		<LATIN1 public="1" expr="&quot;¡¢£¤¥¦§¨©ª«¬-®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿœæŒÆ€&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"¡¢£¤¥¦§¨©ª«¬-®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿœæŒÆ€"</e></m></meta>
			<haxe_doc>The Latin1 (ISO 8859-1) charset (only the extra chars, no the ASCII part) + euro symbol</haxe_doc>
		</LATIN1>
		<CYRILLIC public="1" expr="&quot;АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя—&quot;" line="18" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя—"</e></m></meta>
			<haxe_doc>Russian support</haxe_doc>
		</CYRILLIC>
		<POLISH public="1" expr="&quot;ĄĆĘŁŃÓŚŹŻąćęłńóśźż&quot;" line="23" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ĄĆĘŁŃÓŚŹŻąćęłńóśźż"</e></m></meta>
			<haxe_doc>Polish support</haxe_doc>
		</POLISH>
		<TURKISH public="1" expr="&quot;ÂÇĞIİÎÖŞÜÛâçğıİîöşüû&quot;" line="28" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ÂÇĞIİÎÖŞÜÛâçğıİîöşüû"</e></m></meta>
			<haxe_doc>Turkish support</haxe_doc>
		</TURKISH>
		<JP_KANA public="1" expr="&quot;　あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをんがぎぐげござじずぜぞだぢづでどばびぶべぼぱぴぷぺぽゃゅょアイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲンガギグゲゴザジズゼゾダヂヅデドバビブベボパピプペポヴャぇっッュョァィゥェォ・ー「」、。『』“”！：？％＆（）－０１２３４５６７８９&quot;" line="33" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"　あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをんがぎぐげござじずぜぞだぢづでどばびぶべぼぱぴぷぺぽゃゅょアイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲンガギグゲゴザジズゼゾダヂヅデドバビブベボパピプペポヴャぇっッュョァィゥェォ・ー「」、。『』“”！：？％＆（）－０１２３４５６７８９"</e></m></meta>
			<haxe_doc><![CDATA[Contains Hiragana, Katanaga, japanese punctuaction and full width space (0x3000) full width numbers (0-9) and some full width ascii punctuation (!:?%&()-). Does not include full width A-Za-z.]]></haxe_doc>
		</JP_KANA>
		<UNICODE_SPECIALS public="1" expr="&quot;�□&quot;" line="38" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"�□"</e></m></meta>
			<haxe_doc>Special unicode chars (fallback chars)</haxe_doc>
		</UNICODE_SPECIALS>
		<DEFAULT_CHARS public="1" expr="ASCII + LATIN1" line="41" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>ASCII + LATIN1</e></m></meta>
		</DEFAULT_CHARS>
		<inst static="1"><c path="hxd.Charset"/></inst>
		<getDefault public="1" set="method" line="124" static="1"><f a=""><c path="hxd.Charset"/></f></getDefault>
		<map><t path="Map">
	<x path="Int"/>
	<x path="Int"/>
</t></map>
		<resolveChar public="1" params="T" set="method" line="101"><f a="code:glyphs">
	<x path="Int"/>
	<t path="Map">
		<x path="Int"/>
		<c path="resolveChar.T"/>
	</t>
	<x path="Null"><c path="resolveChar.T"/></x>
</f></resolveChar>
		<isCJK public="1" set="method" line="111"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></isCJK>
		<isSpace public="1" set="method" line="115"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></isSpace>
		<isBreakChar public="1" set="method" line="119"><f a="code">
	<x path="Int"/>
	<x path="Bool"/>
</f></isBreakChar>
		<new set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.Cursor" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Cursor.hx">
		<Default/>
		<Button/>
		<Move/>
		<TextInput/>
		<Hide/>
		<Custom a="custom"><c path="hxd.CustomCursor"/></Custom>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="hxd.CustomCursor" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Cursor.hx" module="hxd.Cursor">
		<frames><c path="Array"><c path="hxd.BitmapData"/></c></frames>
		<speed><x path="Float"/></speed>
		<offsetX><x path="Int"/></offsetX>
		<offsetY><x path="Int"/></offsetY>
		<alloc><d/></alloc>
		<dispose public="1" set="method" line="82"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="42"><f a="frames:speed:offsetX:offsetY">
	<c path="Array"><c path="hxd.BitmapData"/></c>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":allow"><e>hxd.System</e></m></meta>
	</class>
	<enum path="hxd.EventKind" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Event.hx" module="hxd.Event">
		<EPush/>
		<ERelease/>
		<EMove/>
		<EOver/>
		<EOut/>
		<EWheel/>
		<EFocus/>
		<EFocusLost/>
		<EKeyDown/>
		<EKeyUp/>
		<EReleaseOutside/>
		<ETextInput/>
		<ECheck><haxe_doc>Used to check if we are still on the interactive if no EMove was triggered this frame.</haxe_doc></ECheck>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="hxd.Event" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Event.hx">
		<kind public="1"><e path="hxd.EventKind"/></kind>
		<relX public="1"><x path="Float"/></relX>
		<relY public="1"><x path="Float"/></relY>
		<relZ public="1"><x path="Float"/></relZ>
		<propagate public="1">
			<x path="Bool"/>
			<haxe_doc>Will propagate the event to other interactives that are below the current one.</haxe_doc>
		</propagate>
		<cancel public="1">
			<x path="Bool"/>
			<haxe_doc>Will cancel the default behavior for this event as if it had happen outside of the interactive zone.</haxe_doc>
		</cancel>
		<button public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</button>
		<touchId public="1"><x path="Int"/></touchId>
		<keyCode public="1"><x path="Int"/></keyCode>
		<charCode public="1"><x path="Int"/></charCode>
		<wheelDelta public="1"><x path="Float"/></wheelDelta>
		<toString public="1" set="method" line="48"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="42">
			<f a="k:?x:?y" v=":0.:0.">
				<e path="hxd.EventKind"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0., x : 0. }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxd.BrowseOptions" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/File.hx" module="hxd.File"><a>
	<title>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</title>
	<saveFileName>
		<x path="Null"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":optional"/></meta>
	</saveFileName>
	<relativePath>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</relativePath>
	<fileTypes>
		<x path="Null"><c path="Array"><a>
	<name><c path="String"/></name>
	<extensions><c path="Array"><c path="String"/></c></extensions>
</a></c></x>
		<meta><m n=":optional"/></meta>
	</fileTypes>
	<defaultPath>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</defaultPath>
</a></typedef>
	<typedef path="hxd.BrowseSelect" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/File.hx" module="hxd.File"><a>
	<load set="method">
		<f a="onReady">
			<f a="">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<x path="Void"/>
		</f>
		<haxe_doc>allow to load the selected file content</haxe_doc>
	</load>
	<fileName>
		<c path="String"/>
		<haxe_doc>might contain only the file name without the full path depending on sandbox restrictions</haxe_doc>
	</fileName>
</a></typedef>
	<class path="hxd.File" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/File.hx">
		<browse public="1" set="method" line="75" static="1"><f a="onSelect:?options">
	<f a="">
		<t path="hxd.BrowseSelect"/>
		<x path="Void"/>
	</f>
	<t path="hxd.BrowseOptions"/>
	<x path="Void"/>
</f></browse>
		<saveAs public="1" set="method" line="153" static="1"><f a="dataContent:?options">
	<c path="haxe.io.Bytes"/>
	<t path="hxd.BrowseOptions"/>
	<x path="Void"/>
</f></saveAs>
		<exists public="1" set="method" line="188" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<delete public="1" set="method" line="199" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></delete>
		<listDirectory public="1" set="method" line="212" static="1"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></listDirectory>
		<getBytes public="1" set="method" line="226" static="1"><f a="path">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
		<saveBytes public="1" set="method" line="255" static="1"><f a="path:data">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></saveBytes>
		<load public="1" set="method" line="271" static="1"><f a="path:onLoad:?onError">
	<c path="String"/>
	<f a="">
		<c path="haxe.io.Bytes"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></load>
		<createDirectory public="1" set="method" line="294" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></createDirectory>
		<applicationPath public="1" set="method" line="304" static="1"><f a=""><c path="String"/></f></applicationPath>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxd._FloatBuffer.InnerData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/FloatBuffer.hx" private="1" module="hxd.FloatBuffer"><c path="Array"><t path="hxd.impl.Float32"/></c></typedef>
	<class path="hxd._FloatBuffer.InnerIterator" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/FloatBuffer.hx" private="1" module="hxd.FloatBuffer">
		<b><t path="hxd._FloatBuffer.InnerData"/></b>
		<len><x path="Int"/></len>
		<pos><x path="Int"/></pos>
		<hasNext public="1" get="inline" set="null" line="54"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="57"><f a=""><t path="hxd.impl.Float32"/></f></next>
		<new public="1" get="inline" set="null" line="49"><f a="b">
	<t path="hxd._FloatBuffer.InnerData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="hxd.FloatBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/FloatBuffer.hx">
		<this><t path="hxd._FloatBuffer.InnerData"/></this>
		<impl><class path="hxd._FloatBuffer.FloatBuffer_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/FloatBuffer.hx" private="1" module="hxd.FloatBuffer">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" get="inline" set="null" line="66" static="1">
		<f a="?length" v="0">
			<x path="Int"/>
			<x path="hxd.FloatBuffer"/>
		</f>
		<meta>
			<m n=":value"><e>{ length : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<push public="1" get="inline" set="null" line="75" static="1">
		<f a="this:v">
			<t path="hxd._FloatBuffer.InnerData"/>
			<t path="hxd.impl.Float32"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</push>
	<grow public="1" get="inline" set="null" line="83" static="1">
		<f a="this:v">
			<t path="hxd._FloatBuffer.InnerData"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</grow>
	<resize public="1" get="inline" set="null" line="94" static="1">
		<f a="this:v">
			<t path="hxd._FloatBuffer.InnerData"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</resize>
	<arrayRead get="inline" set="null" line="103" static="1">
		<f a="this:key">
			<t path="hxd._FloatBuffer.InnerData"/>
			<x path="Int"/>
			<t path="hxd.impl.Float32"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</arrayRead>
	<arrayWrite get="inline" set="null" line="107" static="1">
		<f a="this:key:value">
			<t path="hxd._FloatBuffer.InnerData"/>
			<x path="Int"/>
			<t path="hxd.impl.Float32"/>
			<t path="hxd.impl.Float32"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</arrayWrite>
	<getNative public="1" get="inline" set="null" line="111" static="1">
		<f a="this">
			<t path="hxd._FloatBuffer.InnerData"/>
			<t path="hxd._FloatBuffer.InnerData"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getNative>
	<iterator public="1" get="inline" set="null" line="115" static="1">
		<f a="this">
			<t path="hxd._FloatBuffer.InnerData"/>
			<c path="hxd._FloatBuffer.InnerIterator"/>
		</f>
		<meta><m n=":impl"/></meta>
	</iterator>
	<get_length get="inline" set="null" line="119" static="1">
		<f a="this">
			<t path="hxd._FloatBuffer.InnerData"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
</class></impl>
	</abstract>
	<class path="hxd._FloatBuffer.FloatBuffer_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/FloatBuffer.hx" private="1" module="hxd.FloatBuffer">
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" get="inline" set="null" line="66" static="1">
			<f a="?length" v="0">
				<x path="Int"/>
				<x path="hxd.FloatBuffer"/>
			</f>
			<meta>
				<m n=":value"><e>{ length : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<push public="1" get="inline" set="null" line="75" static="1">
			<f a="this:v">
				<t path="hxd._FloatBuffer.InnerData"/>
				<t path="hxd.impl.Float32"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</push>
		<grow public="1" get="inline" set="null" line="83" static="1">
			<f a="this:v">
				<t path="hxd._FloatBuffer.InnerData"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</grow>
		<resize public="1" get="inline" set="null" line="94" static="1">
			<f a="this:v">
				<t path="hxd._FloatBuffer.InnerData"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</resize>
		<arrayRead get="inline" set="null" line="103" static="1">
			<f a="this:key">
				<t path="hxd._FloatBuffer.InnerData"/>
				<x path="Int"/>
				<t path="hxd.impl.Float32"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</arrayRead>
		<arrayWrite get="inline" set="null" line="107" static="1">
			<f a="this:key:value">
				<t path="hxd._FloatBuffer.InnerData"/>
				<x path="Int"/>
				<t path="hxd.impl.Float32"/>
				<t path="hxd.impl.Float32"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</arrayWrite>
		<getNative public="1" get="inline" set="null" line="111" static="1">
			<f a="this">
				<t path="hxd._FloatBuffer.InnerData"/>
				<t path="hxd._FloatBuffer.InnerData"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getNative>
		<iterator public="1" get="inline" set="null" line="115" static="1">
			<f a="this">
				<t path="hxd._FloatBuffer.InnerData"/>
				<c path="hxd._FloatBuffer.InnerIterator"/>
			</f>
			<meta><m n=":impl"/></meta>
		</iterator>
		<get_length get="inline" set="null" line="119" static="1">
			<f a="this">
				<t path="hxd._FloatBuffer.InnerData"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
	</class>
	<typedef path="hxd._IndexBuffer.InnerData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/IndexBuffer.hx" private="1" module="hxd.IndexBuffer"><c path="Array"><t path="hxd.impl.UInt16"/></c></typedef>
	<class path="hxd._IndexBuffer.InnerIterator" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/IndexBuffer.hx" private="1" module="hxd.IndexBuffer">
		<b><t path="hxd._IndexBuffer.InnerData"/></b>
		<len><x path="Int"/></len>
		<pos><x path="Int"/></pos>
		<hasNext public="1" get="inline" set="null" line="14"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="17"><f a=""><x path="Int"/></f></next>
		<new public="1" get="inline" set="null" line="9"><f a="b">
	<t path="hxd._IndexBuffer.InnerData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="hxd.IndexBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/IndexBuffer.hx">
		<this><t path="hxd._IndexBuffer.InnerData"/></this>
		<impl><class path="hxd._IndexBuffer.IndexBuffer_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/IndexBuffer.hx" private="1" module="hxd.IndexBuffer">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" get="inline" set="null" line="26" static="1">
		<f a="?length" v="0">
			<x path="Int"/>
			<x path="hxd.IndexBuffer"/>
		</f>
		<meta>
			<m n=":value"><e>{ length : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<push public="1" get="inline" set="null" line="37" static="1">
		<f a="this:v">
			<t path="hxd._IndexBuffer.InnerData"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</push>
	<grow public="1" get="inline" set="null" line="45" static="1">
		<f a="this:v">
			<t path="hxd._IndexBuffer.InnerData"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</grow>
	<arrayRead get="inline" set="null" line="55" static="1">
		<f a="this:key">
			<t path="hxd._IndexBuffer.InnerData"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</arrayRead>
	<arrayWrite get="inline" set="null" line="59" static="1">
		<f a="this:key:value">
			<t path="hxd._IndexBuffer.InnerData"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</arrayWrite>
	<getNative public="1" get="inline" set="null" line="63" static="1">
		<f a="this">
			<t path="hxd._IndexBuffer.InnerData"/>
			<t path="hxd._IndexBuffer.InnerData"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getNative>
	<iterator public="1" get="inline" set="null" line="67" static="1">
		<f a="this">
			<t path="hxd._IndexBuffer.InnerData"/>
			<c path="hxd._IndexBuffer.InnerIterator"/>
		</f>
		<meta><m n=":impl"/></meta>
	</iterator>
	<get_length get="inline" set="null" line="71" static="1">
		<f a="this">
			<t path="hxd._IndexBuffer.InnerData"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
</class></impl>
	</abstract>
	<class path="hxd._IndexBuffer.IndexBuffer_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/IndexBuffer.hx" private="1" module="hxd.IndexBuffer">
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" get="inline" set="null" line="26" static="1">
			<f a="?length" v="0">
				<x path="Int"/>
				<x path="hxd.IndexBuffer"/>
			</f>
			<meta>
				<m n=":value"><e>{ length : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<push public="1" get="inline" set="null" line="37" static="1">
			<f a="this:v">
				<t path="hxd._IndexBuffer.InnerData"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</push>
		<grow public="1" get="inline" set="null" line="45" static="1">
			<f a="this:v">
				<t path="hxd._IndexBuffer.InnerData"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</grow>
		<arrayRead get="inline" set="null" line="55" static="1">
			<f a="this:key">
				<t path="hxd._IndexBuffer.InnerData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</arrayRead>
		<arrayWrite get="inline" set="null" line="59" static="1">
			<f a="this:key:value">
				<t path="hxd._IndexBuffer.InnerData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</arrayWrite>
		<getNative public="1" get="inline" set="null" line="63" static="1">
			<f a="this">
				<t path="hxd._IndexBuffer.InnerData"/>
				<t path="hxd._IndexBuffer.InnerData"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getNative>
		<iterator public="1" get="inline" set="null" line="67" static="1">
			<f a="this">
				<t path="hxd._IndexBuffer.InnerData"/>
				<c path="hxd._IndexBuffer.InnerIterator"/>
			</f>
			<meta><m n=":impl"/></meta>
		</iterator>
		<get_length get="inline" set="null" line="71" static="1">
			<f a="this">
				<t path="hxd._IndexBuffer.InnerData"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
	</class>
	<class path="hxd.Math" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Math.hx">
		<PI public="1" get="inline" set="null" expr="3.14159265358979323" line="5" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>3.14159265358979323</e></m></meta>
		</PI>
		<EPSILON public="1" get="inline" set="null" expr="1e-10" line="6" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1e-10</e></m></meta>
		</EPSILON>
		<POSITIVE_INFINITY public="1" get="accessor" set="null" static="1"><x path="Float"/></POSITIVE_INFINITY>
		<NEGATIVE_INFINITY public="1" get="accessor" set="null" static="1"><x path="Float"/></NEGATIVE_INFINITY>
		<NaN public="1" get="accessor" set="null" static="1"><x path="Float"/></NaN>
		<get_POSITIVE_INFINITY get="inline" set="null" line="12" static="1"><f a=""><x path="Float"/></f></get_POSITIVE_INFINITY>
		<get_NEGATIVE_INFINITY get="inline" set="null" line="16" static="1"><f a=""><x path="Float"/></f></get_NEGATIVE_INFINITY>
		<get_NaN get="inline" set="null" line="20" static="1"><f a=""><x path="Float"/></f></get_NaN>
		<isNaN public="1" get="inline" set="null" line="24" static="1"><f a="v">
	<x path="Float"/>
	<x path="Bool"/>
</f></isNaN>
		<fmt public="1" set="method" line="29" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fmt>
		<floor public="1" get="inline" set="null" line="47" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></floor>
		<ceil public="1" get="inline" set="null" line="51" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></ceil>
		<round public="1" get="inline" set="null" line="55" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></round>
		<clamp public="1" get="inline" set="null" line="59" static="1">
			<f a="f:?min:?max" v=":0.:1.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ max : 1., min : 0. }</e></m></meta>
		</clamp>
		<pow public="1" get="inline" set="null" line="63" static="1"><f a="v:p">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pow>
		<scaleTime public="1" get="inline" set="null" line="67" static="1"><f a="v:et">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></scaleTime>
		<cos public="1" get="inline" set="null" line="71" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></cos>
		<sin public="1" get="inline" set="null" line="75" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></sin>
		<tan public="1" get="inline" set="null" line="79" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></tan>
		<acos public="1" get="inline" set="null" line="83" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></acos>
		<asin public="1" get="inline" set="null" line="87" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></asin>
		<atan public="1" get="inline" set="null" line="91" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></atan>
		<sqrt public="1" get="inline" set="null" line="95" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></sqrt>
		<invSqrt public="1" get="inline" set="null" line="99" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></invSqrt>
		<atan2 public="1" get="inline" set="null" line="103" static="1"><f a="dy:dx">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></atan2>
		<abs public="1" get="inline" set="null" line="107" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></abs>
		<max public="1" get="inline" set="null" line="111" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></max>
		<min public="1" get="inline" set="null" line="115" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></min>
		<iabs public="1" get="inline" set="null" line="119" static="1"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></iabs>
		<imax public="1" get="inline" set="null" line="123" static="1"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></imax>
		<imin public="1" get="inline" set="null" line="127" static="1"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></imin>
		<iclamp public="1" get="inline" set="null" line="131" static="1"><f a="v:min:max">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></iclamp>
		<lerp public="1" get="inline" set="null" line="138" static="1">
			<f a="a:b:k">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Linear interpolation between two values. When k is 0 a is returned, when it's 1, b is returned.</haxe_doc>
		</lerp>
		<bitCount public="1" get="inline" set="null" line="142" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></bitCount>
		<distanceSq public="1" get="inline" set="null" line="148" static="1">
			<f a="dx:dy:?dz" v="::0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ dz : 0. }</e></m></meta>
		</distanceSq>
		<distance public="1" get="inline" set="null" line="152" static="1">
			<f a="dx:dy:?dz" v="::0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ dz : 0. }</e></m></meta>
		</distance>
		<colorLerp public="1" set="method" line="159" static="1">
			<f a="c1:c2:k">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Linear interpolation between two colors (ARGB).</haxe_doc>
		</colorLerp>
		<angle public="1" get="inline" set="null" line="178" static="1"><f a="da">
	<x path="Float"/>
	<x path="Float"/>
</f></angle>
		<angleLerp public="1" get="inline" set="null" line="184" static="1"><f a="a:b:k">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></angleLerp>
		<angleMove public="1" get="inline" set="null" line="191" static="1">
			<f a="a:b:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Move angle a towards angle b with a max increment. Return the new angle.</haxe_doc>
		</angleMove>
		<shuffle public="1" params="T" get="inline" set="null" line="196" static="1"><f a="a">
	<c path="Array"><c path="shuffle.T"/></c>
	<x path="Void"/>
</f></shuffle>
		<random public="1" get="inline" set="null" line="207" static="1">
			<f a="?max" v="1.0">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ max : 1.0 }</e></m></meta>
		</random>
		<srand public="1" set="method" line="214" static="1">
			<f a="?max" v="1.0">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ max : 1.0 }</e></m></meta>
			<haxe_doc>Returns a signed random between -max and max (both included).</haxe_doc>
		</srand>
		<b2f public="1" get="inline" set="null" line="224" static="1">
			<f a="v">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* takes an int , masks it and devide so that it safely maps 0...255 to 0...1.0
	 * @paramv an int between 0 and 255 will be masked
	 * @return a float between( 0 and 1)</haxe_doc>
		</b2f>
		<f2b public="1" get="inline" set="null" line="233" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* takes a float , clamps it and multipy so that it safely maps 0...1 to 0...255.0
	 * @param	f a float
	 * @return an int [0...255]</haxe_doc>
		</f2b>
		<umod public="1" get="inline" set="null" line="240" static="1">
			<f a="value:modulo">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* returns the modulo but always positive</haxe_doc>
		</umod>
		<ufmod public="1" get="inline" set="null" line="248" static="1">
			<f a="value:modulo">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* returns the modulo but always positive</haxe_doc>
		</ufmod>
		<degToRad public="1" get="inline" set="null" line="256" static="1">
			<f a="deg">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Convert degrees to radians</haxe_doc>
		</degToRad>
		<radToDeg public="1" get="inline" set="null" line="263" static="1">
			<f a="rad">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Convert radians to degrees</haxe_doc>
		</radToDeg>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.Flags" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" module="hxd.Pixels">
		<ReadOnly/>
		<AlphaPremultiplied/>
		<FlipY/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<abstract path="hxd.PixelsARGB" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" module="hxd.Pixels">
		<from><icast field="fromPixels"><c path="hxd.Pixels"/></icast></from>
		<this><c path="hxd.Pixels"/></this>
		<to><icast><c path="hxd.Pixels"/></icast></to>
		<meta><m n=":forward">
	<e>bytes</e>
	<e>width</e>
	<e>height</e>
	<e>offset</e>
	<e>flags</e>
	<e>clear</e>
	<e>dispose</e>
	<e>toPNG</e>
	<e>clone</e>
	<e>toVector</e>
	<e>sub</e>
	<e>blit</e>
</m></meta>
		<impl><class path="hxd._Pixels.PixelsARGB_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" private="1" module="hxd.Pixels">
	<getPixel public="1" get="inline" set="null" line="13" static="1">
		<f a="this:x:y">
			<c path="hxd.Pixels"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getPixel>
	<setPixel public="1" get="inline" set="null" line="17" static="1">
		<f a="this:x:y:v">
			<c path="hxd.Pixels"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</setPixel>
	<fromPixels public="1" set="method" line="21" static="1">
		<f a="p">
			<c path="hxd.Pixels"/>
			<x path="hxd.PixelsARGB"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromPixels>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="hxd._Pixels.PixelsARGB_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" private="1" module="hxd.Pixels">
		<getPixel public="1" get="inline" set="null" line="13" static="1">
			<f a="this:x:y">
				<c path="hxd.Pixels"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getPixel>
		<setPixel public="1" get="inline" set="null" line="17" static="1">
			<f a="this:x:y:v">
				<c path="hxd.Pixels"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</setPixel>
		<fromPixels public="1" set="method" line="21" static="1">
			<f a="p">
				<c path="hxd.Pixels"/>
				<x path="hxd.PixelsARGB"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromPixels>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="hxd.PixelsFloat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" module="hxd.Pixels">
		<from><icast field="fromPixels"><c path="hxd.Pixels"/></icast></from>
		<this><c path="hxd.Pixels"/></this>
		<to><icast><c path="hxd.Pixels"/></icast></to>
		<meta><m n=":forward">
	<e>bytes</e>
	<e>width</e>
	<e>height</e>
	<e>offset</e>
	<e>flags</e>
	<e>clear</e>
	<e>dispose</e>
	<e>toPNG</e>
	<e>clone</e>
	<e>toVector</e>
	<e>sub</e>
	<e>blit</e>
</m></meta>
		<impl><class path="hxd._Pixels.PixelsFloat_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" private="1" module="hxd.Pixels">
	<getPixelF public="1" get="inline" set="null" line="32" static="1">
		<f a="this:x:y">
			<c path="hxd.Pixels"/>
			<x path="Int"/>
			<x path="Int"/>
			<c path="h3d.Vector"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getPixelF>
	<setPixelF public="1" get="inline" set="null" line="37" static="1">
		<f a="this:x:y:v">
			<c path="hxd.Pixels"/>
			<x path="Int"/>
			<x path="Int"/>
			<c path="h3d.Vector"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</setPixelF>
	<fromPixels public="1" set="method" line="45" static="1">
		<f a="p">
			<c path="hxd.Pixels"/>
			<x path="hxd.PixelsFloat"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromPixels>
</class></impl>
	</abstract>
	<class path="hxd._Pixels.PixelsFloat_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" private="1" module="hxd.Pixels">
		<getPixelF public="1" get="inline" set="null" line="32" static="1">
			<f a="this:x:y">
				<c path="hxd.Pixels"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="h3d.Vector"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getPixelF>
		<setPixelF public="1" get="inline" set="null" line="37" static="1">
			<f a="this:x:y:v">
				<c path="hxd.Pixels"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="h3d.Vector"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</setPixelF>
		<fromPixels public="1" set="method" line="45" static="1">
			<f a="p">
				<c path="hxd.Pixels"/>
				<x path="hxd.PixelsFloat"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromPixels>
	</class>
	<abstract path="hxd.Channel" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" module="hxd.Pixels">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="hxd._Pixels.Channel_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" private="1" module="hxd.Pixels">
	<R public="1" get="inline" set="null" expr="cast 0" line="53" static="1">
		<x path="hxd.Channel"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</R>
	<G public="1" get="inline" set="null" expr="cast 1" line="54" static="1">
		<x path="hxd.Channel"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</G>
	<B public="1" get="inline" set="null" expr="cast 2" line="55" static="1">
		<x path="hxd.Channel"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</B>
	<A public="1" get="inline" set="null" expr="cast 3" line="56" static="1">
		<x path="hxd.Channel"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</A>
	<toInt public="1" get="inline" set="null" line="57" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toInt>
	<fromInt public="1" get="inline" set="null" line="58" static="1"><f a="v">
	<x path="Int"/>
	<x path="hxd.Channel"/>
</f></fromInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="hxd._Pixels.Channel_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx" private="1" module="hxd.Pixels">
		<R public="1" get="inline" set="null" expr="cast 0" line="53" static="1">
			<x path="hxd.Channel"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</R>
		<G public="1" get="inline" set="null" expr="cast 1" line="54" static="1">
			<x path="hxd.Channel"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</G>
		<B public="1" get="inline" set="null" expr="cast 2" line="55" static="1">
			<x path="hxd.Channel"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</B>
		<A public="1" get="inline" set="null" expr="cast 3" line="56" static="1">
			<x path="hxd.Channel"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</A>
		<toInt public="1" get="inline" set="null" line="57" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toInt>
		<fromInt public="1" get="inline" set="null" line="58" static="1"><f a="v">
	<x path="Int"/>
	<x path="hxd.Channel"/>
</f></fromInt>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="hxd.Pixels" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Pixels.hx">
		<switchEndian public="1" get="inline" set="null" line="81" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></switchEndian>
		<switchBR public="1" get="inline" set="null" line="85" static="1"><f a="v">
	<x path="Int"/>
	<x path="Int"/>
</f></switchBR>
		<getBytesPerPixel public="1" set="method" line="388" static="1"><f a="format">
	<e path="hxd.PixelFormat"/>
	<x path="Int"/>
</f></getBytesPerPixel>
		<getChannelOffset public="1" set="method" line="411" static="1">
			<f a="format:channel">
				<e path="hxd.PixelFormat"/>
				<x path="hxd.Channel"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the byte offset for the requested channel (0=R,1=G,2=B,3=A)
		Returns -1 if the channel is not found</haxe_doc>
		</getChannelOffset>
		<alloc public="1" set="method" line="436" static="1"><f a="width:height:format">
	<x path="Int"/>
	<x path="Int"/>
	<e path="hxd.PixelFormat"/>
	<c path="hxd.Pixels"/>
</f></alloc>
		<bytes public="1"><c path="haxe.io.Bytes"/></bytes>
		<format public="1" get="accessor" set="null"><e path="hxd.PixelFormat"/></format>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<offset public="1"><x path="Int"/></offset>
		<flags public="1"><x path="haxe.EnumFlags"><e path="hxd.Flags"/></x></flags>
		<bytesPerPixel public="1" set="null"><x path="Int"/></bytesPerPixel>
		<innerFormat set="accessor"><e path="hxd.PixelFormat"/></innerFormat>
		<get_format get="inline" set="null" line="89"><f a=""><e path="hxd.PixelFormat"/></f></get_format>
		<set_innerFormat set="method" line="91"><f a="fmt">
	<e path="hxd.PixelFormat"/>
	<e path="hxd.PixelFormat"/>
</f></set_innerFormat>
		<invalidFormat set="method" line="97"><f a=""><x path="Void"/></f></invalidFormat>
		<sub public="1" set="method" line="101"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="hxd.Pixels"/>
</f></sub>
		<yflip get="inline" set="null" line="115"><f a="y">
	<x path="Int"/>
	<x path="Int"/>
</f></yflip>
		<blit public="1" set="method" line="119"><f a="x:y:src:srcX:srcY:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<c path="hxd.Pixels"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blit>
		<clear public="1" set="method" line="135">
			<f a="color:?preserveMask" v=":0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ preserveMask : 0 }</e></m></meta>
		</clear>
		<toVector public="1" set="method" line="167"><f a=""><x path="haxe.ds.Vector"><x path="Int"/></x></f></toVector>
		<makeSquare public="1" set="method" line="209"><f a="?copy">
	<x path="Bool"/>
	<c path="hxd.Pixels"/>
</f></makeSquare>
		<copyInner set="method" line="239"><f a=""><x path="Void"/></f></copyInner>
		<willChange get="inline" set="null" line="247"><f a=""><x path="Void"/></f></willChange>
		<setFlip public="1" set="method" line="251"><f a="b">
	<x path="Bool"/>
	<x path="Void"/>
</f></setFlip>
		<convert public="1" set="method" line="272"><f a="target">
	<e path="hxd.PixelFormat"/>
	<x path="Void"/>
</f></convert>
		<getPixel public="1" set="method" line="327"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getPixel>
		<setPixel public="1" set="method" line="342"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setPixel>
		<dispose public="1" set="method" line="357"><f a=""><x path="Void"/></f></dispose>
		<toPNG public="1" set="method" line="361">
			<f a="?level" v="9">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ level : 9 }</e></m></meta>
		</toPNG>
		<clone public="1" set="method" line="376"><f a=""><c path="hxd.Pixels"/></f></clone>
		<new public="1" set="method" line="72">
			<f a="width:height:bytes:format:?offset" v="::::0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<e path="hxd.PixelFormat"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="hxd.SceneEvents" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/SceneEvents.hx">
		<window><c path="hxd.Window"/></window>
		<scenes><c path="Array"><c path="hxd.InteractiveScene"/></c></scenes>
		<currentOver><c path="hxd.Interactive"/></currentOver>
		<currentFocus><c path="hxd.Interactive"/></currentFocus>
		<pendingEvents><c path="Array"><c path="hxd.Event"/></c></pendingEvents>
		<pushList><c path="Array"><c path="hxd.Interactive"/></c></pushList>
		<currentDrag><a>
	<ref><x path="Null"><x path="Int"/></x></ref>
	<onCancel><f a=""><x path="Void"/></f></onCancel>
	<f><f a="">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></f>
</a></currentDrag>
		<mouseX expr="-1.">
			<x path="Float"/>
			<meta><m n=":value"><e>-1.</e></m></meta>
		</mouseX>
		<mouseY expr="-1.">
			<x path="Float"/>
			<meta><m n=":value"><e>-1.</e></m></meta>
		</mouseY>
		<lastTouch expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lastTouch>
		<focusLost expr="new hxd.Event(EFocusLost)">
			<c path="hxd.Event"/>
			<meta><m n=":value"><e>new hxd.Event(EFocusLost)</e></m></meta>
		</focusLost>
		<checkPos expr="new hxd.Event(ECheck)">
			<c path="hxd.Event"/>
			<meta><m n=":value"><e>new hxd.Event(ECheck)</e></m></meta>
		</checkPos>
		<onOut expr="new hxd.Event(EOut)">
			<c path="hxd.Event"/>
			<meta><m n=":value"><e>new hxd.Event(EOut)</e></m></meta>
		</onOut>
		<isOut expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isOut>
		<enablePhysicalMouse public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* enablePhysicalMouse : enable mouse movements of system mouse, set it to false anse use setMousePos instead to manually set mouse position</haxe_doc>
		</enablePhysicalMouse>
		<mouseCheckMove public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* enable/disable per frame check of elements under mouse (default:true)</haxe_doc>
		</mouseCheckMove>
		<setMousePos public="1" set="method" line="55"><f a="xPos:yPos">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setMousePos>
		<onRemove set="method" line="60"><f a="i">
	<c path="hxd.Interactive"/>
	<x path="Void"/>
</f></onRemove>
		<addScene public="1" set="method" line="70"><f a="s:?index">
	<c path="hxd.InteractiveScene"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addScene>
		<removeScene public="1" set="method" line="75"><f a="s">
	<c path="hxd.InteractiveScene"/>
	<x path="Void"/>
</f></removeScene>
		<dispose public="1" set="method" line="79"><f a=""><x path="Void"/></f></dispose>
		<focus public="1" set="method" line="83"><f a="i">
	<c path="hxd.Interactive"/>
	<x path="Void"/>
</f></focus>
		<blur public="1" set="method" line="100"><f a=""><x path="Void"/></f></blur>
		<checkFocus set="method" line="109"><f a=""><x path="Void"/></f></checkFocus>
		<emitEvent set="method" line="120"><f a="event">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></emitEvent>
		<checkEvents public="1" set="method" line="240"><f a=""><x path="Void"/></f></checkEvents>
		<startDrag public="1" set="method" line="311"><f a="f:?onCancel:?refEvent">
	<f a="">
		<c path="hxd.Event"/>
		<x path="Void"/>
	</f>
	<f a=""><x path="Void"/></f>
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></startDrag>
		<stopDrag public="1" set="method" line="317"><f a=""><x path="Void"/></f></stopDrag>
		<getFocus public="1" set="method" line="323"><f a=""><c path="hxd.Interactive"/></f></getFocus>
		<onEvent set="method" line="327"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></onEvent>
		<dispatchListeners set="method" line="332"><f a="event">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></dispatchListeners>
		<new public="1" set="method" line="46"><f a="?window">
	<c path="hxd.Window"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="hxd.Platform" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/System.hx" module="hxd.System">
		<IOS/>
		<Android/>
		<WebGL/>
		<PC/>
		<Console/>
		<FlashPlayer/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hxd.SystemValue" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/System.hx" module="hxd.System">
		<IsTouch/>
		<IsWindowed/>
		<IsMobile/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="hxd.System" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/System.hx">
		<width public="1" get="accessor" set="null" static="1"><x path="Int"/></width>
		<height public="1" get="accessor" set="null" static="1"><x path="Int"/></height>
		<lang public="1" get="accessor" set="null" static="1"><c path="String"/></lang>
		<platform public="1" get="accessor" set="null" static="1"><e path="hxd.Platform"/></platform>
		<screenDPI public="1" get="accessor" set="null" static="1"><x path="Float"/></screenDPI>
		<setCursor public="1" expr="setNativeCursor" line="29" static="1">
			<f a="">
				<e path="hxd.Cursor"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>setNativeCursor</e></m></meta>
			<haxe_doc>Sets current cursor and can be replaced by custom function to manually operate displayed cursor.
		When called, it should call `hxd.System.setNativeCursor` and pass desired `hxd.Cursor` to it.</haxe_doc>
		</setCursor>
		<allowTimeout public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<haxe_doc>Can be used to temporarly disable infinite loop check</haxe_doc>
		</allowTimeout>
		<timeoutTick public="1" set="method" line="39" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>If you have a time consuming calculus that might trigger a timeout, you can either disable timeouts with [allowTimeout] or call timeoutTick() frequently.</haxe_doc>
		</timeoutTick>
		<loopFunc static="1"><f a=""><x path="Void"/></f></loopFunc>
		<getCurrentLoop public="1" set="method" line="44" static="1"><f a=""><f a=""><x path="Void"/></f></f></getCurrentLoop>
		<setLoop public="1" set="method" line="48" static="1"><f a="f">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></setLoop>
		<start public="1" set="method" line="52" static="1"><f a="callb">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></start>
		<setNativeCursor public="1" set="method" line="55" static="1"><f a="c">
	<e path="hxd.Cursor"/>
	<x path="Void"/>
</f></setNativeCursor>
		<getDeviceName public="1" set="method" line="58" static="1"><f a=""><c path="String"/></f></getDeviceName>
		<getDefaultFrameRate public="1" set="method" line="62" static="1"><f a=""><x path="Float"/></f></getDefaultFrameRate>
		<getValue public="1" set="method" line="66" static="1"><f a="s">
	<e path="hxd.SystemValue"/>
	<x path="Bool"/>
</f></getValue>
		<exit public="1" set="method" line="70" static="1"><f a=""><x path="Void"/></f></exit>
		<get_width set="method" line="75" static="1"><f a=""><x path="Int"/></f></get_width>
		<get_height set="method" line="76" static="1"><f a=""><x path="Int"/></f></get_height>
		<get_lang set="method" line="77" static="1"><f a=""><c path="String"/></f></get_lang>
		<get_platform set="method" line="78" static="1"><f a=""><e path="hxd.Platform"/></f></get_platform>
		<get_screenDPI set="method" line="79" static="1"><f a=""><x path="Int"/></f></get_screenDPI>
		<get_allowTimeout set="method" line="80" static="1"><f a=""><x path="Bool"/></f></get_allowTimeout>
		<set_allowTimeout set="method" line="81" static="1"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowTimeout>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.Timer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Timer.hx">
		<wantedFPS public="1" expr="60." line="14" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>60.</e></m></meta>
			<haxe_doc>The FPS on which "tmod" have values are based on.
		Can be freely configured if your gameplay runs at a different speed.
		Default : 60</haxe_doc>
		</wantedFPS>
		<maxDeltaTime public="1" expr="0.5" line="21" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
			<haxe_doc>The maximum amount of time between two frames (in seconds).
		If the time exceed this amount, Timer will consider these lags are to be ignored.
		Default : 0.5</haxe_doc>
		</maxDeltaTime>
		<smoothFactor public="1" expr="0.95" line="28" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.95</e></m></meta>
			<haxe_doc>The smoothing done between frames. A smoothing of 0 gives "real time" values, higher values will smooth
		the results for tmod/dt/fps over frames using the formula   dt = lerp(dt, elapsedTime, smoothFactor)
		Default : 0 on HashLink, 0.95 on other platforms</haxe_doc>
		</smoothFactor>
		<lastTimeStamp public="1" set="null" expr="haxe.Timer.stamp()" line="33" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>haxe.Timer.stamp()</e></m></meta>
			<haxe_doc>The last timestamp in which update() function was called.</haxe_doc>
		</lastTimeStamp>
		<elapsedTime public="1" set="null" expr="0." line="38" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
			<haxe_doc>The amount of time (unsmoothed) that was spent since the last frame.</haxe_doc>
		</elapsedTime>
		<frameCount public="1" expr="0" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>A frame counter, increases on each call to update()</haxe_doc>
		</frameCount>
		<dt public="1" expr="1 / wantedFPS" line="49" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1 / wantedFPS</e></m></meta>
			<haxe_doc>The smoothed elapsed time (in seconds).</haxe_doc>
		</dt>
		<tmod public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<haxe_doc>The smoothed frame modifier, based on wantedFPS. Its value is the same as dt/wantedFPS
		Allows to express movements in terms of pixels-per-frame-at-wantedFPS instead of per second.</haxe_doc>
		</tmod>
		<currentDT expr="1 / wantedFPS" line="57" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1 / wantedFPS</e></m></meta>
		</currentDT>
		<update public="1" set="method" line="62" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Update the timer calculus on each frame. This is automatically called by hxd.App</haxe_doc>
		</update>
		<get_tmod get="inline" set="null" line="74" static="1"><f a=""><x path="Float"/></f></get_tmod>
		<set_tmod get="inline" set="null" line="78" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_tmod>
		<fps public="1" set="method" line="86" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>The current smoothed FPS.</haxe_doc>
		</fps>
		<skip public="1" set="method" line="95" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>After some loading / long processing, call skip() in order to prevent
		it from impacting your smoothed values.</haxe_doc>
		</skip>
		<reset public="1" set="method" line="103" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Similar as skip() but also reset dt to default value.
		Can be used when starting a new game if you want to discard any previous measurement.</haxe_doc>
		</reset>
		<haxe_doc>The Timer class acts as a global time measurement that can be accessed from various parts of the engine.
	These three values are representation of the same underlying calculus: tmod, dt, fps</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxd.UString" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/UString.hx"><c path="String"/></typedef>
	<class path="hxd.Window" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/Window.hx">
		<inst expr="null" line="65" static="1">
			<c path="hxd.Window"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</inst>
		<getInstance public="1" set="method" line="66" static="1"><f a=""><c path="hxd.Window"/></f></getInstance>
		<resizeEvents><t path="List"><f a=""><x path="Void"/></f></t></resizeEvents>
		<eventTargets><t path="List"><f a="">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></t></eventTargets>
		<width public="1" get="accessor" set="null"><x path="Int"/></width>
		<height public="1" get="accessor" set="null"><x path="Int"/></height>
		<mouseX public="1" get="accessor" set="null"><x path="Int"/></mouseX>
		<mouseY public="1" get="accessor" set="null"><x path="Int"/></mouseY>
		<mouseLock public="1" get="accessor" set="accessor"><x path="Bool"/></mouseLock>
		<vsync public="1" get="accessor" set="accessor"><x path="Bool"/></vsync>
		<isFocused public="1" get="accessor" set="null"><x path="Bool"/></isFocused>
		<onClose public="1" set="dynamic" line="21"><f a=""><x path="Bool"/></f></onClose>
		<event public="1" set="method" line="25"><f a="e">
	<c path="hxd.Event"/>
	<x path="Void"/>
</f></event>
		<addEventTarget public="1" set="method" line="30"><f a="et">
	<f a="">
		<c path="hxd.Event"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></addEventTarget>
		<removeEventTarget public="1" set="method" line="34"><f a="et">
	<f a="">
		<c path="hxd.Event"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></removeEventTarget>
		<addResizeEvent public="1" set="method" line="42"><f a="f">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></addResizeEvent>
		<removeResizeEvent public="1" set="method" line="46"><f a="f">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></removeResizeEvent>
		<onResize set="method" line="54"><f a="e">
	<d/>
	<x path="Void"/>
</f></onResize>
		<resize public="1" set="method" line="59"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<setFullScreen public="1" set="method" line="62"><f a="v">
	<x path="Bool"/>
	<x path="Void"/>
</f></setFullScreen>
		<get_mouseX set="method" line="71"><f a=""><x path="Int"/></f></get_mouseX>
		<get_mouseY set="method" line="75"><f a=""><x path="Int"/></f></get_mouseY>
		<get_width set="method" line="79"><f a=""><x path="Int"/></f></get_width>
		<get_height set="method" line="83"><f a=""><x path="Int"/></f></get_height>
		<get_mouseLock set="method" line="87"><f a=""><x path="Bool"/></f></get_mouseLock>
		<set_mouseLock set="method" line="91"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mouseLock>
		<get_vsync set="method" line="96"><f a=""><x path="Bool"/></f></get_vsync>
		<set_vsync set="method" line="98"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_vsync>
		<get_isFocused set="method" line="103"><f a=""><x path="Bool"/></f></get_isFocused>
		<new set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.earcut.EarNode" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/earcut/Earcut.hx" module="hxd.earcut.Earcut">
		<next public="1"><c path="hxd.earcut.EarNode"/></next>
		<prev public="1"><c path="hxd.earcut.EarNode"/></prev>
		<nextZ public="1"><c path="hxd.earcut.EarNode"/></nextZ>
		<prevZ public="1"><c path="hxd.earcut.EarNode"/></prevZ>
		<allocNext public="1"><c path="hxd.earcut.EarNode"/></allocNext>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<i public="1"><x path="Int"/></i>
		<z public="1"><x path="Int"/></z>
		<steiner public="1"><x path="Bool"/></steiner>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.earcut.Earcut" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/earcut/Earcut.hx">
		<triangles><c path="Array"><x path="Int"/></c></triangles>
		<cache><c path="hxd.earcut.EarNode"/></cache>
		<allocated><c path="hxd.earcut.EarNode"/></allocated>
		<minX><x path="Float"/></minX>
		<minY><x path="Float"/></minY>
		<size><x path="Float"/></size>
		<hasSize><x path="Bool"/></hasSize>
		<triangulate public="1" params="T" set="method" line="34">
			<f a="points:?holes">
				<c path="Array"><c path="triangulate.T"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":generic"/></meta>
		</triangulate>
		<triangulateNode public="1" set="method" line="48"><f a="root:useZOrder">
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
	<c path="Array"><x path="Int"/></c>
</f></triangulateNode>
		<setLinkedList params="T" set="method" line="90">
			<f a="points:start:end:clockwise">
				<c path="Array"><c path="setLinkedList.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="hxd.earcut.EarNode"/>
			</f>
			<meta><m n=":generic"/></meta>
		</setLinkedList>
		<eliminateHoles params="T" set="method" line="124">
			<f a="points:holes:root">
				<c path="Array"><c path="eliminateHoles.T"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="hxd.earcut.EarNode"/>
				<c path="hxd.earcut.EarNode"/>
			</f>
			<meta><m n=":generic"/></meta>
		</eliminateHoles>
		<eliminateHole set="method" line="147"><f a="hole:root">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Void"/>
</f></eliminateHole>
		<findHoleBridge set="method" line="156"><f a="hole:root">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
</f></findHoleBridge>
		<getLeftmost set="method" line="201"><f a="node">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
</f></getLeftmost>
		<compareX get="inline" set="null" line="212"><f a="a:b">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Int"/>
</f></compareX>
		<equals get="inline" set="null" line="216"><f a="p1:p2">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></equals>
		<area get="inline" set="null" line="220"><f a="p:q:r">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Float"/>
</f></area>
		<intersects get="inline" set="null" line="224"><f a="p1:q1:p2:q2">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></intersects>
		<locallyInside get="inline" set="null" line="229"><f a="a:b">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></locallyInside>
		<filterPoints set="method" line="235">
			<f a="start:?end" v=":null">
				<c path="hxd.earcut.EarNode"/>
				<c path="hxd.earcut.EarNode"/>
				<c path="hxd.earcut.EarNode"/>
			</f>
			<meta><m n=":value"><e>{ end : null }</e></m></meta>
		</filterPoints>
		<removeNode get="inline" set="null" line="253"><f a="p">
	<c path="hxd.earcut.EarNode"/>
	<x path="Void"/>
</f></removeNode>
		<allocNode get="inline" set="null" line="260">
			<f a="i:x:y:?last" v=":::null">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="hxd.earcut.EarNode"/>
				<c path="hxd.earcut.EarNode"/>
			</f>
			<meta><m n=":value"><e>{ last : null }</e></m></meta>
		</allocNode>
		<earcutLinked set="method" line="282">
			<f a="ear:?pass" v=":0">
				<c path="hxd.earcut.EarNode"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ pass : 0 }</e></m></meta>
		</earcutLinked>
		<isEar set="method" line="333"><f a="ear">
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></isEar>
		<isEarHashed set="method" line="352"><f a="ear">
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></isEarHashed>
		<cureLocalIntersections set="method" line="393"><f a="start">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
</f></cureLocalIntersections>
		<splitEarcut set="method" line="419"><f a="start">
	<c path="hxd.earcut.EarNode"/>
	<x path="Void"/>
</f></splitEarcut>
		<splitPolygon set="method" line="446"><f a="a:b">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
</f></splitPolygon>
		<pointInTriangle get="inline" set="null" line="467"><f a="ax:ay:bx:by:cx:cy:px:py">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></pointInTriangle>
		<isValidDiagonal set="method" line="474"><f a="a:b">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></isValidDiagonal>
		<middleInside set="method" line="480"><f a="a:b">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></middleInside>
		<intersectsPolygon set="method" line="495"><f a="a:b">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
	<x path="Bool"/>
</f></intersectsPolygon>
		<zOrder get="inline" set="null" line="505"><f a="px:py">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></zOrder>
		<indexCurve set="method" line="523"><f a="start">
	<c path="hxd.earcut.EarNode"/>
	<x path="Void"/>
</f></indexCurve>
		<sortLinked set="method" line="538"><f a="list">
	<c path="hxd.earcut.EarNode"/>
	<c path="hxd.earcut.EarNode"/>
</f></sortLinked>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Ported from https://github.com/mapbox/earcut by @ncannasse</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.bfnt.FontParser" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/bfnt/FontParser.hx">
		<parse public="1" set="method" line="12" static="1">
			<f a="bytes:path:resolveTile">
				<c path="haxe.io.Bytes"/>
				<c path="String"/>
				<f a="">
					<c path="String"/>
					<c path="h2d.Tile"/>
				</f>
				<c path="h2d.Font"/>
			</f>
			<meta><m n=":access"><e>h2d.Font</e></m></meta>
		</parse>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.bfnt.Reader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/bfnt/Reader.hx">
		<parse public="1" get="inline" set="null" line="47" static="1"><f a="bytes:resolveTile">
	<c path="haxe.io.Bytes"/>
	<f a="">
		<c path="String"/>
		<c path="h2d.Tile"/>
	</f>
	<c path="h2d.Font"/>
</f></parse>
		<i><c path="haxe.io.Input"/></i>
		<read public="1" set="method" line="14"><f a="resolveTile">
	<f a="">
		<c path="String"/>
		<c path="h2d.Tile"/>
	</f>
	<c path="h2d.Font"/>
</f></read>
		<new public="1" set="method" line="10"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>h2d.Font</e></m>
		</meta>
	</class>
	<class path="hxd.fmt.bfnt.Writer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/bfnt/Writer.hx">
		<VERSION get="inline" set="null" expr="1" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</VERSION>
		<out><c path="haxe.io.Output"/></out>
		<write public="1" set="method" line="26"><f a="font">
	<c path="h2d.Font"/>
	<x path="Void"/>
</f></write>
		<writeString get="inline" set="null" line="76"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></writeString>
		<new public="1" set="method" line="22"><f a="out">
	<c path="haxe.io.Output"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>h2d.Font</e></m>
		</meta>
	</class>
	<class path="hxd.fmt.fbx.TmpObject" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/BaseLibrary.hx" module="hxd.fmt.fbx.BaseLibrary">
		<index public="1"><x path="Int"/></index>
		<model public="1"><t path="hxd.fmt.fbx.FbxNode"/></model>
		<parent public="1"><c path="hxd.fmt.fbx.TmpObject"/></parent>
		<isJoint public="1"><x path="Bool"/></isJoint>
		<isMesh public="1"><x path="Bool"/></isMesh>
		<childs public="1"><c path="Array"><c path="hxd.fmt.fbx.TmpObject"/></c></childs>
		<obj public="1"><c path="h3d.scene.Object"/></obj>
		<joint public="1"><c path="h3d.anim.Joint"/></joint>
		<skin public="1"><c path="hxd.fmt.fbx.TmpObject"/></skin>
		<new public="1" set="method" line="24"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.fbx._BaseLibrary.AnimCurve" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/BaseLibrary.hx" private="1" module="hxd.fmt.fbx.BaseLibrary">
		<def public="1"><c path="hxd.fmt.fbx.DefaultMatrixes"/></def>
		<object public="1"><c path="String"/></object>
		<t public="1"><a>
	<z><c path="Array"><x path="Float"/></c></z>
	<y><c path="Array"><x path="Float"/></c></y>
	<x><c path="Array"><x path="Float"/></c></x>
	<t><c path="Array"><x path="Float"/></c></t>
</a></t>
		<r public="1"><a>
	<z><c path="Array"><x path="Float"/></c></z>
	<y><c path="Array"><x path="Float"/></c></y>
	<x><c path="Array"><x path="Float"/></c></x>
	<t><c path="Array"><x path="Float"/></c></t>
</a></r>
		<s public="1"><a>
	<z><c path="Array"><x path="Float"/></c></z>
	<y><c path="Array"><x path="Float"/></c></y>
	<x><c path="Array"><x path="Float"/></c></x>
	<t><c path="Array"><x path="Float"/></c></t>
</a></s>
		<a public="1"><a>
	<v><c path="Array"><x path="Float"/></c></v>
	<t><c path="Array"><x path="Float"/></c></t>
</a></a>
		<fov public="1"><a>
	<v><c path="Array"><x path="Float"/></c></v>
	<t><c path="Array"><x path="Float"/></c></t>
</a></fov>
		<roll public="1"><a>
	<v><c path="Array"><x path="Float"/></c></v>
	<t><c path="Array"><x path="Float"/></c></t>
</a></roll>
		<uv public="1"><c path="Array"><a>
	<v><x path="Float"/></v>
	<u><x path="Float"/></u>
	<t><x path="Float"/></t>
</a></c></uv>
		<new public="1" set="method" line="39"><f a="def:object">
	<c path="hxd.fmt.fbx.DefaultMatrixes"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.fbx.DefaultMatrixes" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/BaseLibrary.hx" module="hxd.fmt.fbx.BaseLibrary">
		<rightHandToLeft public="1" get="inline" set="null" line="55" static="1"><f a="m">
	<c path="h3d.Matrix"/>
	<x path="Void"/>
</f></rightHandToLeft>
		<trans public="1"><x path="Null"><c path="h3d.col.Point"/></x></trans>
		<scale public="1"><x path="Null"><c path="h3d.col.Point"/></x></scale>
		<rotate public="1"><x path="Null"><c path="h3d.col.Point"/></x></rotate>
		<preRot public="1"><x path="Null"><c path="h3d.col.Point"/></x></preRot>
		<wasRemoved public="1"><x path="Null"><x path="Int"/></x></wasRemoved>
		<toMatrix public="1" set="method" line="67"><f a="leftHand">
	<x path="Bool"/>
	<c path="h3d.Matrix"/>
</f></toMatrix>
		<toQuaternion public="1" set="method" line="78"><f a="leftHand">
	<x path="Bool"/>
	<c path="h3d.Quat"/>
</f></toQuaternion>
		<new public="1" set="method" line="52"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.fbx.BaseLibrary" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/BaseLibrary.hx">
		<root><t path="hxd.fmt.fbx.FbxNode"/></root>
		<ids><t path="Map">
	<x path="Int"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
</t></ids>
		<connect><t path="Map">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</t></connect>
		<namedConnect><t path="Map">
	<x path="Int"/>
	<t path="Map">
		<c path="String"/>
		<x path="Int"/>
	</t>
</t></namedConnect>
		<invConnect><t path="Map">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</t></invConnect>
		<leftHand><x path="Bool"/></leftHand>
		<defaultModelMatrixes><t path="Map">
	<c path="String"/>
	<c path="hxd.fmt.fbx.DefaultMatrixes"/>
</t></defaultModelMatrixes>
		<uvAnims><t path="Map">
	<c path="String"/>
	<c path="Array"><a>
	<v><x path="Float"/></v>
	<u><x path="Float"/></u>
	<t><x path="Float"/></t>
</a></c>
</t></uvAnims>
		<animationEvents><c path="Array"><a>
	<frame><x path="Int"/></frame>
	<data><c path="String"/></data>
</a></c></animationEvents>
		<fileName public="1"><c path="String"/></fileName>
		<version public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
			<haxe_doc>The FBX version that was decoded</haxe_doc>
		</version>
		<keepJoints public="1">
			<t path="Map">
				<c path="String"/>
				<x path="Bool"/>
			</t>
			<haxe_doc>Allows to prevent some terminal unskinned joints to be removed, for instance if we want to track their position</haxe_doc>
		</keepJoints>
		<skipObjects public="1">
			<t path="Map">
				<c path="String"/>
				<x path="Bool"/>
			</t>
			<haxe_doc>Allows to skip some objects from being processed as if they were not part of the FBX</haxe_doc>
		</skipObjects>
		<bonesPerVertex public="1" expr="3">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
			<haxe_doc>Set how many bones per vertex should be created in skin data in makeObject(). Default is 3</haxe_doc>
		</bonesPerVertex>
		<maxBonesPerSkin public="1" expr="34">
			<x path="Int"/>
			<meta><m n=":value"><e>34</e></m></meta>
			<haxe_doc>If there are too many bones, the model will be split in separate render passes.</haxe_doc>
		</maxBonesPerSkin>
		<unskinnedJointsAsObjects public="1">
			<x path="Bool"/>
			<haxe_doc>Consider unskinned joints to be simple objects</haxe_doc>
		</unskinnedJointsAsObjects>
		<allowVertexColor public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</allowVertexColor>
		<normalizeScaleOrient public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>Convert centimeters to meters and axis to Z-up (Maya FBX export)</haxe_doc>
		</normalizeScaleOrient>
		<reset set="method" line="150"><f a=""><x path="Void"/></f></reset>
		<loadFile public="1" set="method" line="158"><f a="data">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></loadFile>
		<load public="1" set="method" line="162"><f a="root">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Void"/>
</f></load>
		<updateModelScale set="method" line="203"><f a=""><x path="Void"/></f></updateModelScale>
		<convertPoints set="method" line="310"><f a="a">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></convertPoints>
		<leftHandConvert public="1" set="method" line="318"><f a=""><x path="Void"/></f></leftHandConvert>
		<init set="method" line="333"><f a="n">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Void"/>
</f></init>
		<getGeometry public="1" set="method" line="383">
			<f a="?name" v="&quot;&quot;">
				<c path="String"/>
				<c path="hxd.fmt.fbx.Geometry"/>
			</f>
			<meta><m n=":value"><e>{ name : "" }</e></m></meta>
		</getGeometry>
		<getParent public="1" set="method" line="395"><f a="node:nodeName:?opt">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Null"><t path="hxd.fmt.fbx.FbxNode"/></x>
</f></getParent>
		<getChild public="1" set="method" line="404"><f a="node:nodeName:?opt">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Null"><t path="hxd.fmt.fbx.FbxNode"/></x>
</f></getChild>
		<getSpecChild public="1" set="method" line="413"><f a="node:name">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<x path="Null"><t path="hxd.fmt.fbx.FbxNode"/></x>
</f></getSpecChild>
		<getChilds public="1" set="method" line="423"><f a="node:?nodeName">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<c path="Array"><x path="Null"><t path="hxd.fmt.fbx.FbxNode"/></x></c>
</f></getChilds>
		<getParents public="1" set="method" line="436"><f a="node:?nodeName">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<c path="Array"><x path="Null"><t path="hxd.fmt.fbx.FbxNode"/></x></c>
</f></getParents>
		<getRoot public="1" set="method" line="449"><f a=""><t path="hxd.fmt.fbx.FbxNode"/></f></getRoot>
		<ignoreMissingObject public="1" set="method" line="453"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></ignoreMissingObject>
		<buildHierarchy set="method" line="462"><f a=""><a>
	<root><c path="hxd.fmt.fbx.TmpObject"/></root>
	<objects><c path="Array"><c path="hxd.fmt.fbx.TmpObject"/></c></objects>
</a></f></buildHierarchy>
		<getObjectCurve set="method" line="572"><f a="curves:model:curveName:animName">
	<t path="Map">
		<x path="Int"/>
		<c path="hxd.fmt.fbx._BaseLibrary.AnimCurve"/>
	</t>
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<c path="String"/>
	<c path="hxd.fmt.fbx._BaseLibrary.AnimCurve"/>
</f></getObjectCurve>
		<mergeModels public="1" set="method" line="604"><f a="modelNames">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></mergeModels>
		<addLink set="method" line="682"><f a="parent:child">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Void"/>
</f></addLink>
		<removeLink set="method" line="689"><f a="parent:child">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Void"/>
</f></removeLink>
		<checkData set="method" line="696"><f a="t">
	<a>
		<z><c path="Array"><x path="Float"/></c></z>
		<y><c path="Array"><x path="Float"/></c></y>
		<x><c path="Array"><x path="Float"/></c></x>
	</a>
	<x path="Bool"/>
</f></checkData>
		<roundValues set="method" line="720">
			<f a="data:def:?mult" v="::1.">
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ mult : 1. }</e></m></meta>
		</roundValues>
		<getAnimationNames public="1" set="method" line="736">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns an array of names with all animations present in FBX file.</haxe_doc>
		</getAnimationNames>
		<loadAnimation public="1" set="method" line="745"><f a="?animName:?root:?lib">
	<c path="String"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="hxd.fmt.fbx.BaseLibrary"/>
	<c path="h3d.anim.Animation"/>
</f></loadAnimation>
		<sortDistinctFloats set="method" line="1156"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></sortDistinctFloats>
		<isNullJoint set="method" line="1160"><f a="model">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Bool"/>
</f></isNullJoint>
		<getModelPath set="method" line="1172"><f a="model">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Null"><c path="String"/></x>
</f></getModelPath>
		<autoMerge set="method" line="1180"><f a=""><x path="Void"/></f></autoMerge>
		<keepJoint set="method" line="1230"><f a="j">
	<c path="h3d.anim.Joint"/>
	<x path="Bool"/>
</f></keepJoint>
		<createSkin set="method" line="1234"><f a="hskins:hgeom:rootJoints:bonesPerVertex">
	<t path="Map">
		<x path="Int"/>
		<c path="h3d.anim.Skin"/>
	</t>
	<t path="Map">
		<x path="Int"/>
		<a>
			<vertexCount set="method"><f a=""><x path="Int"/></f></vertexCount>
			<setSkin set="method"><f a="s">
	<c path="h3d.anim.Skin"/>
	<x path="Void"/>
</f></setSkin>
		</a>
	</t>
	<c path="Array"><c path="h3d.anim.Joint"/></c>
	<x path="Int"/>
	<x path="Null"><c path="h3d.anim.Skin"/></x>
</f></createSkin>
		<round set="method" line="1304"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></round>
		<getDefaultMatrixes set="method" line="1309"><f a="model">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Null"><c path="hxd.fmt.fbx.DefaultMatrixes"/></x>
</f></getDefaultMatrixes>
		<new public="1" set="method" line="142"><f a="fileName">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="hxd.fmt.fbx.FbxProp" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/Data.hx" module="hxd.fmt.fbx.Data">
		<PInt a="v"><x path="Int"/></PInt>
		<PFloat a="v"><x path="Float"/></PFloat>
		<PString a="v"><c path="String"/></PString>
		<PIdent a="i"><c path="String"/></PIdent>
		<PInts a="v"><c path="Array"><x path="Int"/></c></PInts>
		<PFloats a="v"><c path="Array"><x path="Float"/></c></PFloats>
		<PBinary a="v"><c path="haxe.io.Bytes"/></PBinary>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hxd.fmt.fbx.FbxNode" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/Data.hx" module="hxd.fmt.fbx.Data"><a>
	<props><c path="Array"><e path="hxd.fmt.fbx.FbxProp"/></c></props>
	<name><c path="String"/></name>
	<childs><c path="Array"><t path="hxd.fmt.fbx.FbxNode"/></c></childs>
</a></typedef>
	<class path="hxd.fmt.fbx.FbxTools" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/Data.hx" module="hxd.fmt.fbx.Data">
		<get public="1" set="method" line="21" static="1">
			<f a="n:path:?opt" v="::false">
				<t path="hxd.fmt.fbx.FbxNode"/>
				<c path="String"/>
				<x path="Bool"/>
				<t path="hxd.fmt.fbx.FbxNode"/>
			</f>
			<meta><m n=":value"><e>{ opt : false }</e></m></meta>
		</get>
		<getAll public="1" set="method" line="41" static="1"><f a="n:path">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
	<c path="Array"><t path="hxd.fmt.fbx.FbxNode"/></c>
</f></getAll>
		<getInts public="1" set="method" line="57" static="1"><f a="n">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="Array"><x path="Int"/></c>
</f></getInts>
		<getFloats public="1" set="method" line="68" static="1"><f a="n">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="Array"><x path="Float"/></c>
</f></getFloats>
		<hasProp public="1" set="method" line="87" static="1"><f a="n:p">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<e path="hxd.fmt.fbx.FbxProp"/>
	<x path="Bool"/>
</f></hasProp>
		<idToInt get="inline" set="null" line="94" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></idToInt>
		<toInt public="1" set="method" line="106" static="1"><f a="n">
	<e path="hxd.fmt.fbx.FbxProp"/>
	<x path="Int"/>
</f></toInt>
		<toFloat public="1" set="method" line="115" static="1"><f a="n">
	<e path="hxd.fmt.fbx.FbxProp"/>
	<x path="Float"/>
</f></toFloat>
		<toString public="1" set="method" line="124" static="1"><f a="n">
	<e path="hxd.fmt.fbx.FbxProp"/>
	<c path="String"/>
</f></toString>
		<toBinary public="1" set="method" line="132" static="1"><f a="n">
	<e path="hxd.fmt.fbx.FbxProp"/>
	<c path="haxe.io.Bytes"/>
</f></toBinary>
		<getId public="1" set="method" line="140" static="1"><f a="n">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Int"/>
</f></getId>
		<getName public="1" set="method" line="150" static="1"><f a="n">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Null"><c path="String"/></x>
</f></getName>
		<getType public="1" set="method" line="159" static="1"><f a="n">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
</f></getType>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.fbx.Geometry" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/Geometry.hx">
		<lib><c path="hxd.fmt.fbx.BaseLibrary"/></lib>
		<root><t path="hxd.fmt.fbx.FbxNode"/></root>
		<getRoot public="1" set="method" line="14"><f a=""><t path="hxd.fmt.fbx.FbxNode"/></f></getRoot>
		<getVertices public="1" set="method" line="18"><f a=""><c path="Array"><x path="Float"/></c></f></getVertices>
		<getPolygons public="1" set="method" line="22"><f a=""><c path="Array"><x path="Int"/></c></f></getPolygons>
		<getMaterials public="1" set="method" line="26"><f a=""><x path="Null"><c path="Array"><x path="Int"/></c></x></f></getMaterials>
		<getMaterialByTriangle public="1" set="method" line="31"><f a=""><c path="Array"><x path="Int"/></c></f></getMaterialByTriangle>
		<merge public="1" set="method" line="48"><f a="g:materials">
	<c path="hxd.fmt.fbx.Geometry"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></merge>
		<getIndexes public="1" set="method" line="148">
			<f a=""><a>
	<vidx><c path="Array"><x path="Int"/></c></vidx>
	<idx><c path="Array"><x path="Int"/></c></idx>
</a></f>
			<haxe_doc>Decode polygon informations into triangle indexes and vertices indexes.
		Returns vidx, which is the list of vertices indexes and iout which is the index buffer for the full vertex model</haxe_doc>
		</getIndexes>
		<getNormals public="1" set="method" line="172"><f a=""><c path="Array"><x path="Float"/></c></f></getNormals>
		<getTangents public="1" set="method" line="176">
			<f a="?opt" v="false">
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ opt : false }</e></m></meta>
		</getTangents>
		<getBinormals public="1" set="method" line="180">
			<f a="?opt" v="false">
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ opt : false }</e></m></meta>
		</getBinormals>
		<processVectors set="method" line="184">
			<f a="layer:name:?opt" v="::false">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ opt : false }</e></m></meta>
		</processVectors>
		<getColors public="1" set="method" line="204"><f a=""><x path="Null"><a>
	<values><c path="Array"><x path="Float"/></c></values>
	<index><c path="Array"><x path="Int"/></c></index>
</a></x></f></getColors>
		<getUVs public="1" set="method" line="209"><f a=""><c path="Array"><a>
	<values><c path="Array"><x path="Float"/></c></values>
	<index><c path="Array"><x path="Int"/></c></index>
</a></c></f></getUVs>
		<getGeomMatrix public="1" set="method" line="224">
			<f a=""><c path="h3d.Matrix"/></f>
			<meta><m n=":access"><e>hxd.fmt.fbx.BaseLibrary.leftHand</e></m></meta>
		</getGeomMatrix>
		<new public="1" set="method" line="9"><f a="l:root">
	<c path="hxd.fmt.fbx.BaseLibrary"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.fbx.HMDOut" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/HMDOut.hx">
		<extends path="hxd.fmt.fbx.BaseLibrary"/>
		<d><c path="hxd.fmt.hmd.Data"/></d>
		<dataOut><c path="haxe.io.BytesOutput"/></dataOut>
		<filePath><c path="String"/></filePath>
		<tmp expr="haxe.io.Bytes.alloc(4)">
			<c path="haxe.io.Bytes"/>
			<meta><m n=":value"><e>haxe.io.Bytes.alloc(4)</e></m></meta>
		</tmp>
		<absoluteTexturePath public="1"><x path="Bool"/></absoluteTexturePath>
		<optimizeSkin public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</optimizeSkin>
		<floatSkinIndexes public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</floatSkinIndexes>
		<int32tof set="method" line="20"><f a="v">
	<x path="Int"/>
	<x path="Float"/>
</f></int32tof>
		<keepJoint set="method" line="28" override="1"><f a="j">
	<c path="h3d.anim.Joint"/>
	<x path="Bool"/>
</f></keepJoint>
		<buildTangents set="method" line="37"><f a="geom">
	<c path="hxd.fmt.fbx.Geometry"/>
	<c path="Array"><x path="Float"/></c>
</f></buildTangents>
		<buildGeom set="method" line="128"><f a="geom:skin:dataOut:genTangents">
	<c path="hxd.fmt.fbx.Geometry"/>
	<c path="h3d.anim.Skin"/>
	<c path="haxe.io.BytesOutput"/>
	<x path="Bool"/>
	<a>
		<materials><c path="Array"><x path="Int"/></c></materials>
		<g><c path="hxd.fmt.hmd.Geometry"/></g>
	</a>
</f></buildGeom>
		<addModels set="method" line="359"><f a="includeGeometry">
	<x path="Bool"/>
	<x path="Void"/>
</f></addModels>
		<makeTexturePath set="method" line="629"><f a="tex">
	<t path="hxd.fmt.fbx.FbxNode"/>
	<c path="String"/>
</f></makeTexturePath>
		<makeSkin set="method" line="651"><f a="skin:obj">
	<c path="h3d.anim.Skin"/>
	<c path="hxd.fmt.fbx.TmpObject"/>
	<c path="hxd.fmt.hmd.Skin"/>
</f></makeSkin>
		<makePosition set="method" line="690"><f a="m">
	<c path="h3d.Matrix"/>
	<c path="hxd.fmt.hmd.Position"/>
</f></makePosition>
		<writeFloat get="inline" set="null" line="709"><f a="f">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<makeAnimation set="method" line="713"><f a="anim">
	<c path="h3d.anim.Animation"/>
	<c path="hxd.fmt.hmd.Animation"/>
</f></makeAnimation>
		<toHMD public="1" set="method" line="780"><f a="filePath:includeGeometry">
	<c path="String"/>
	<x path="Bool"/>
	<c path="hxd.fmt.hmd.Data"/>
</f></toHMD>
		<new public="1" set="method" line="6"><f a="fileName">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.fmt.fbx._Parser.Token" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/Parser.hx" private="1" module="hxd.fmt.fbx.Parser">
		<TIdent a="s"><c path="String"/></TIdent>
		<TNode a="s"><c path="String"/></TNode>
		<TInt a="s"><c path="String"/></TInt>
		<TFloat a="s"><c path="String"/></TFloat>
		<TString a="s"><c path="String"/></TString>
		<TLength a="v"><x path="Int"/></TLength>
		<TBraceOpen/>
		<TBraceClose/>
		<TColon/>
		<TEof/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="hxd.fmt.fbx.Parser" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/fbx/Parser.hx">
		<parse public="1" set="method" line="501" static="1"><f a="data">
	<c path="haxe.io.Bytes"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
</f></parse>
		<line><x path="Int"/></line>
		<buf><c path="String"/></buf>
		<bytes><c path="haxe.io.Bytes"/></bytes>
		<pos><x path="Int"/></pos>
		<token><x path="Null"><e path="hxd.fmt.fbx._Parser.Token"/></x></token>
		<binary><x path="Bool"/></binary>
		<fbxVersion><x path="Int"/></fbxVersion>
		<parseText set="method" line="31"><f a="str">
	<c path="String"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
</f></parseText>
		<parseBytes set="method" line="44"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
</f></parseBytes>
		<parseNodes set="method" line="87"><f a=""><c path="Array"><t path="hxd.fmt.fbx.FbxNode"/></c></f></parseNodes>
		<parseNode set="method" line="100"><f a=""><t path="hxd.fmt.fbx.FbxNode"/></f></parseNode>
		<parseBinaryNodes set="method" line="176"><f a="output">
	<c path="Array"><t path="hxd.fmt.fbx.FbxNode"/></c>
	<x path="Void"/>
</f></parseBinaryNodes>
		<parseBinaryNode set="method" line="185"><f a="nextRecord">
	<x path="Int"/>
	<t path="hxd.fmt.fbx.FbxNode"/>
</f></parseBinaryNode>
		<readBinaryProperty set="method" line="212"><f a=""><e path="hxd.fmt.fbx.FbxProp"/></f></readBinaryProperty>
		<except set="method" line="319"><f a="except">
	<e path="hxd.fmt.fbx._Parser.Token"/>
	<x path="Void"/>
</f></except>
		<peek set="method" line="325"><f a=""><x path="Null"><e path="hxd.fmt.fbx._Parser.Token"/></x></f></peek>
		<next set="method" line="331"><f a=""><e path="hxd.fmt.fbx._Parser.Token"/></f></next>
		<error set="method" line="339"><f a="msg">
	<c path="String"/>
	<d/>
</f></error>
		<unexpected set="method" line="344"><f a="t">
	<e path="hxd.fmt.fbx._Parser.Token"/>
	<d/>
</f></unexpected>
		<tokenStr set="method" line="348"><f a="t">
	<e path="hxd.fmt.fbx._Parser.Token"/>
	<c path="String"/>
</f></tokenStr>
		<nextChar get="inline" set="null" line="363"><f a=""><x path="Int"/></f></nextChar>
		<getVersionedInt32 get="inline" set="null" line="367"><f a=""><x path="Int"/></f></getVersionedInt32>
		<getInt32 get="inline" set="null" line="374"><f a=""><x path="Int"/></f></getInt32>
		<getInt16 get="inline" set="null" line="380"><f a=""><x path="Int"/></f></getInt16>
		<getFloat get="inline" set="null" line="386"><f a=""><x path="Float"/></f></getFloat>
		<getDouble get="inline" set="null" line="392"><f a=""><x path="Float"/></f></getDouble>
		<i64ToFloat get="inline" set="null" line="398"><f a="i64">
	<x path="haxe.Int64"/>
	<x path="Float"/>
</f></i64ToFloat>
		<getByte get="inline" set="null" line="403"><f a=""><x path="Int"/></f></getByte>
		<getBuf get="inline" set="null" line="407"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></getBuf>
		<isIdentChar get="inline" set="null" line="411"><f a="c">
	<x path="Int"/>
	<x path="Bool"/>
</f></isIdentChar>
		<nextToken set="method" line="416">
			<f a=""><e path="hxd.fmt.fbx._Parser.Token"/></f>
			<meta><m n=":noDebug"/></meta>
		</nextToken>
		<new set="method" line="28"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="hxd.fmt.hmd.GeometryDataFormat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="hxd.fmt.hmd._Data.GeometryDataFormat_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" private="1" module="hxd.fmt.hmd.Data">
	<DFloat public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
		<x path="hxd.fmt.hmd.GeometryDataFormat"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DFloat>
	<DVec2 public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
		<x path="hxd.fmt.hmd.GeometryDataFormat"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DVec2>
	<DVec3 public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
		<x path="hxd.fmt.hmd.GeometryDataFormat"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DVec3>
	<DVec4 public="1" get="inline" set="null" expr="cast 4" line="8" static="1">
		<x path="hxd.fmt.hmd.GeometryDataFormat"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DVec4>
	<DBytes4 public="1" get="inline" set="null" expr="cast 9" line="9" static="1">
		<x path="hxd.fmt.hmd.GeometryDataFormat"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DBytes4>
	<_new get="inline" set="null" line="11" static="1">
		<f a="v">
			<x path="Int"/>
			<x path="hxd.fmt.hmd.GeometryDataFormat"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<getSize public="1" get="inline" set="null" line="15" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getSize>
	<toInt public="1" get="inline" set="null" line="19" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toInt>
	<toString public="1" set="method" line="23" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<fromInt public="1" get="inline" set="null" line="33" static="1"><f a="v">
	<x path="Int"/>
	<x path="hxd.fmt.hmd.GeometryDataFormat"/>
</f></fromInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="hxd.fmt.hmd._Data.GeometryDataFormat_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" private="1" module="hxd.fmt.hmd.Data">
		<DFloat public="1" get="inline" set="null" expr="cast 1" line="5" static="1">
			<x path="hxd.fmt.hmd.GeometryDataFormat"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DFloat>
		<DVec2 public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
			<x path="hxd.fmt.hmd.GeometryDataFormat"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DVec2>
		<DVec3 public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
			<x path="hxd.fmt.hmd.GeometryDataFormat"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DVec3>
		<DVec4 public="1" get="inline" set="null" expr="cast 4" line="8" static="1">
			<x path="hxd.fmt.hmd.GeometryDataFormat"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DVec4>
		<DBytes4 public="1" get="inline" set="null" expr="cast 9" line="9" static="1">
			<x path="hxd.fmt.hmd.GeometryDataFormat"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DBytes4>
		<_new get="inline" set="null" line="11" static="1">
			<f a="v">
				<x path="Int"/>
				<x path="hxd.fmt.hmd.GeometryDataFormat"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<getSize public="1" get="inline" set="null" line="15" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getSize>
		<toInt public="1" get="inline" set="null" line="19" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toInt>
		<toString public="1" set="method" line="23" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<fromInt public="1" get="inline" set="null" line="33" static="1"><f a="v">
	<x path="Int"/>
	<x path="hxd.fmt.hmd.GeometryDataFormat"/>
</f></fromInt>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="hxd.fmt.hmd.DataPosition" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data"><x path="Int"/></typedef>
	<typedef path="hxd.fmt.hmd.Index" params="T" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data"><x path="Int"/></typedef>
	<enum path="hxd.fmt.hmd.Property" params="T" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<CameraFOVY a="v"><x path="Float"/></CameraFOVY>
		<Unused_HasMaterialFlags/>
		<HasExtraTextures/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hxd.fmt.hmd.Properties" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data"><x path="Null"><c path="Array"><e path="hxd.fmt.hmd.Property"><d/></e></c></x></typedef>
	<class path="hxd.fmt.hmd.Position" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<QTMP expr="new h3d.Quat()" line="91" static="1">
			<c path="h3d.Quat"/>
			<meta><m n=":value"><e>new h3d.Quat()</e></m></meta>
		</QTMP>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<qx public="1"><x path="Float"/></qx>
		<qy public="1"><x path="Float"/></qy>
		<qz public="1"><x path="Float"/></qz>
		<qw public="1" get="accessor" set="null"><x path="Float"/></qw>
		<sx public="1"><x path="Float"/></sx>
		<sy public="1"><x path="Float"/></sy>
		<sz public="1"><x path="Float"/></sz>
		<loadQuaternion public="1" get="inline" set="null" line="63"><f a="q">
	<c path="h3d.Quat"/>
	<x path="Void"/>
</f></loadQuaternion>
		<get_qw set="method" line="70"><f a=""><x path="Float"/></f></get_qw>
		<toMatrix public="1" set="method" line="75">
			<f a="?postScale" v="false">
				<x path="Bool"/>
				<c path="h3d.Matrix"/>
			</f>
			<meta><m n=":value"><e>{ postScale : false }</e></m></meta>
		</toMatrix>
		<new public="1" set="method" line="60"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.GeometryFormat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<format public="1"><x path="hxd.fmt.hmd.GeometryDataFormat"/></format>
		<new public="1" set="method" line="97"><f a="name:format">
	<c path="String"/>
	<x path="hxd.fmt.hmd.GeometryDataFormat"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Geometry" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<vertexCount public="1"><x path="Int"/></vertexCount>
		<vertexStride public="1"><x path="Int"/></vertexStride>
		<vertexFormat public="1"><c path="Array"><c path="hxd.fmt.hmd.GeometryFormat"/></c></vertexFormat>
		<vertexPosition public="1"><t path="hxd.fmt.hmd.DataPosition"/></vertexPosition>
		<indexCount public="1" get="accessor" set="null"><x path="Int"/></indexCount>
		<indexCounts public="1"><c path="Array"><x path="Int"/></c></indexCounts>
		<indexPosition public="1"><t path="hxd.fmt.hmd.DataPosition"/></indexPosition>
		<bounds public="1"><c path="h3d.col.Bounds"/></bounds>
		<get_indexCount set="method" line="115"><f a=""><x path="Int"/></f></get_indexCount>
		<new public="1" set="method" line="113"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Material" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<diffuseTexture public="1"><x path="Null"><c path="String"/></x></diffuseTexture>
		<specularTexture public="1"><x path="Null"><c path="String"/></x></specularTexture>
		<normalMap public="1"><x path="Null"><c path="String"/></x></normalMap>
		<blendMode public="1"><t path="h3d.mat.BlendMode"/></blendMode>
		<new public="1" set="method" line="131"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.SkinJoint" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<parent public="1"><t path="hxd.fmt.hmd.Index"><c path="hxd.fmt.hmd.SkinJoint"/></t></parent>
		<position public="1"><c path="hxd.fmt.hmd.Position"/></position>
		<bind public="1"><x path="Int"/></bind>
		<transpos public="1"><x path="Null"><c path="hxd.fmt.hmd.Position"/></x></transpos>
		<new public="1" set="method" line="142"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.SkinSplit" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<materialIndex public="1"><x path="Int"/></materialIndex>
		<joints public="1"><c path="Array"><t path="hxd.fmt.hmd.Index"><c path="hxd.fmt.hmd.SkinJoint"/></t></c></joints>
		<new public="1" set="method" line="149"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Skin" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<joints public="1"><c path="Array"><c path="hxd.fmt.hmd.SkinJoint"/></c></joints>
		<split public="1"><x path="Null"><c path="Array"><c path="hxd.fmt.hmd.SkinSplit"/></c></x></split>
		<new public="1" set="method" line="158"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Model" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<parent public="1"><t path="hxd.fmt.hmd.Index"><c path="hxd.fmt.hmd.Model"/></t></parent>
		<follow public="1"><x path="Null"><c path="String"/></x></follow>
		<position public="1"><c path="hxd.fmt.hmd.Position"/></position>
		<geometry public="1"><t path="hxd.fmt.hmd.Index"><c path="hxd.fmt.hmd.Geometry"/></t></geometry>
		<materials public="1"><x path="Null"><c path="Array"><t path="hxd.fmt.hmd.Index"><c path="hxd.fmt.hmd.Material"/></t></c></x></materials>
		<skin public="1"><x path="Null"><c path="hxd.fmt.hmd.Skin"/></x></skin>
		<new public="1" set="method" line="171"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.fmt.hmd.AnimationFlag" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<HasPosition/>
		<HasRotation/>
		<HasScale/>
		<HasUV/>
		<HasAlpha/>
		<SinglePosition/>
		<HasProps/>
		<Reserved/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="hxd.fmt.hmd.AnimationObject" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<flags public="1"><x path="haxe.EnumFlags"><e path="hxd.fmt.hmd.AnimationFlag"/></x></flags>
		<props public="1"><c path="Array"><c path="String"/></c></props>
		<new public="1" set="method" line="190"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.AnimationEvent" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<frame public="1"><x path="Int"/></frame>
		<data public="1"><c path="String"/></data>
		<new public="1" set="method" line="197"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Animation" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx" module="hxd.fmt.hmd.Data">
		<name public="1"><c path="String"/></name>
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<frames public="1"><x path="Int"/></frames>
		<sampling public="1"><x path="Float"/></sampling>
		<speed public="1"><x path="Float"/></speed>
		<loop public="1"><x path="Bool"/></loop>
		<objects public="1"><c path="Array"><c path="hxd.fmt.hmd.AnimationObject"/></c></objects>
		<events public="1"><x path="Null"><c path="Array"><c path="hxd.fmt.hmd.AnimationEvent"/></c></x></events>
		<dataPosition public="1"><t path="hxd.fmt.hmd.DataPosition"/></dataPosition>
		<new public="1" set="method" line="211"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Data" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Data.hx">
		<CURRENT_VERSION public="1" get="inline" set="null" expr="2" line="217" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</CURRENT_VERSION>
		<version public="1"><x path="Int"/></version>
		<props public="1"><t path="hxd.fmt.hmd.Properties"/></props>
		<geometries public="1"><c path="Array"><c path="hxd.fmt.hmd.Geometry"/></c></geometries>
		<materials public="1"><c path="Array"><c path="hxd.fmt.hmd.Material"/></c></materials>
		<models public="1"><c path="Array"><c path="hxd.fmt.hmd.Model"/></c></models>
		<animations public="1"><c path="Array"><c path="hxd.fmt.hmd.Animation"/></c></animations>
		<dataPosition public="1"><x path="Int"/></dataPosition>
		<data public="1"><c path="haxe.io.Bytes"/></data>
		<new public="1" set="method" line="228"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxd.fmt.hmd.HideData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Library.hx" module="hxd.fmt.hmd.Library"><a><animations><x path="haxe.DynamicAccess"><a><events><c path="Array"><a>
	<frame><x path="Int"/></frame>
	<data><c path="String"/></data>
</a></c></events></a></x></animations></a></typedef>
	<class path="hxd.fmt.hmd._Library.FormatMap" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Library.hx" private="1" module="hxd.fmt.hmd.Library">
		<size public="1"><x path="Int"/></size>
		<offset public="1"><x path="Int"/></offset>
		<def public="1"><c path="h3d.Vector"/></def>
		<next public="1"><c path="hxd.fmt.hmd._Library.FormatMap"/></next>
		<new public="1" set="method" line="13"><f a="size:offset:def:next">
	<x path="Int"/>
	<x path="Int"/>
	<c path="h3d.Vector"/>
	<c path="hxd.fmt.hmd._Library.FormatMap"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.GeometryBuffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Library.hx" module="hxd.fmt.hmd.Library">
		<vertexes public="1"><x path="haxe.ds.Vector"><t path="hxd.impl.Float32"/></x></vertexes>
		<indexes public="1"><x path="haxe.ds.Vector"><t path="hxd.impl.UInt16"/></x></indexes>
		<new public="1" set="method" line="24"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Library" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Library.hx">
		<resource public="1" set="null"><c path="hxd.res.Resource"/></resource>
		<header public="1" set="null"><c path="hxd.fmt.hmd.Data"/></header>
		<cachedPrimitives><c path="Array"><c path="h3d.prim.HMDModel"/></c></cachedPrimitives>
		<cachedAnimations><t path="Map">
	<c path="String"/>
	<c path="h3d.anim.Animation"/>
</t></cachedAnimations>
		<cachedSkin><t path="Map">
	<c path="String"/>
	<c path="h3d.anim.Skin"/>
</t></cachedSkin>
		<tmp expr="haxe.io.Bytes.alloc(4)">
			<c path="haxe.io.Bytes"/>
			<meta><m n=":value"><e>haxe.io.Bytes.alloc(4)</e></m></meta>
		</tmp>
		<hideData public="1"><t path="hxd.fmt.hmd.HideData"/></hideData>
		<getData public="1" set="method" line="46"><f a=""><c path="haxe.io.Bytes"/></f></getData>
		<getDefaultFormat public="1" set="method" line="56"><f a="stride">
	<x path="Int"/>
	<a>
		<format><c path="Array"><c path="hxd.fmt.hmd.GeometryFormat"/></c></format>
		<defs><c path="Array"><c path="h3d.Vector"/></c></defs>
	</a>
</f></getDefaultFormat>
		<load public="1" set="method" line="78">
			<f a="format:?defaults:?modelIndex" v="::-1">
				<c path="Array"><c path="hxd.fmt.hmd.GeometryFormat"/></c>
				<c path="Array"><c path="h3d.Vector"/></c>
				<x path="Int"/>
				<a>
					<vertex><x path="hxd.FloatBuffer"/></vertex>
					<index><x path="hxd.IndexBuffer"/></index>
				</a>
			</f>
			<meta><m n=":value"><e>{ modelIndex : -1 }</e></m></meta>
		</load>
		<getBuffers public="1" set="method" line="116">
			<f a="geom:format:?defaults:?material">
				<c path="hxd.fmt.hmd.Geometry"/>
				<c path="Array"><c path="hxd.fmt.hmd.GeometryFormat"/></c>
				<c path="Array"><c path="h3d.Vector"/></c>
				<x path="Int"/>
				<c path="hxd.fmt.hmd.GeometryBuffer"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</getBuffers>
		<makePrimitive set="method" line="258"><f a="id">
	<x path="Int"/>
	<c path="h3d.prim.HMDModel"/>
</f></makePrimitive>
		<makeMaterial set="method" line="266"><f a="model:mid:loadTexture">
	<c path="hxd.fmt.hmd.Model"/>
	<x path="Int"/>
	<f a="">
		<c path="String"/>
		<c path="h3d.mat.Texture"/>
	</f>
	<c path="h3d.mat.Material"/>
</f></makeMaterial>
		<makeSkin set="method" line="287">
			<f a="skin">
				<c path="hxd.fmt.hmd.Skin"/>
				<x path="Null"><c path="h3d.anim.Skin"/></x>
			</f>
			<meta><m n=":access"><e>h3d.anim.Skin</e></m></meta>
		</makeSkin>
		<getModelProperty public="1" params="T" set="method" line="324"><f a="objName:p:?def">
	<c path="String"/>
	<e path="hxd.fmt.hmd.Property"><c path="getModelProperty.T"/></e>
	<c path="getModelProperty.T"/>
	<x path="Null"><c path="getModelProperty.T"/></x>
</f></getModelProperty>
		<makeObject public="1" set="method" line="339"><f a="?loadTexture">
	<f a="">
		<c path="String"/>
		<c path="h3d.mat.Texture"/>
	</f>
	<c path="h3d.scene.Object"/>
</f></makeObject>
		<loadAnimation public="1" set="method" line="370"><f a="?name">
	<c path="String"/>
	<c path="h3d.anim.Animation"/>
</f></loadAnimation>
		<makeAnimation set="method" line="399"><f a="a">
	<c path="hxd.fmt.hmd.Animation"/>
	<c path="h3d.anim.LinearAnimation"/>
</f></makeAnimation>
		<loadSkin public="1" set="method" line="500">
			<f a="geom:skin">
				<c path="hxd.fmt.hmd.Geometry"/>
				<c path="h3d.anim.Skin"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>h3d.anim.Skin</e></m></meta>
		</loadSkin>
		<ftoint32 set="method" line="519"><f a="v">
	<t path="hxd.impl.Float32"/>
	<x path="Int"/>
</f></ftoint32>
		<new public="1" set="method" line="38"><f a="res:header">
	<c path="hxd.res.Resource"/>
	<c path="hxd.fmt.hmd.Data"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Reader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Reader.hx">
		<BLEND expr="Type.allEnums(h2d.BlendMode)" line="6" static="1">
			<c path="Array"><e path="h2d.BlendMode"/></c>
			<meta><m n=":value"><e>Type.allEnums(h2d.BlendMode)</e></m></meta>
		</BLEND>
		<CULLING expr="Type.allEnums(h3d.mat.Data.Face)" line="7" static="1">
			<c path="Array"><e path="h3d.mat.Face"/></c>
			<meta><m n=":value"><e>Type.allEnums(h3d.mat.Data.Face)</e></m></meta>
		</CULLING>
		<i><c path="haxe.io.Input"/></i>
		<version><x path="Int"/></version>
		<readProperty set="method" line="16"><f a=""><e path="hxd.fmt.hmd.Property"><x path="Float"/></e></f></readProperty>
		<readProps set="method" line="29"><f a=""><c path="Array"><e path="hxd.fmt.hmd.Property"><x path="Float"/></e></c></f></readProps>
		<readName set="method" line="38"><f a=""><c path="String"/></f></readName>
		<readPosition set="method" line="44">
			<f a="?hasScale" v="true">
				<x path="Bool"/>
				<c path="hxd.fmt.hmd.Position"/>
			</f>
			<meta><m n=":value"><e>{ hasScale : true }</e></m></meta>
		</readPosition>
		<readBounds set="method" line="64"><f a=""><c path="h3d.col.Bounds"/></f></readBounds>
		<readSkin set="method" line="75"><f a=""><c path="hxd.fmt.hmd.Skin"/></f></readSkin>
		<readHeader public="1" set="method" line="110"><f a=""><c path="hxd.fmt.hmd.Data"/></f></readHeader>
		<read public="1" set="method" line="206"><f a=""><c path="hxd.fmt.hmd.Data"/></f></read>
		<new public="1" set="method" line="12"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fmt.hmd.Writer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fmt/hmd/Writer.hx">
		<out><c path="haxe.io.Output"/></out>
		<version><x path="Int"/></version>
		<writeProperty set="method" line="13"><f a="p">
	<e path="hxd.fmt.hmd.Property"><d/></e>
	<x path="Void"/>
</f></writeProperty>
		<writeProps set="method" line="23"><f a="props">
	<t path="hxd.fmt.hmd.Properties"/>
	<x path="Void"/>
</f></writeProps>
		<writeName set="method" line="37"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></writeName>
		<writeFloat get="inline" set="null" line="50"><f a="f">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writePosition set="method" line="54">
			<f a="p:?hasScale" v=":true">
				<c path="hxd.fmt.hmd.Position"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ hasScale : true }</e></m></meta>
		</writePosition>
		<writeBounds set="method" line="68"><f a="b">
	<c path="h3d.col.Bounds"/>
	<x path="Void"/>
</f></writeBounds>
		<writeSkin set="method" line="77"><f a="s">
	<c path="hxd.fmt.hmd.Skin"/>
	<x path="Void"/>
</f></writeSkin>
		<write public="1" set="method" line="102"><f a="d">
	<c path="hxd.fmt.hmd.Data"/>
	<x path="Void"/>
</f></write>
		<new public="1" set="method" line="9"><f a="out">
	<c path="haxe.io.Output"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fs.FileEntry" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/FileEntry.hx">
		<name public="1" set="null"><c path="String"/></name>
		<path public="1" get="accessor" set="null"><c path="String"/></path>
		<directory public="1" get="accessor" set="null"><c path="String"/></directory>
		<extension public="1" get="accessor" set="null"><c path="String"/></extension>
		<size public="1" get="accessor" set="null"><x path="Int"/></size>
		<isDirectory public="1" get="accessor" set="null"><x path="Bool"/></isDirectory>
		<isAvailable public="1" get="accessor" set="null"><x path="Bool"/></isAvailable>
		<getSign public="1" set="method" line="14"><f a=""><x path="Int"/></f></getSign>
		<getBytes public="1" set="method" line="16"><f a=""><c path="haxe.io.Bytes"/></f></getBytes>
		<getText public="1" set="method" line="18"><f a=""><c path="String"/></f></getText>
		<open public="1" set="method" line="20"><f a=""><x path="Void"/></f></open>
		<skip public="1" set="method" line="21"><f a="nbytes">
	<x path="Int"/>
	<x path="Void"/>
</f></skip>
		<readByte public="1" set="method" line="22"><f a=""><x path="Int"/></f></readByte>
		<read public="1" set="method" line="23"><f a="out:pos:size">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></read>
		<close public="1" set="method" line="24"><f a=""><x path="Void"/></f></close>
		<load public="1" set="method" line="26"><f a="?onReady">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></load>
		<loadBitmap public="1" set="method" line="27"><f a="onLoaded">
	<f a="">
		<x path="hxd.fs.LoadedBitmap"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBitmap>
		<watch public="1" set="method" line="28"><f a="onChanged">
	<x path="Null"><f a=""><x path="Void"/></f></x>
	<x path="Void"/>
</f></watch>
		<exists public="1" set="method" line="29"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<get public="1" set="method" line="30"><f a="name">
	<c path="String"/>
	<c path="hxd.fs.FileEntry"/>
</f></get>
		<iterator public="1" set="method" line="32"><f a=""><c path="hxd.impl.ArrayIterator_hxd_fs_FileEntry"/></f></iterator>
		<get_isAvailable set="method" line="34"><f a=""><x path="Bool"/></f></get_isAvailable>
		<get_isDirectory set="method" line="35"><f a=""><x path="Bool"/></f></get_isDirectory>
		<get_size set="method" line="36"><f a=""><x path="Int"/></f></get_size>
		<get_path set="method" line="37"><f a=""><c path="String"/></f></get_path>
		<get_directory set="method" line="39"><f a=""><c path="String"/></f></get_directory>
		<get_extension set="method" line="45"><f a=""><c path="String"/></f></get_extension>
	</class>
	<class path="hxd.fs.BytesFileEntry" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/BytesFileSystem.hx" module="hxd.fs.BytesFileSystem">
		<extends path="hxd.fs.FileEntry"/>
		<fullPath><c path="String"/></fullPath>
		<bytes><c path="haxe.io.Bytes"/></bytes>
		<pos><x path="Int"/></pos>
		<get_path set="method" line="17" override="1"><f a=""><c path="String"/></f></get_path>
		<getSign public="1" set="method" line="21" override="1"><f a=""><x path="Int"/></f></getSign>
		<getBytes public="1" set="method" line="25" override="1"><f a=""><c path="haxe.io.Bytes"/></f></getBytes>
		<open public="1" set="method" line="29" override="1"><f a=""><x path="Void"/></f></open>
		<skip public="1" set="method" line="33" override="1"><f a="nbytes">
	<x path="Int"/>
	<x path="Void"/>
</f></skip>
		<readByte public="1" set="method" line="36" override="1"><f a=""><x path="Int"/></f></readByte>
		<read public="1" set="method" line="40" override="1"><f a="out:pos:size">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></read>
		<close public="1" set="method" line="45" override="1"><f a=""><x path="Void"/></f></close>
		<load public="1" set="method" line="48" override="1"><f a="?onReady">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></load>
		<loadBitmap public="1" set="method" line="52" override="1"><f a="onLoaded">
	<f a="">
		<x path="hxd.fs.LoadedBitmap"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBitmap>
		<exists public="1" set="method" line="79" override="1"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<get public="1" set="method" line="80" override="1"><f a="name">
	<c path="String"/>
	<c path="hxd.fs.FileEntry"/>
</f></get>
		<iterator public="1" set="method" line="82" override="1"><f a=""><c path="hxd.impl.ArrayIterator_hxd_fs_FileEntry"/></f></iterator>
		<get_size set="method" line="84" override="1"><f a=""><x path="Int"/></f></get_size>
		<new public="1" set="method" line="11"><f a="path:bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fs.FileSystem" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/FileSystem.hx" interface="1">
		<getRoot public="1" set="method"><f a=""><c path="hxd.fs.FileEntry"/></f></getRoot>
		<get public="1" set="method"><f a="path">
	<c path="String"/>
	<c path="hxd.fs.FileEntry"/>
</f></get>
		<exists public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<dir public="1" set="method"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="hxd.fs.FileEntry"/></c>
</f></dir>
	</class>
	<class path="hxd.fs.BytesFileSystem" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/BytesFileSystem.hx">
		<implements path="hxd.fs.FileSystem"/>
		<getRoot public="1" set="method" line="93"><f a=""><c path="hxd.fs.FileEntry"/></f></getRoot>
		<getBytes set="method" line="98"><f a="path">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
		<exists public="1" set="method" line="103"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<get public="1" set="method" line="107"><f a="path">
	<c path="String"/>
	<c path="hxd.fs.BytesFileEntry"/>
</f></get>
		<dispose public="1" set="method" line="113"><f a=""><x path="Void"/></f></dispose>
		<dir public="1" set="method" line="116"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="hxd.fs.FileEntry"/></c>
</f></dir>
		<new set="method" line="90"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="hxd.fs.Convert" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/Convert.hx">
		<converts public="1" expr="new Array()" line="18" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>new Array()</e></m></meta>
			<haxe_doc>Custom list of converts that should be used in FileSystem.
		Should be added in hxml `--macro` to ensure proper function.
		Example of adding a Convert:
		```haxe
		static function initCustomConverts() {
			hxd.fs.Convert.converts.push("path.to.my.Convert");
			hxd.fs.Convert.converts.push("path.to.my.OtherConvert");
		}
		```
		Adn in hxml:
		`--macro path.to.my.MacroScript.initCustomConverts()`</haxe_doc>
		</converts>
		<getConverts set="method" static="1"><f a=""><d/></f></getConverts>
		<sourceExt public="1" set="null"><c path="String"/></sourceExt>
		<destExt public="1" set="null"><c path="String"/></destExt>
		<srcPath public="1"><c path="String"/></srcPath>
		<dstPath public="1"><c path="String"/></dstPath>
		<srcFilename public="1"><c path="String"/></srcFilename>
		<srcBytes public="1"><c path="haxe.io.Bytes"/></srcBytes>
		<convert public="1" set="method" line="50"><f a=""><x path="Void"/></f></convert>
		<save set="method" line="54"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></save>
		<command set="method" line="58"><f a="cmd:args">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></command>
		<new public="1" set="method" line="45"><f a="sourceExt:destExt">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.fs.ConvertFBX2HMD" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<convert public="1" set="method" line="78" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="74"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fs.Command" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<cmd><c path="String"/></cmd>
		<args><c path="Array"><c path="String"/></c></args>
		<convert public="1" set="method" line="102" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="96"><f a="fr:to:cmd:args">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.fs.ConvertWAV2MP3" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<convert public="1" set="method" line="115" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="111"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="hxd.fs.ConvertWAV2OGG" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<convert public="1" set="method" line="127" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="123"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="hxd.fs.ConvertTGA2PNG" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<convert public="1" set="method" line="143" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="139"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fs.ConvertFNT2BFNT" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/Convert.hx" module="hxd.fs.Convert">
		<extends path="hxd.fs.Convert"/>
		<emptyTile><c path="h2d.Tile"/></emptyTile>
		<convert public="1" set="method" line="184" override="1"><f a=""><x path="Void"/></f></convert>
		<resolveTile set="method" line="192"><f a="path">
	<c path="String"/>
	<c path="h2d.Tile"/>
</f></resolveTile>
		<new public="1" set="method" line="178"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fs.FileInput" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/FileInput.hx">
		<extends path="haxe.io.Input"/>
		<f><c path="hxd.fs.FileEntry"/></f>
		<skip public="1" set="method" line="12"><f a="nbytes">
	<x path="Int"/>
	<x path="Void"/>
</f></skip>
		<readByte public="1" set="method" line="16" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="20" override="1"><f a="b:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="25" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="7"><f a="f">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxd.fs.LoadedBitmapData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/LoadedBitmap.hx" module="hxd.fs.LoadedBitmap"><c path="hxd.BitmapData"/></typedef>
	<abstract path="hxd.fs.LoadedBitmap" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/LoadedBitmap.hx">
		<this><t path="hxd.fs.LoadedBitmapData"/></this>
		<impl><class path="hxd.fs._LoadedBitmap.LoadedBitmap_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/LoadedBitmap.hx" private="1" module="hxd.fs.LoadedBitmap">
	<_new public="1" get="inline" set="null" line="15" static="1">
		<f a="data">
			<t path="hxd.fs.LoadedBitmapData"/>
			<x path="hxd.fs.LoadedBitmap"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<toBitmap public="1" set="method" line="19" static="1">
		<f a="this">
			<t path="hxd.fs.LoadedBitmapData"/>
			<c path="hxd.BitmapData"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBitmap>
	<toNative public="1" get="inline" set="null" line="38" static="1">
		<f a="this">
			<t path="hxd.fs.LoadedBitmapData"/>
			<t path="hxd.fs.LoadedBitmapData"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toNative>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="hxd.fs._LoadedBitmap.LoadedBitmap_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/LoadedBitmap.hx" private="1" module="hxd.fs.LoadedBitmap">
		<_new public="1" get="inline" set="null" line="15" static="1">
			<f a="data">
				<t path="hxd.fs.LoadedBitmapData"/>
				<x path="hxd.fs.LoadedBitmap"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<toBitmap public="1" set="method" line="19" static="1">
			<f a="this">
				<t path="hxd.fs.LoadedBitmapData"/>
				<c path="hxd.BitmapData"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBitmap>
		<toNative public="1" get="inline" set="null" line="38" static="1">
			<f a="this">
				<t path="hxd.fs.LoadedBitmapData"/>
				<t path="hxd.fs.LoadedBitmapData"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toNative>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fs._LocalFileSystem.LocalEntry" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/LocalFileSystem.hx" private="1" module="hxd.fs.LocalFileSystem">
		<extends path="hxd.fs.FileEntry"/>
		<WATCH_INDEX expr="0" line="210" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</WATCH_INDEX>
		<WATCH_LIST expr="null" line="211" static="1">
			<c path="Array"><c path="hxd.fs._LocalFileSystem.LocalEntry"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</WATCH_LIST>
		<tmpDir expr="null" line="212" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</tmpDir>
		<checkFiles set="method" line="222" static="1"><f a=""><x path="Void"/></f></checkFiles>
		<fs><c path="hxd.fs.LocalFileSystem"/></fs>
		<relPath><c path="String"/></relPath>
		<file><c path="String"/></file>
		<fread><c path="sys.io.FileInput"/></fread>
		<getSign public="1" set="method" line="27" override="1"><f a=""><x path="Int"/></f></getSign>
		<getBytes public="1" set="method" line="44" override="1"><f a=""><c path="haxe.io.Bytes"/></f></getBytes>
		<open public="1" set="method" line="59" override="1"><f a=""><x path="Void"/></f></open>
		<skip public="1" set="method" line="75" override="1"><f a="nbytes">
	<x path="Int"/>
	<x path="Void"/>
</f></skip>
		<readByte public="1" set="method" line="83" override="1"><f a=""><x path="Int"/></f></readByte>
		<read public="1" set="method" line="91" override="1"><f a="out:pos:size">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></read>
		<close public="1" set="method" line="99" override="1"><f a=""><x path="Void"/></f></close>
		<isDirCached><x path="Null"><x path="Bool"/></x></isDirCached>
		<get_isDirectory set="method" line="114" override="1"><f a=""><x path="Bool"/></f></get_isDirectory>
		<load public="1" set="method" line="123" override="1"><f a="?onReady">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></load>
		<loadBitmap public="1" set="method" line="131" override="1"><f a="onLoaded">
	<f a="">
		<x path="hxd.fs.LoadedBitmap"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBitmap>
		<get_path set="method" line="159" override="1"><f a=""><c path="String"/></f></get_path>
		<exists public="1" set="method" line="163" override="1"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<get public="1" set="method" line="167" override="1"><f a="name">
	<c path="String"/>
	<c path="hxd.fs._LocalFileSystem.LocalEntry"/>
</f></get>
		<get_size set="method" line="171" override="1"><f a=""><x path="Int"/></f></get_size>
		<iterator public="1" set="method" line="179" override="1"><f a=""><c path="hxd.impl.ArrayIterator_hxd_fs_FileEntry"/></f></iterator>
		<watchCallback><f a=""><x path="Void"/></f></watchCallback>
		<watchTime><x path="Float"/></watchTime>
		<getModifTime get="inline" set="null" line="214"><f a=""><x path="Float"/></f></getModifTime>
		<watch public="1" set="method" line="259" override="1"><f a="onChanged">
	<x path="Null"><f a=""><x path="Void"/></f></x>
	<x path="Void"/>
</f></watch>
		<new set="method" line="20"><f a="fs:name:relPath:file">
	<c path="hxd.fs.LocalFileSystem"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>hxd.fs.LocalFileSystem</e></m>
			<m n=":access"><e>hxd.fs.LocalFileSystem</e></m>
		</meta>
	</class>
	<class path="hxd.fs.LocalFileSystem" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/LocalFileSystem.hx">
		<implements path="hxd.fs.FileSystem"/>
		<root><c path="hxd.fs.FileEntry"/></root>
		<fileCache expr="new Map&lt;String,{ var r : LocalEntry}&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<a><r><c path="hxd.fs._LocalFileSystem.LocalEntry"/></r></a>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,{ var r : LocalEntry}>()]]></e></m></meta>
		</fileCache>
		<converts><t path="Map">
	<c path="String"/>
	<c path="hxd.fs.Convert"/>
</t></converts>
		<baseDir public="1" set="null"><c path="String"/></baseDir>
		<tmpDir public="1"><c path="String"/></tmpDir>
		<addConvert public="1" set="method" line="348"><f a="c">
	<c path="hxd.fs.Convert"/>
	<x path="Void"/>
</f></addConvert>
		<onConvert public="1" set="dynamic" line="352"><f a="f">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></onConvert>
		<getAbsolutePath public="1" set="method" line="355"><f a="f">
	<c path="hxd.fs.FileEntry"/>
	<c path="String"/>
</f></getAbsolutePath>
		<getRoot public="1" set="method" line="364"><f a=""><c path="hxd.fs.FileEntry"/></f></getRoot>
		<directoryCache expr="new Map()">
			<t path="Map">
				<c path="String"/>
				<t path="Map">
					<c path="String"/>
					<x path="Bool"/>
				</t>
			</t>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</directoryCache>
		<checkPath set="method" line="372"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></checkPath>
		<open set="method" line="397">
			<f a="path:?check" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="hxd.fs._LocalFileSystem.LocalEntry"/>
			</f>
			<meta><m n=":value"><e>{ check : true }</e></m></meta>
		</open>
		<exists public="1" set="method" line="424"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<get public="1" set="method" line="429"><f a="path">
	<c path="String"/>
	<c path="hxd.fs._LocalFileSystem.LocalEntry"/>
</f></get>
		<dispose public="1" set="method" line="436"><f a=""><x path="Void"/></f></dispose>
		<times><t path="Map">
	<c path="String"/>
	<x path="Int"/>
</t></times>
		<hashes><d/></hashes>
		<addedPaths expr="new Map&lt;String,Bool&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="Bool"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,Bool>()]]></e></m></meta>
		</addedPaths>
		<getFileTime set="method" line="444"><f a="filePath">
	<c path="String"/>
	<x path="Float"/>
</f></getFileTime>
		<convert set="method" line="454"><f a="e">
	<c path="hxd.fs._LocalFileSystem.LocalEntry"/>
	<x path="Void"/>
</f></convert>
		<dir public="1" set="method" line="562"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="hxd.fs.FileEntry"/></c>
</f></dir>
		<new public="1" set="method" line="298"><f a="dir">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.fs.ManifestBuilder" params="" file="./hxd/fs/ManifestBuilder.hx">
		<initManifest public="1" set="method" static="1"><f a="?basePath:?options:?storeManifest">
	<d/>
	<d/>
	<d/>
	<d/>
</f></initManifest>
		<generate public="1" set="method" static="1"><f a="?basePath:?options:?storeManifest">
	<d/>
	<d/>
	<d/>
	<d/>
</f></generate>
		<create public="1" set="method" static="1"><f a="?basePath:?options:?storeManifest">
	<d/>
	<d/>
	<d/>
	<d/>
</f></create>
	</class>
	<typedef path="hxd.fs.ManifestOptions" params="" file="./hxd/fs/ManifestBuilder.hx" module="hxd.fs.ManifestBuilder"><a><format>
	<x path="Null"><e path="hxd.fs.ManifestFormat"/></x>
	<meta><m n=":optional"/></meta>
</format></a></typedef>
	<enum path="hxd.fs.ManifestFormat" params="" file="./hxd/fs/ManifestBuilder.hx" module="hxd.fs.ManifestBuilder">
		<KeyValue/>
		<List/>
		<Serialized/>
		<Json/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="hxd.fs.ManifestEntry" params="" file="./hxd/fs/ManifestFileSystem.hx" module="hxd.fs.ManifestFileSystem">
		<extends path="hxd.fs.FileEntry"/>
		<fs><c path="hxd.fs.ManifestFileSystem"/></fs>
		<relPath><c path="String"/></relPath>
		<isDir><x path="Bool"/></isDir>
		<contents><c path="Array"><c path="hxd.fs.ManifestEntry"/></c></contents>
		<file><c path="String"/></file>
		<fio><c path="sys.io.FileInput"/></fio>
		<getSign public="1" set="method" line="44" override="1"><f a=""><x path="Int"/></f></getSign>
		<getBytes public="1" set="method" line="57" override="1"><f a=""><c path="haxe.io.Bytes"/></f></getBytes>
		<open public="1" set="method" line="66" override="1"><f a=""><x path="Void"/></f></open>
		<skip public="1" set="method" line="78" override="1"><f a="nbytes">
	<x path="Int"/>
	<x path="Void"/>
</f></skip>
		<readByte public="1" set="method" line="88" override="1"><f a=""><x path="Int"/></f></readByte>
		<read public="1" set="method" line="97" override="1"><f a="out:pos:size">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></read>
		<close public="1" set="method" line="107" override="1"><f a=""><x path="Void"/></f></close>
		<fancyLoad public="1" set="method" line="120"><f a="onReady:onProgress">
	<f a=""><x path="Void"/></f>
	<f a="cur:max">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></fancyLoad>
		<load public="1" set="method" line="139" override="1"><f a="?onReady">
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></load>
		<loadBitmap public="1" set="method" line="165" override="1"><f a="onLoaded">
	<f a="">
		<x path="hxd.fs.LoadedBitmap"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBitmap>
		<exists public="1" set="method" line="181" override="1"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<get public="1" set="method" line="186" override="1"><f a="name">
	<c path="String"/>
	<c path="hxd.fs.FileEntry"/>
</f></get>
		<_exists set="method" line="191"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></_exists>
		<_get set="method" line="200"><f a="name">
	<c path="String"/>
	<c path="hxd.fs.ManifestEntry"/>
</f></_get>
		<iterator public="1" set="method" line="209" override="1"><f a=""><c path="hxd.impl.ArrayIterator_hxd_fs_FileEntry"/></f></iterator>
		<get_isDirectory set="method" line="223" override="1"><f a=""><x path="Bool"/></f></get_isDirectory>
		<get_path set="method" line="228" override="1"><f a=""><c path="String"/></f></get_path>
		<get_size set="method" line="233" override="1"><f a=""><x path="Int"/></f></get_size>
		<dispose set="method" line="242"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="31"><f a="fs:name:relPath:file">
	<c path="hxd.fs.ManifestFileSystem"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>hxd.fs.ManifestFileSystem</e></m>
		</meta>
	</class>
	<class path="hxd.fs.ManifestFileSystem" params="" file="./hxd/fs/ManifestFileSystem.hx">
		<implements path="hxd.fs.FileSystem"/>
		<baseDir><c path="String"/></baseDir>
		<manifest public="1"><t path="Map">
	<c path="String"/>
	<c path="hxd.fs.ManifestEntry"/>
</t></manifest>
		<root><c path="hxd.fs.ManifestEntry"/></root>
		<getRoot public="1" set="method" line="330"><f a=""><c path="hxd.fs.FileEntry"/></f></getRoot>
		<splitPath set="method" line="335"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></splitPath>
		<find set="method" line="340"><f a="path">
	<c path="String"/>
	<c path="hxd.fs.ManifestEntry"/>
</f></find>
		<exists public="1" set="method" line="351"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<get public="1" set="method" line="355"><f a="path">
	<c path="String"/>
	<c path="hxd.fs.ManifestEntry"/>
</f></get>
		<dispose public="1" set="method" line="362"><f a=""><x path="Void"/></f></dispose>
		<dir public="1" set="method" line="367"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="hxd.fs.FileEntry"/></c>
</f></dir>
		<new public="1" set="method" line="265"><f a="dir:_manifest">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.fs.NotFound" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/fs/NotFound.hx">
		<path public="1"><c path="String"/></path>
		<toString set="method" line="8">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="5"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.heeps._EventSignal.SignalListener" params="T" file="./hxd/heeps/EventSignal.hx" private="1" module="hxd.heeps.EventSignal">
		<listener public="1"><c path="hxd.heeps._EventSignal.SignalListener.T"/></listener>
		<priority public="1"><x path="Int"/></priority>
		<once public="1"><x path="Bool"/></once>
		<new public="1" set="method" line="5">
			<f a="listener:priority:once">
				<c path="hxd.heeps._EventSignal.SignalListener.T"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":structInit"/>
		</meta>
	</class>
	<class path="hxd.heeps.EventSignal" params="T" file="./hxd/heeps/EventSignal.hx">
		<cancelled public="1">
			<x path="Bool"/>
			<haxe_doc>True, when listeners cancel signal invokation. Prevents further listeners being invoked.</haxe_doc>
		</cancelled>
		<softCancelled public="1">
			<x path="Bool"/>
			<haxe_doc>Will force dispatch function to return `false` and `cancelled` being true after call, but does not stop listener invokation.</haxe_doc>
		</softCancelled>
		<listeners><c path="Array"><c path="hxd.heeps._EventSignal.SignalListener"><c path="hxd.heeps.EventSignal.T"/></c></c></listeners>
		<dirty><x path="Bool"/></dirty>
		<cancel public="1" set="method" line="43">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Cancels futher listener invokation. Events further in listener list will not be invoked after this call.
    If called, `cancelled` will be true and `dispatch` will return false.</haxe_doc>
		</cancel>
		<softCancel public="1" set="method" line="52">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Cancels signal without preventing furhter listener invokation.
    If called, `cancelled` will be true and `dispatch` will return false.</haxe_doc>
		</softCancel>
		<add public="1" set="method" line="62">
			<f a="listener:?priority:?once" v=":0:false">
				<c path="hxd.heeps.EventSignal.T"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ once : false, priority : 0 }</e></m></meta>
			<haxe_doc>Adds new listeners to the list.
    @param priority A priority of the listener. Higher priority listeners are called first. Same priority events are called on first-come-first-served basis.
    @param once If true, will trigger listener only once and then automatically unsubscribe from the list.</haxe_doc>
		</add>
		<remove public="1" set="method" line="75">
			<f a="listener">
				<c path="hxd.heeps.EventSignal.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes listener from the list.</haxe_doc>
		</remove>
		<listenerSort set="method" line="88"><f a="a:b">
	<c path="hxd.heeps._EventSignal.SignalListener"><c path="hxd.heeps.EventSignal.T"/></c>
	<c path="hxd.heeps._EventSignal.SignalListener"><c path="hxd.heeps.EventSignal.T"/></c>
	<x path="Int"/>
</f></listenerSort>
		<reset get="inline" set="null" line="93"><f a=""><x path="Void"/></f></reset>
		<dispatchResult get="inline" set="null" line="103"><f a=""><x path="Bool"/></f></dispatchResult>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
		<haxe_doc>A msignal-based event dispatcher class.
  Allows for easy setup of event dispatching.
  When cancelled, will stop next listeners invokation.
  
  Use subclasses to create instances of EventSignal and call their `dispatch` function to invoke listeners.</haxe_doc>
	</class>
	<class path="hxd.heeps.EventSignal0" params="" file="./hxd/heeps/EventSignal.hx" module="hxd.heeps.EventSignal">
		<extends path="hxd.heeps.EventSignal"><f a=""><x path="Void"/></f></extends>
		<dispatch public="1" set="method" line="114"><f a=""><x path="Bool"/></f></dispatch>
		<new public="1" set="method" line="111"><f a=""><x path="Void"/></f></new>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<class path="hxd.heeps.EventSignal1" params="T" file="./hxd/heeps/EventSignal.hx" module="hxd.heeps.EventSignal">
		<extends path="hxd.heeps.EventSignal"><f a="">
	<c path="hxd.heeps.EventSignal1.T"/>
	<x path="Void"/>
</f></extends>
		<dispatch public="1" set="method" line="133"><f a="arg">
	<c path="hxd.heeps.EventSignal1.T"/>
	<x path="Bool"/>
</f></dispatch>
		<new public="1" set="method" line="131"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="hxd.heeps.EventSignal2" params="A0:A1" file="./hxd/heeps/EventSignal.hx" module="hxd.heeps.EventSignal">
		<extends path="hxd.heeps.EventSignal"><f a=":">
	<c path="hxd.heeps.EventSignal2.A0"/>
	<c path="hxd.heeps.EventSignal2.A1"/>
	<x path="Void"/>
</f></extends>
		<dispatch public="1" set="method" line="151"><f a="arg0:arg1">
	<c path="hxd.heeps.EventSignal2.A0"/>
	<c path="hxd.heeps.EventSignal2.A1"/>
	<x path="Bool"/>
</f></dispatch>
		<new public="1" set="method" line="149"><f a=""><x path="Void"/></f></new>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<class path="hxd.heeps.EventSignal3" params="A0:A1:A2" file="./hxd/heeps/EventSignal.hx" module="hxd.heeps.EventSignal">
		<extends path="hxd.heeps.EventSignal"><f a="::">
	<c path="hxd.heeps.EventSignal3.A0"/>
	<c path="hxd.heeps.EventSignal3.A1"/>
	<c path="hxd.heeps.EventSignal3.A2"/>
	<x path="Void"/>
</f></extends>
		<dispatch public="1" set="method" line="169"><f a="arg0:arg1:arg2">
	<c path="hxd.heeps.EventSignal3.A0"/>
	<c path="hxd.heeps.EventSignal3.A1"/>
	<c path="hxd.heeps.EventSignal3.A2"/>
	<x path="Bool"/>
</f></dispatch>
		<new public="1" set="method" line="167"><f a=""><x path="Void"/></f></new>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<class path="hxd.heeps.EventSignal4" params="A0:A1:A2:A3" file="./hxd/heeps/EventSignal.hx" module="hxd.heeps.EventSignal">
		<extends path="hxd.heeps.EventSignal"><f a=":::">
	<c path="hxd.heeps.EventSignal4.A0"/>
	<c path="hxd.heeps.EventSignal4.A1"/>
	<c path="hxd.heeps.EventSignal4.A2"/>
	<c path="hxd.heeps.EventSignal4.A3"/>
	<x path="Void"/>
</f></extends>
		<dispatch public="1" set="method" line="187"><f a="arg0:arg1:arg2:arg3">
	<c path="hxd.heeps.EventSignal4.A0"/>
	<c path="hxd.heeps.EventSignal4.A1"/>
	<c path="hxd.heeps.EventSignal4.A2"/>
	<c path="hxd.heeps.EventSignal4.A3"/>
	<x path="Bool"/>
</f></dispatch>
		<new public="1" set="method" line="185"><f a=""><x path="Void"/></f></new>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<class path="hxd.heeps.GifConvert" params="" file="./hxd/heeps/GifConvert.hx">
		<extends path="hxd.fs.Convert"/>
		<convert public="1" set="method" line="14" override="1"><f a=""><x path="Void"/></f></convert>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.heeps.HeepsMacro" params="" file="./hxd/heeps/HeepsMacro.hx"/>
	<class path="hxd.impl.ArrayIterator" params="T" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/ArrayIterator.hx">
		<i><x path="Int"/></i>
		<l><x path="Int"/></l>
		<a><c path="Array"><c path="hxd.impl.ArrayIterator.T"/></c></a>
		<hasNext public="1" get="inline" set="null" line="12"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="15"><f a=""><c path="hxd.impl.ArrayIterator.T"/></f></next>
		<new public="1" get="inline" set="null" line="7"><f a="a">
	<c path="Array"><c path="hxd.impl.ArrayIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":generic"/></meta>
	</class>
	<typedef path="hxd.impl.Float32" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/Float32.hx"><x path="Float"/></typedef>
	<typedef path="hxd.impl.Serializable" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/Serializable.hx"><c path="hxd.impl._Serializable.NoSerializeSupport"/></typedef>
	<typedef path="hxd.impl.StructSerializable" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/Serializable.hx" module="hxd.impl.Serializable"><c path="hxd.impl._Serializable.NoSerializeSupport"/></typedef>
	<typedef path="hxd.impl.UInt16" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/UInt16.hx"><x path="Int"/></typedef>
	<typedef path="hxd.impl._UncheckedBytes.InnerData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/UncheckedBytes.hx" private="1" module="hxd.impl.UncheckedBytes"><t path="haxe.io.BytesData"/></typedef>
	<abstract path="hxd.impl.UncheckedBytes" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/UncheckedBytes.hx">
		<from><icast field="fromBytes"><c path="haxe.io.Bytes"/></icast></from>
		<this><t path="hxd.impl._UncheckedBytes.InnerData"/></this>
		<impl><class path="hxd.impl._UncheckedBytes.UncheckedBytes_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/UncheckedBytes.hx" private="1" module="hxd.impl.UncheckedBytes">
	<_new get="inline" set="null" line="7" static="1">
		<f a="v">
			<t path="hxd.impl._UncheckedBytes.InnerData"/>
			<x path="hxd.impl.UncheckedBytes"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<get get="inline" set="null" line="11" static="1">
		<f a="this:i">
			<t path="hxd.impl._UncheckedBytes.InnerData"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</get>
	<set get="inline" set="null" line="19" static="1">
		<f a="this:i:v">
			<t path="hxd.impl._UncheckedBytes.InnerData"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</set>
	<fromBytes public="1" get="inline" set="null" line="28" static="1">
		<f a="b">
			<c path="haxe.io.Bytes"/>
			<x path="hxd.impl.UncheckedBytes"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromBytes>
</class></impl>
	</abstract>
	<class path="hxd.impl._UncheckedBytes.UncheckedBytes_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/impl/UncheckedBytes.hx" private="1" module="hxd.impl.UncheckedBytes">
		<_new get="inline" set="null" line="7" static="1">
			<f a="v">
				<t path="hxd.impl._UncheckedBytes.InnerData"/>
				<x path="hxd.impl.UncheckedBytes"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<get get="inline" set="null" line="11" static="1">
			<f a="this:i">
				<t path="hxd.impl._UncheckedBytes.InnerData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</get>
		<set get="inline" set="null" line="19" static="1">
			<f a="this:i:v">
				<t path="hxd.impl._UncheckedBytes.InnerData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</set>
		<fromBytes public="1" get="inline" set="null" line="28" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<x path="hxd.impl.UncheckedBytes"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromBytes>
	</class>
	<class path="hxd.net.BinaryLoader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/net/BinaryLoader.hx">
		<url public="1" set="null"><c path="String"/></url>
		<onLoaded public="1" set="dynamic" line="14"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></onLoaded>
		<onProgress public="1" set="dynamic" line="17"><f a="cur:max">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onProgress>
		<onError public="1" set="dynamic" line="20"><f a="msg">
	<c path="String"/>
	<x path="Void"/>
</f></onError>
		<load public="1" set="method" line="24"><f a=""><x path="Void"/></f></load>
		<new public="1" set="method" line="10"><f a="url">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.poly2tri.Edge" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/poly2tri/Edge.hx">
		<p public="1"><c path="hxd.poly2tri.Point"/></p>
		<q public="1"><c path="hxd.poly2tri.Point"/></q>
		<toString public="1" set="method" line="42"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="8"><f a="p1:p2">
	<c path="hxd.poly2tri.Point"/>
	<c path="hxd.poly2tri.Point"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.poly2tri.Point" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/poly2tri/Point.hx">
		<sortPoints public="1" set="method" line="50" static="1"><f a="points">
	<c path="Array"><c path="hxd.poly2tri.Point"/></c>
	<x path="Void"/>
</f></sortPoints>
		<cmpPoints public="1" set="method" line="55" static="1"><f a="l:r">
	<c path="hxd.poly2tri.Point"/>
	<c path="hxd.poly2tri.Point"/>
	<x path="Int"/>
</f></cmpPoints>
		<C_ID public="1" expr="0" line="69" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</C_ID>
		<id public="1"><x path="Int"/></id>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<edge_list public="1" get="accessor" set="null"><c path="Array"><c path="hxd.poly2tri.Edge"/></c></edge_list>
		<get_edge_list set="method" line="33"><f a=""><c path="Array"><c path="hxd.poly2tri.Edge"/></c></f></get_edge_list>
		<equals public="1" get="inline" set="null" line="41"><f a="that">
	<c path="hxd.poly2tri.Point"/>
	<x path="Bool"/>
</f></equals>
		<toString public="1" set="method" line="64"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="22"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.prefab.Context" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/prefab/Context.hx">
		<local2d public="1"><c path="h2d.Object"/></local2d>
		<local3d public="1"><c path="h3d.scene.Object"/></local3d>
		<shared public="1"><c path="hxd.prefab.ContextShared"/></shared>
		<cleanup public="1"><f a=""><x path="Void"/></f></cleanup>
		<custom public="1"><d/></custom>
		<isRef public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isRef>
		<init public="1" set="method" line="15"><f a=""><x path="Void"/></f></init>
		<clone public="1" set="method" line="22"><f a="p">
	<c path="hxd.prefab.Prefab"/>
	<c path="hxd.prefab.Context"/>
</f></clone>
		<loadModel public="1" set="method" line="42"><f a="path">
	<c path="String"/>
	<c path="h3d.scene.Object"/>
</f></loadModel>
		<loadAnimation public="1" set="method" line="46"><f a="path">
	<c path="String"/>
	<c path="h3d.anim.Animation"/>
</f></loadAnimation>
		<loadTexture public="1" set="method" line="50"><f a="path">
	<c path="String"/>
	<c path="h3d.mat.Texture"/>
</f></loadTexture>
		<loadShader public="1" set="method" line="54"><f a="name">
	<c path="String"/>
	<t path="hxd.prefab.ShaderDef"/>
</f></loadShader>
		<locateObject public="1" set="method" line="58"><f a="path">
	<c path="String"/>
	<c path="h3d.scene.Object"/>
</f></locateObject>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<typedef path="hxd.prefab.ShaderDef" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/prefab/ContextShared.hx" module="hxd.prefab.ContextShared"><a>
	<shader><c path="hxsl.SharedShader"/></shader>
	<inits><c path="Array"><a>
	<v><t path="hxsl.TVar"/></v>
	<e><t path="hxsl.TExpr"/></e>
</a></c></inits>
</a></typedef>
	<typedef path="hxd.prefab.ShaderDefCache" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/prefab/ContextShared.hx" module="hxd.prefab.ContextShared"><t path="Map">
	<c path="String"/>
	<t path="hxd.prefab.ShaderDef"/>
</t></typedef>
	<class path="hxd.prefab.ContextShared" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/prefab/ContextShared.hx">
		<root2d public="1"><c path="h2d.Object"/></root2d>
		<root3d public="1"><c path="h3d.scene.Object"/></root3d>
		<contexts public="1"><t path="Map">
	<c path="hxd.prefab.Prefab"/>
	<c path="hxd.prefab.Context"/>
</t></contexts>
		<references public="1"><t path="Map">
	<c path="hxd.prefab.Prefab"/>
	<c path="Array"><c path="hxd.prefab.Context"/></c>
</t></references>
		<currentPath public="1"><c path="String"/></currentPath>
		<editorDisplay public="1"><x path="Bool"/></editorDisplay>
		<cache><c path="h3d.prim.ModelCache"/></cache>
		<shaderCache><t path="hxd.prefab.ShaderDefCache"/></shaderCache>
		<bakedData><t path="Map">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</t></bakedData>
		<onError public="1" set="method" line="31"><f a="e">
	<d/>
	<x path="Void"/>
</f></onError>
		<elements public="1" set="method" line="35"><f a=""><c path="Array"><c path="hxd.prefab.Prefab"/></c></f></elements>
		<getContexts public="1" set="method" line="39"><f a="p">
	<c path="hxd.prefab.Prefab"/>
	<c path="Array"><c path="hxd.prefab.Context"/></c>
</f></getContexts>
		<loadDir public="1" set="method" line="50"><f a="p:?dir">
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><c path="hxd.res.Any"/></c>
</f></loadDir>
		<loadPrefabDat public="1" set="method" line="58"><f a="file:ext:p">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="hxd.res.Any"/>
</f></loadPrefabDat>
		<savePrefabDat public="1" set="method" line="66"><f a="file:ext:p:bytes">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></savePrefabDat>
		<loadPrefab public="1" set="method" line="70"><f a="path">
	<c path="String"/>
	<c path="hxd.prefab.Prefab"/>
</f></loadPrefab>
		<loadShader public="1" set="method" line="74"><f a="path">
	<c path="String"/>
	<t path="hxd.prefab.ShaderDef"/>
</f></loadShader>
		<loadModel public="1" set="method" line="88"><f a="path">
	<c path="String"/>
	<c path="h3d.scene.Object"/>
</f></loadModel>
		<loadAnimation public="1" set="method" line="92"><f a="path">
	<c path="String"/>
	<c path="h3d.anim.Animation"/>
</f></loadAnimation>
		<loadTexture public="1" set="method" line="96"><f a="path">
	<c path="String"/>
	<c path="h3d.mat.Texture"/>
</f></loadTexture>
		<loadBytes public="1" set="method" line="100"><f a="file">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></loadBytes>
		<loadBakedBytes public="1" set="method" line="104"><f a="file">
	<c path="String"/>
	<x path="Null"><c path="haxe.io.Bytes"/></x>
</f></loadBakedBytes>
		<saveBakedBytes public="1" set="method" line="109"><f a="file:bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></saveBakedBytes>
		<saveTexture public="1" set="method" line="142"><f a="file:bytes:dir:ext">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></saveTexture>
		<saveBakedFile set="method" line="146"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></saveBakedFile>
		<loadBakedFile set="method" line="150"><f a=""><x path="Null"><c path="haxe.io.Bytes"/></x></f></loadBakedFile>
		<loadBakedData set="method" line="156"><f a=""><x path="Void"/></f></loadBakedData>
		<getChildrenRoots set="method" line="180"><f a="base:p:out">
	<c path="h3d.scene.Object"/>
	<c path="hxd.prefab.Prefab"/>
	<c path="Array"><c path="h3d.scene.Object"/></c>
	<c path="Array"><c path="h3d.scene.Object"/></c>
</f></getChildrenRoots>
		<getObjects public="1" params="T" set="method" line="192"><f a="p:c">
	<c path="hxd.prefab.Prefab"/>
	<x path="Class"><c path="getObjects.T"/></x>
	<c path="Array"><c path="getObjects.T"/></c>
</f></getObjects>
		<getMaterials public="1" set="method" line="210"><f a="p">
	<c path="hxd.prefab.Prefab"/>
	<c path="Array"><c path="h3d.mat.Material"/></c>
</f></getMaterials>
		<new public="1" set="method" line="22"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.prefab.Prefab" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/prefab/Prefab.hx">
		<loadRec public="1" set="method" line="130" static="1"><f a="v:?parent">
	<d/>
	<c path="hxd.prefab.Prefab"/>
	<c path="hxd.prefab.Prefab"/>
</f></loadRec>
		<type public="1" set="null"><c path="String"/></type>
		<name public="1" set="accessor"><c path="String"/></name>
		<parent public="1" set="accessor"><c path="hxd.prefab.Prefab"/></parent>
		<source public="1" set="accessor"><c path="String"/></source>
		<children public="1" set="null"><c path="Array"><c path="hxd.prefab.Prefab"/></c></children>
		<enabled public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</enabled>
		<props public="1"><x path="Any"/></props>
		<set_name set="method" line="19"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></set_name>
		<set_source set="method" line="23"><f a="f">
	<c path="String"/>
	<c path="String"/>
</f></set_source>
		<set_parent set="method" line="27"><f a="p">
	<c path="hxd.prefab.Prefab"/>
	<c path="hxd.prefab.Prefab"/>
</f></set_parent>
		<iterator public="1" get="inline" set="null" line="65"><f a=""><t path="Iterator"><c path="hxd.prefab.Prefab"/></t></f></iterator>
		<load public="1" set="method" line="69"><f a="v">
	<d/>
	<x path="Void"/>
</f></load>
		<save public="1" set="method" line="73"><f a=""><a/></f></save>
		<makeInstance public="1" set="method" line="78"><f a="ctx">
	<c path="hxd.prefab.Context"/>
	<c path="hxd.prefab.Context"/>
</f></makeInstance>
		<updateInstance public="1" set="method" line="82"><f a="ctx:?propName">
	<c path="hxd.prefab.Context"/>
	<c path="String"/>
	<x path="Void"/>
</f></updateInstance>
		<removeInstance public="1" set="method" line="85"><f a="ctx">
	<c path="hxd.prefab.Context"/>
	<x path="Bool"/>
</f></removeInstance>
		<saveRec public="1" set="method" line="89"><f a=""><a/></f></saveRec>
		<reload public="1" set="method" line="105"><f a="p">
	<d/>
	<x path="Void"/>
</f></reload>
		<makeInstanceRec public="1" set="method" line="150"><f a="ctx">
	<c path="hxd.prefab.Context"/>
	<c path="hxd.prefab.Context"/>
</f></makeInstanceRec>
		<getPrefabByName public="1" set="method" line="173"><f a="name">
	<c path="String"/>
	<c path="hxd.prefab.Prefab"/>
</f></getPrefabByName>
		<getOpt public="1" params="T" set="method" line="184"><f a="cl:?name">
	<x path="Class"><c path="getOpt.T"/></x>
	<c path="String"/>
	<c path="getOpt.T"/>
</f></getOpt>
		<get public="1" params="T" set="method" line="202"><f a="cl:?name">
	<x path="Class"><c path="get.T"/></x>
	<c path="String"/>
	<c path="get.T"/>
</f></get>
		<getAll public="1" params="T" set="method" line="209"><f a="cl:?arr">
	<x path="Class"><c path="getAll.T"/></x>
	<c path="Array"><c path="getAll.T"/></c>
	<c path="Array"><c path="getAll.T"/></c>
</f></getAll>
		<findAll public="1" params="T" set="method" line="213"><f a="f:?arr">
	<f a="">
		<c path="hxd.prefab.Prefab"/>
		<x path="Null"><c path="findAll.T"/></x>
	</f>
	<c path="Array"><c path="findAll.T"/></c>
	<c path="Array"><c path="findAll.T"/></c>
</f></findAll>
		<flatten public="1" params="T" set="method" line="225"><f a="?cl:?arr">
	<x path="Class"><c path="flatten.T"/></x>
	<c path="Array"><c path="flatten.T"/></c>
	<c path="Array"><c path="flatten.T"/></c>
</f></flatten>
		<visitChildren public="1" set="method" line="240"><f a="func">
	<f a="">
		<c path="hxd.prefab.Prefab"/>
		<x path="Bool"/>
	</f>
	<x path="Void"/>
</f></visitChildren>
		<getParent public="1" params="T" set="method" line="247"><f a="c">
	<x path="Class"><c path="getParent.T"/></x>
	<x path="Null"><c path="getParent.T"/></x>
</f></getParent>
		<to public="1" params="T" set="method" line="257"><f a="c">
	<x path="Class"><c path="to.T"/></x>
	<x path="Null"><c path="to.T"/></x>
</f></to>
		<getAbsPath public="1" set="method" line="261"><f a=""><c path="String"/></f></getAbsPath>
		<getDefaultName public="1" set="method" line="271"><f a=""><c path="String"/></f></getDefaultName>
		<clone public="1" set="method" line="280"><f a=""><c path="hxd.prefab.Prefab"/></f></clone>
		<new public="1" set="method" line="14"><f a="?parent">
	<c path="hxd.prefab.Prefab"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keepSub"/>
		</meta>
	</class>
	<class path="hxd.prefab.Library" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/prefab/Library.hx">
		<extends path="hxd.prefab.Prefab"/>
		<registeredElements expr="new Map&lt;String,{ var cl : Class&lt;Prefab&gt;}&gt;()" line="47" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<a><cl><x path="Class"><c path="hxd.prefab.Prefab"/></x></cl></a>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,{ var cl : Class<Prefab>}>()]]></e></m></meta>
		</registeredElements>
		<registeredExtensions expr="new Map&lt;String,String&gt;()" line="48" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="String"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,String>()]]></e></m></meta>
		</registeredExtensions>
		<getRegistered public="1" set="method" line="50" static="1"><f a=""><x path="haxe.ds.Map">
	<c path="String"/>
	<a><cl><x path="Class"><c path="hxd.prefab.Prefab"/></x></cl></a>
</x></f></getRegistered>
		<isOfType public="1" set="method" line="54" static="1"><f a="prefabKind:cl">
	<c path="String"/>
	<x path="Class"><c path="hxd.prefab.Prefab"/></x>
	<x path="Bool"/>
</f></isOfType>
		<register public="1" set="method" line="65" static="1"><f a="type:cl:?extension">
	<c path="String"/>
	<x path="Class"><c path="hxd.prefab.Prefab"/></x>
	<c path="String"/>
	<x path="Bool"/>
</f></register>
		<create public="1" set="method" line="71" static="1"><f a="extension">
	<c path="String"/>
	<c path="hxd.prefab.Prefab"/>
</f></create>
		<getPrefabType public="1" set="method" line="81" static="1"><f a="path">
	<c path="String"/>
	<x path="Null"><c path="String"/></x>
</f></getPrefabType>
		<_ expr="hxd.prefab.Library.register(&quot;prefab&quot;, Library, &quot;prefab&quot;)" line="86" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>hxd.prefab.Library.register("prefab", Library, "prefab")</e></m></meta>
		</_>
		<inRec expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</inRec>
		<load public="1" set="method" line="14" override="1"><f a="obj">
	<d/>
	<x path="Void"/>
</f></load>
		<reload public="1" set="method" line="23" override="1"><f a="v">
	<d/>
	<x path="Void"/>
</f></reload>
		<save public="1" set="method" line="29" override="1"><f a=""><a/></f></save>
		<makeInstance public="1" set="method" line="38" override="1"><f a="ctx">
	<c path="hxd.prefab.Context"/>
	<c path="hxd.prefab.Context"/>
</f></makeInstance>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.prefab.Unknown" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/prefab/Unknown.hx">
		<extends path="hxd.prefab.Prefab"/>
		<data><d/></data>
		<load public="1" set="method" line="7" override="1"><f a="v">
	<d/>
	<x path="Void"/>
</f></load>
		<save public="1" set="method" line="11" override="1"><f a=""><a/></f></save>
		<new public="1" set="method" line="3"><f a="?parent">
	<c path="hxd.prefab.Prefab"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.prefab.rfx.Step" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/prefab/rfx/RendererFX.hx" module="hxd.prefab.rfx.RendererFX">
		<BeforeHdr/>
		<AfterHdr/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="hxd.prefab.rfx.RendererFX" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/prefab/rfx/RendererFX.hx">
		<extends path="hxd.prefab.Prefab"/>
		<apply public="1" set="method" line="10"><f a="r:step">
	<c path="h3d.scene.Renderer"/>
	<e path="hxd.prefab.rfx.Step"/>
	<x path="Void"/>
</f></apply>
		<save public="1" set="method" line="13" override="1"><f a=""><a/></f></save>
		<load public="1" set="method" line="17" override="1"><f a="v">
	<d/>
	<x path="Void"/>
</f></load>
		<dispose public="1" set="method" line="20"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="8"><f a="?parent">
	<c path="hxd.prefab.Prefab"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.res._Any.SingleFileSystem" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Any.hx" private="1" module="hxd.res.Any">
		<extends path="hxd.fs.BytesFileSystem"/>
		<path><c path="String"/></path>
		<bytes><c path="haxe.io.Bytes"/></bytes>
		<getBytes set="method" line="14" override="1"><f a="p">
	<c path="String"/>
	<x path="Null"><c path="haxe.io.Bytes"/></x>
</f></getBytes>
		<new public="1" set="method" line="8"><f a="path:bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.res.Resource" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Resource.hx">
		<LIVE_UPDATE public="1" expr="false" line="5" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</LIVE_UPDATE>
		<name public="1" get="accessor" set="null"><c path="String"/></name>
		<entry public="1" set="null"><c path="hxd.fs.FileEntry"/></entry>
		<get_name get="inline" set="null" line="14"><f a=""><c path="String"/></f></get_name>
		<toString set="method" line="18"><f a=""><c path="String"/></f></toString>
		<watch public="1" set="method" line="22"><f a="onChanged">
	<x path="Null"><f a=""><x path="Void"/></f></x>
	<x path="Void"/>
</f></watch>
		<new public="1" set="method" line="10"><f a="entry">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.res.Any" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Any.hx">
		<extends path="hxd.res.Resource"/>
		<fromBytes public="1" set="method" line="66" static="1"><f a="path:bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<c path="hxd.res.Any"/>
</f></fromBytes>
		<loader><c path="hxd.res.Loader"/></loader>
		<toModel public="1" set="method" line="30"><f a=""><c path="hxd.res.Model"/></f></toModel>
		<toTexture public="1" set="method" line="34"><f a=""><c path="h3d.mat.Texture"/></f></toTexture>
		<toTile public="1" set="method" line="38"><f a=""><c path="h2d.Tile"/></f></toTile>
		<toText public="1" set="method" line="42"><f a=""><c path="String"/></f></toText>
		<toImage public="1" set="method" line="46"><f a=""><c path="hxd.res.Image"/></f></toImage>
		<toSound public="1" set="method" line="50"><f a=""><c path="hxd.res.Sound"/></f></toSound>
		<toPrefab public="1" set="method" line="54"><f a=""><c path="hxd.res.Prefab"/></f></toPrefab>
		<to public="1" params="T" set="method" line="58"><f a="c">
	<x path="Class"><c path="to.T"/></x>
	<c path="to.T"/>
</f></to>
		<iterator public="1" get="inline" set="null" line="62"><f a=""><c path="hxd.impl.ArrayIterator_hxd_res_Any"/></f></iterator>
		<new public="1" set="method" line="25"><f a="loader:entry">
	<c path="hxd.res.Loader"/>
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>hxd.res.Loader</e></m>
		</meta>
	</class>
	<class path="hxd.res.BitmapFont" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/BitmapFont.hx">
		<extends path="hxd.res.Resource"/>
		<loader><c path="hxd.res.Loader"/></loader>
		<font><c path="h2d.Font"/></font>
		<sdfFonts><c path="Array"><c path="h2d.Font"/></c></sdfFonts>
		<toFont public="1" set="method" line="19"><f a=""><c path="h2d.Font"/></f></toFont>
		<toSdfFont public="1" set="method" line="31">
			<f a="?size:?channel:?alphaCutoff:?smoothing" v=":0:0.5:1 / 32">
				<x path="Int"/>
				<x path="h2d.SDFChannel"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="h2d.Font"/>
			</f>
			<meta><m n=":value"><e>{ smoothing : 1 / 32, alphaCutoff : 0.5, channel : 0 }</e></m></meta>
			<haxe_doc>Load and cache Signed Distance Field font with specified size, channel, alphaCutoff and smoothing. ( default : initial size, red, 0.5, 1 / 32 )
		For more information on SDF texture generation refer to this page: https://github.com/libgdx/libgdx/wiki/Distance-field-fonts
		For more information on MSDF texture generation refer to this page: https://github.com/Chlumsky/msdfgen</haxe_doc>
		</toSdfFont>
		<resolveSdfTile set="method" line="50"><f a="path">
	<c path="String"/>
	<c path="h2d.Tile"/>
</f></resolveSdfTile>
		<resolveTile set="method" line="56"><f a="path">
	<c path="String"/>
	<c path="h2d.Tile"/>
</f></resolveTile>
		<new public="1" set="method" line="14"><f a="entry">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.res.DefaultFont" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/DefaultFont.hx">
		<get public="1" set="method" line="5" static="1"><f a=""><c path="h2d.Font"/></f></get>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.res.Embed" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Embed.hx">
		<getFileContent public="1" set="method" static="1"><f a="file">
	<d/>
	<d/>
</f></getFileContent>
		<getResource public="1" set="method" static="1"><f a="file">
	<d/>
	<d/>
</f></getResource>
		<embedFont public="1" set="method" static="1"><f a="file:?chars:?skipErrors">
	<d/>
	<d/>
	<d/>
	<d/>
</f></embedFont>
	</class>
	<typedef path="hxd.res.EmbedOptions" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/EmbedOptions.hx"><a>
	<tmpDir>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</tmpDir>
	<fontsChars>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</fontsChars>
	<compressSounds>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</compressSounds>
	<compressAsMp3>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</compressAsMp3>
</a></typedef>
	<class path="hxd.res.GifImage" params="" file="./hxd/res/GifImage.hx">
		<extends path="hxd.res.Resource"/>
		<toImage public="1" set="method" line="16">
			<f a=""><c path="hxd.res.Image"/></f>
			<haxe_doc>Returns Image resource of gif spritesheet.</haxe_doc>
		</toImage>
		<toFrames public="1" set="method" line="24">
			<f a=""><c path="Array"><c path="h2d.AnimationFrame"/></c></f>
			<haxe_doc>Returns list of animation frames containing full gif animation.</haxe_doc>
		</toFrames>
		<toAnimation public="1" get="inline" set="null" line="46">
			<f a="?parent">
				<c path="h2d.Object"/>
				<c path="h2d.Animation"/>
			</f>
			<haxe_doc>Returns an Animation object with frames contained in gif file.</haxe_doc>
		</toAnimation>
		<new public="1" set="method" line="11"><f a="entry">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>A .gif image resource.</haxe_doc>
	</class>
	<abstract path="hxd.res.ImageFormat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Image.hx" module="hxd.res.Image">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="hxd.res._Image.ImageFormat_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Image.hx" private="1" module="hxd.res.Image">
	<Jpg public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
		<x path="hxd.res.ImageFormat"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Jpg>
	<Png public="1" get="inline" set="null" expr="cast 1" line="6" static="1">
		<x path="hxd.res.ImageFormat"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Png>
	<Gif public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
		<x path="hxd.res.ImageFormat"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Gif>
	<Tga public="1" get="inline" set="null" expr="cast 3" line="8" static="1">
		<x path="hxd.res.ImageFormat"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Tga>
	<useAsyncDecode public="1" get="accessor" set="null" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</useAsyncDecode>
	<get_useAsyncDecode get="inline" set="null" line="16" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_useAsyncDecode>
	<toInt get="inline" set="null" line="24" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="hxd.res._Image.ImageFormat_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Image.hx" private="1" module="hxd.res.Image">
		<Jpg public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
			<x path="hxd.res.ImageFormat"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Jpg>
		<Png public="1" get="inline" set="null" expr="cast 1" line="6" static="1">
			<x path="hxd.res.ImageFormat"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Png>
		<Gif public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
			<x path="hxd.res.ImageFormat"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Gif>
		<Tga public="1" get="inline" set="null" expr="cast 3" line="8" static="1">
			<x path="hxd.res.ImageFormat"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Tga>
		<useAsyncDecode public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</useAsyncDecode>
		<get_useAsyncDecode get="inline" set="null" line="16" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_useAsyncDecode>
		<toInt get="inline" set="null" line="24" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toInt>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="hxd.res.Image" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Image.hx">
		<extends path="hxd.res.Resource"/>
		<ALLOW_NPOT public="1" expr="true" line="33" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>Specify if we will automatically convert non-power-of-two textures to power-of-two.</haxe_doc>
		</ALLOW_NPOT>
		<DEFAULT_FILTER public="1" expr="Linear" line="34" static="1">
			<e path="h3d.mat.Filter"/>
			<meta><m n=":value"><e>Linear</e></m></meta>
		</DEFAULT_FILTER>
		<DEFAULT_ASYNC public="1" expr="false" line="39" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Forces async decoding for images if available on the target platform.</haxe_doc>
		</DEFAULT_ASYNC>
		<ENABLE_AUTO_WATCH expr="true" line="41" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</ENABLE_AUTO_WATCH>
		<tex><c path="h3d.mat.Texture"/></tex>
		<inf><a>
	<width><x path="Int"/></width>
	<height><x path="Int"/></height>
	<format><x path="hxd.res.ImageFormat"/></format>
</a></inf>
		<getFormat public="1" set="method" line="46"><f a=""><x path="hxd.res.ImageFormat"/></f></getFormat>
		<getSize public="1" set="method" line="51"><f a=""><a>
	<width><x path="Int"/></width>
	<height><x path="Int"/></height>
</a></f></getSize>
		<getPixels public="1" set="method" line="106"><f a="?fmt:?flipY">
	<e path="hxd.PixelFormat"/>
	<x path="Bool"/>
	<c path="hxd.Pixels"/>
</f></getPixels>
		<toBitmap public="1" set="method" line="209"><f a=""><c path="hxd.BitmapData"/></f></toBitmap>
		<watchCallb set="method" line="218"><f a=""><x path="Void"/></f></watchCallb>
		<loadTexture set="method" line="228"><f a=""><x path="Void"/></f></loadTexture>
		<toTexture public="1" set="method" line="276"><f a=""><c path="h3d.mat.Texture"/></f></toTexture>
		<toTile public="1" set="method" line="295"><f a=""><c path="h2d.Tile"/></f></toTile>
		<new public="1" set="method" line="28"><f a="entry">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.res.Loader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Loader.hx">
		<currentInstance public="1" static="1">
			<c path="hxd.res.Loader"/>
			<haxe_doc>Set when initializing hxd.Res, or manually.
		Allows code to resolve resources without compiling hxd.Res</haxe_doc>
		</currentInstance>
		<fs public="1" set="null"><c path="hxd.fs.FileSystem"/></fs>
		<cache><t path="Map">
	<c path="String"/>
	<d/>
</t></cache>
		<cleanCache public="1" set="method" line="19"><f a=""><x path="Void"/></f></cleanCache>
		<dir public="1" set="method" line="23"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="hxd.res.Any"/></c>
</f></dir>
		<exists public="1" set="method" line="31"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<load public="1" set="method" line="35"><f a="path">
	<c path="String"/>
	<c path="hxd.res.Any"/>
</f></load>
		<loadCache public="1" params="T" set="method" line="39"><f a="path:c">
	<c path="String"/>
	<x path="Class"><c path="loadCache.T"/></x>
	<c path="loadCache.T"/>
</f></loadCache>
		<dispose public="1" set="method" line="55"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="14"><f a="fs">
	<c path="hxd.fs.FileSystem"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.res.ManifestLoader" params="" file="./hxd/res/ManifestLoader.hx">
		<extends path="hxd.res.Loader"/>
		<mfs><c path="hxd.fs.ManifestFileSystem"/></mfs>
		<totalFiles public="1" set="null"><x path="Int"/></totalFiles>
		<loadedFiles public="1" set="null"><x path="Int"/></loadedFiles>
		<loading public="1" set="null"><x path="Bool"/></loading>
		<entries><t path="Iterator"><c path="hxd.fs.ManifestEntry"/></t></entries>
		<current><c path="hxd.fs.ManifestEntry"/></current>
		<loadManifestFiles public="1" set="method" line="26"><f a=""><x path="Void"/></f></loadManifestFiles>
		<next set="method" line="36"><f a=""><x path="Void"/></f></next>
		<fileProgress set="method" line="57"><f a="loaded:total">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fileProgress>
		<onFileLoadStarted public="1" set="dynamic" line="63"><f a="file">
	<c path="hxd.fs.ManifestEntry"/>
	<x path="Void"/>
</f></onFileLoadStarted>
		<onFileProgress public="1" set="dynamic" line="69"><f a="file:loaded:total">
	<c path="hxd.fs.ManifestEntry"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onFileProgress>
		<onFileLoaded public="1" set="dynamic" line="75"><f a="file">
	<c path="hxd.fs.ManifestEntry"/>
	<x path="Void"/>
</f></onFileLoaded>
		<onLoaded public="1" set="dynamic" line="80"><f a=""><x path="Void"/></f></onLoaded>
		<new public="1" set="method" line="17"><f a="fs">
	<c path="hxd.fs.ManifestFileSystem"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.res.Model" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Model.hx">
		<extends path="hxd.res.Resource"/>
		<toHmd public="1" set="method" line="5"><f a=""><c path="hxd.fmt.hmd.Library"/></f></toHmd>
		<new public="1" set="method" line="3"><f a="entry">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.res.Filter" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/NanoJpeg.hx" module="hxd.res.NanoJpeg">
		<Fast/>
		<Chromatic/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="hxd.res._NanoJpeg.FastBytes" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/NanoJpeg.hx" private="1" module="hxd.res.NanoJpeg">
		<this><c path="haxe.io.Bytes"/></this>
		<impl><class path="hxd.res._NanoJpeg.FastBytes_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/NanoJpeg.hx" private="1" module="hxd.res.NanoJpeg">
	<_new public="1" get="inline" set="null" line="27" static="1">
		<f a="b">
			<c path="haxe.io.Bytes"/>
			<x path="hxd.res._NanoJpeg.FastBytes"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<get get="inline" set="null" line="30" static="1">
		<f a="this:i">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</get>
	<set get="inline" set="null" line="33" static="1">
		<f a="this:i:v">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</set>
</class></impl>
	</abstract>
	<class path="hxd.res._NanoJpeg.FastBytes_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/NanoJpeg.hx" private="1" module="hxd.res.NanoJpeg">
		<_new public="1" get="inline" set="null" line="27" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<x path="hxd.res._NanoJpeg.FastBytes"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<get get="inline" set="null" line="30" static="1">
			<f a="this:i">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</get>
		<set get="inline" set="null" line="33" static="1">
			<f a="this:i:v">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</set>
	</class>
	<class path="hxd.res._NanoJpeg.Component" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/NanoJpeg.hx" private="1" module="hxd.res.NanoJpeg">
		<cid public="1"><x path="Int"/></cid>
		<ssx public="1"><x path="Int"/></ssx>
		<ssy public="1"><x path="Int"/></ssy>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<stride public="1"><x path="Int"/></stride>
		<qtsel public="1"><x path="Int"/></qtsel>
		<actabsel public="1"><x path="Int"/></actabsel>
		<dctabsel public="1"><x path="Int"/></dctabsel>
		<dcpred public="1"><x path="Int"/></dcpred>
		<pixels public="1"><c path="haxe.io.Bytes"/></pixels>
		<new public="1" set="method" line="50"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.res.NanoJpeg" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/NanoJpeg.hx">
		<BLOCKSIZE get="inline" set="null" expr="64" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>64</e></m></meta>
		</BLOCKSIZE>
		<W1 get="inline" set="null" expr="2841" line="355" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2841</e></m></meta>
		</W1>
		<W2 get="inline" set="null" expr="2676" line="356" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2676</e></m></meta>
		</W2>
		<W3 get="inline" set="null" expr="2408" line="357" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2408</e></m></meta>
		</W3>
		<W5 get="inline" set="null" expr="1609" line="358" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1609</e></m></meta>
		</W5>
		<W6 get="inline" set="null" expr="1108" line="359" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1108</e></m></meta>
		</W6>
		<W7 get="inline" set="null" expr="565" line="360" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>565</e></m></meta>
		</W7>
		<CF4A get="inline" set="null" expr="-9" line="527" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-9</e></m></meta>
		</CF4A>
		<CF4B get="inline" set="null" expr="111" line="528" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>111</e></m></meta>
		</CF4B>
		<CF4C get="inline" set="null" expr="29" line="529" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>29</e></m></meta>
		</CF4C>
		<CF4D get="inline" set="null" expr="-3" line="530" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-3</e></m></meta>
		</CF4D>
		<CF3A get="inline" set="null" expr="28" line="531" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>28</e></m></meta>
		</CF3A>
		<CF3B get="inline" set="null" expr="109" line="532" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>109</e></m></meta>
		</CF3B>
		<CF3C get="inline" set="null" expr="-9" line="533" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-9</e></m></meta>
		</CF3C>
		<CF3X get="inline" set="null" expr="104" line="534" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>104</e></m></meta>
		</CF3X>
		<CF3Y get="inline" set="null" expr="27" line="535" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>27</e></m></meta>
		</CF3Y>
		<CF3Z get="inline" set="null" expr="-3" line="536" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-3</e></m></meta>
		</CF3Z>
		<CF2A get="inline" set="null" expr="139" line="537" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>139</e></m></meta>
		</CF2A>
		<CF2B get="inline" set="null" expr="-11" line="538" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-11</e></m></meta>
		</CF2B>
		<CF get="inline" set="null" line="539" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></CF>
		<njClip get="inline" set="null" line="541" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></njClip>
		<inst expr="null" line="742" static="1">
			<c path="hxd.res.NanoJpeg"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</inst>
		<decode public="1" set="method" line="743" static="1">
			<f a="bytes:?filter:?position:?size" v="::0:-1">
				<c path="haxe.io.Bytes"/>
				<e path="hxd.res.Filter"/>
				<x path="Int"/>
				<x path="Int"/>
				<a>
					<width><x path="Int"/></width>
					<pixels><c path="haxe.io.Bytes"/></pixels>
					<height><x path="Int"/></height>
				</a>
			</f>
			<meta><m n=":value"><e>{ size : -1, position : 0 }</e></m></meta>
		</decode>
		<bytes><c path="haxe.io.Bytes"/></bytes>
		<pos><x path="Int"/></pos>
		<size><x path="Int"/></size>
		<length><x path="Int"/></length>
		<width><x path="Int"/></width>
		<height><x path="Int"/></height>
		<ncomp><x path="Int"/></ncomp>
		<comps><x path="haxe.ds.Vector"><c path="hxd.res._NanoJpeg.Component"/></x></comps>
		<counts><x path="haxe.ds.Vector"><x path="Int"/></x></counts>
		<qtab><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></qtab>
		<qtused><x path="Int"/></qtused>
		<qtavail><x path="Int"/></qtavail>
		<vlctab><x path="haxe.ds.Vector"><c path="haxe.io.Bytes"/></x></vlctab>
		<block><x path="haxe.ds.Vector"><x path="Int"/></x></block>
		<njZZ><x path="haxe.ds.Vector"><x path="Int"/></x></njZZ>
		<progressive><x path="Bool"/></progressive>
		<mbsizex><x path="Int"/></mbsizex>
		<mbsizey><x path="Int"/></mbsizey>
		<mbwidth><x path="Int"/></mbwidth>
		<mbheight><x path="Int"/></mbheight>
		<rstinterval><x path="Int"/></rstinterval>
		<buf><x path="Int"/></buf>
		<bufbits><x path="Int"/></bufbits>
		<pixels><c path="haxe.io.Bytes"/></pixels>
		<filter><e path="hxd.res.Filter"/></filter>
		<alloc get="inline" set="null" line="106"><f a="nbytes">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<free get="inline" set="null" line="110"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></free>
		<njInit set="method" line="113"><f a="bytes:pos:size:filter">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="hxd.res.Filter"/>
	<x path="Void"/>
</f></njInit>
		<cleanup set="method" line="133"><f a=""><x path="Void"/></f></cleanup>
		<njSkip get="inline" set="null" line="147"><f a="count">
	<x path="Int"/>
	<x path="Void"/>
</f></njSkip>
		<syntax get="inline" set="null" line="154"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></syntax>
		<get get="inline" set="null" line="160"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<njDecode16 get="inline" set="null" line="164"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></njDecode16>
		<njByteAlign get="inline" set="null" line="168"><f a=""><x path="Void"/></f></njByteAlign>
		<njShowBits set="method" line="172"><f a="bits">
	<x path="Int"/>
	<x path="Int"/>
</f></njShowBits>
		<njSkipBits get="inline" set="null" line="204"><f a="bits">
	<x path="Int"/>
	<x path="Void"/>
</f></njSkipBits>
		<njGetBits get="inline" set="null" line="210"><f a="bits">
	<x path="Int"/>
	<x path="Int"/>
</f></njGetBits>
		<njDecodeLength get="inline" set="null" line="216"><f a=""><x path="Void"/></f></njDecodeLength>
		<njSkipMarker get="inline" set="null" line="223"><f a=""><x path="Void"/></f></njSkipMarker>
		<njDecodeSOF set="method" line="228"><f a=""><x path="Void"/></f></njDecodeSOF>
		<njDecodeDQT set="method" line="280"><f a=""><x path="Void"/></f></njDecodeDQT>
		<njDecodeDHT set="method" line="294"><f a=""><x path="Void"/></f></njDecodeDHT>
		<njDecodeDRI set="method" line="330"><f a=""><x path="Void"/></f></njDecodeDRI>
		<vlcCode><x path="Int"/></vlcCode>
		<njGetVLC get="inline" set="null" line="340"><f a="vlc">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
</f></njGetVLC>
		<njRowIDCT get="inline" set="null" line="362"><f a="bp">
	<x path="Int"/>
	<x path="Void"/>
</f></njRowIDCT>
		<njColIDCT get="inline" set="null" line="406"><f a="bp:out:po:stride">
	<x path="Int"/>
	<x path="hxd.res._NanoJpeg.FastBytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></njColIDCT>
		<njDecodeBlock set="method" line="455"><f a="c:po">
	<c path="hxd.res._NanoJpeg.Component"/>
	<x path="Int"/>
	<x path="Void"/>
</f></njDecodeBlock>
		<notSupported set="method" line="478"><f a=""><x path="Void"/></f></notSupported>
		<njDecodeScan set="method" line="482"><f a=""><x path="Void"/></f></njDecodeScan>
		<njUpsampleH set="method" line="545"><f a="c">
	<c path="hxd.res._NanoJpeg.Component"/>
	<x path="Void"/>
</f></njUpsampleH>
		<njUpsampleV set="method" line="574"><f a="c">
	<c path="hxd.res._NanoJpeg.Component"/>
	<x path="Void"/>
</f></njUpsampleV>
		<njUpsample set="method" line="602"><f a="c">
	<c path="hxd.res._NanoJpeg.Component"/>
	<x path="Void"/>
</f></njUpsample>
		<njConvert set="method" line="632"><f a=""><c path="haxe.io.Bytes"/></f></njConvert>
		<njDecode set="method" line="702"><f a=""><a>
	<width><x path="Int"/></width>
	<pixels><c path="haxe.io.Bytes"/></pixels>
	<height><x path="Int"/></height>
</a></f></njDecode>
		<new set="method" line="88"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noDebug"/>
		</meta>
	</class>
	<typedef path="hxd.res.NotFound" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/NotFound.hx"><c path="hxd.fs.NotFound"/></typedef>
	<class path="hxd.res.Prefab" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Prefab.hx">
		<extends path="hxd.res.Resource"/>
		<lib><c path="hxd.prefab.Prefab"/></lib>
		<load public="1" set="method" line="7"><f a=""><c path="hxd.prefab.Prefab"/></f></load>
		<new public="1" set="method" line="3"><f a="entry">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.res.SoundFormat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Sound.hx" module="hxd.res.Sound">
		<Wav/>
		<Mp3/>
		<OggVorbis/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="hxd.res.Sound" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/res/Sound.hx">
		<extends path="hxd.res.Resource"/>
		<supportedFormat public="1" set="method" line="15" static="1"><f a="fmt">
	<e path="hxd.res.SoundFormat"/>
	<x path="Bool"/>
</f></supportedFormat>
		<startWorker public="1" set="method" line="82" static="1"><f a=""><x path="Bool"/></f></startWorker>
		<data><c path="hxd.snd.Data"/></data>
		<channel><c path="hxd.snd.Channel"/></channel>
		<lastPlay public="1" set="null" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</lastPlay>
		<getData public="1" set="method" line="34"><f a=""><c path="hxd.snd.Data"/></f></getData>
		<dispose public="1" set="method" line="62"><f a=""><x path="Void"/></f></dispose>
		<stop public="1" set="method" line="67"><f a=""><x path="Void"/></f></stop>
		<play public="1" set="method" line="74">
			<f a="?loop:?volume:?channelGroup:?soundGroup" v="false:1.::">
				<x path="Bool"/>
				<x path="Float"/>
				<c path="hxd.snd.ChannelGroup"/>
				<c path="hxd.snd.SoundGroup"/>
				<c path="hxd.snd.Channel"/>
			</f>
			<meta><m n=":value"><e>{ volume : 1., loop : false }</e></m></meta>
		</play>
		<new public="1" set="method" line="9"><f a="entry">
	<c path="hxd.fs.FileEntry"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.ChannelBase" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/ChannelBase.hx">
		<priority public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</priority>
		<mute public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</mute>
		<effects public="1" expr="[]">
			<c path="Array"><c path="hxd.snd.Effect"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</effects>
		<bindedEffects public="1" expr="[]">
			<c path="Array"><c path="hxd.snd.Effect"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</bindedEffects>
		<volume public="1" set="accessor" expr="1.">
			<x path="Float"/>
			<meta><m n=":value"><e>1.</e></m></meta>
		</volume>
		<currentFade><a>
	<targetVolume><x path="Float"/></targetVolume>
	<startVolume><x path="Float"/></startVolume>
	<start><x path="Float"/></start>
	<onEnd><f a=""><x path="Void"/></f></onEnd>
	<duration><x path="Float"/></duration>
</a></currentFade>
		<currentVolume><x path="Float"/></currentVolume>
		<getEffect public="1" params="T" set="method" line="18"><f a="etype">
	<x path="Class"><c path="getEffect.T"/></x>
	<c path="getEffect.T"/>
</f></getEffect>
		<set_volume set="method" line="26"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<fadeTo public="1" set="method" line="31">
			<f a="volume:?time:?onEnd" v=":1.:">
				<x path="Float"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ time : 1. }</e></m></meta>
		</fadeTo>
		<updateCurrentVolume set="method" line="35"><f a="now">
	<x path="Float"/>
	<x path="Void"/>
</f></updateCurrentVolume>
		<addEffect public="1" params="T" set="method" line="51">
			<f a="e">
				<c path="addEffect.T"/>
				<c path="addEffect.T"/>
			</f>
			<meta><m n=":access"><e>hxd.snd.Manager</e></m></meta>
		</addEffect>
		<removeEffect public="1" set="method" line="59">
			<f a="e">
				<c path="hxd.snd.Effect"/>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>hxd.snd.Manager</e></m></meta>
		</removeEffect>
		<new set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta><m n=":allow"><e>hxd.snd.Manager</e></m></meta>
	</class>
	<class path="hxd.snd.Channel" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Channel.hx">
		<extends path="hxd.snd.ChannelBase"/>
		<ID expr="0" line="5" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ID>
		<next public="1">
			<c path="hxd.snd.Channel"/>
			<meta><m n=":noCompletion"/></meta>
		</next>
		<manager><c path="hxd.snd.Manager"/></manager>
		<source><c path="hxd.snd.Source"/></source>
		<id><x path="Int"/></id>
		<sound public="1" set="null"><c path="hxd.res.Sound"/></sound>
		<duration public="1" set="null"><x path="Float"/></duration>
		<soundGroup public="1" set="null"><c path="hxd.snd.SoundGroup"/></soundGroup>
		<channelGroup public="1" set="null"><c path="hxd.snd.ChannelGroup"/></channelGroup>
		<position public="1" set="accessor"><x path="Float"/></position>
		<pause public="1" set="accessor"><x path="Bool"/></pause>
		<loop public="1"><x path="Bool"/></loop>
		<audibleGain><x path="Float"/></audibleGain>
		<lastStamp><x path="Float"/></lastStamp>
		<isVirtual><x path="Bool"/></isVirtual>
		<isLoading><x path="Bool"/></isLoading>
		<positionChanged><x path="Bool"/></positionChanged>
		<queue><c path="Array"><c path="hxd.res.Sound"/></c></queue>
		<onEnd public="1" set="dynamic" line="43">
			<f a=""><x path="Void"/></f>
			<haxe_doc>onEnd() is called when a sound which does not loop has finished playing
		or when we switch buffer in a queue
		or when a sound which is streamed loops.</haxe_doc>
		</onEnd>
		<set_position set="method" line="46"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></set_position>
		<set_pause set="method" line="52"><f a="v">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_pause>
		<updateCurrentVolume set="method" line="57" override="1"><f a="now">
	<x path="Float"/>
	<x path="Void"/>
</f></updateCurrentVolume>
		<calcAudibleGain public="1" set="method" line="74"><f a="now">
	<x path="Float"/>
	<x path="Void"/>
</f></calcAudibleGain>
		<queueSound public="1" set="method" line="88">
			<f a="sound">
				<c path="hxd.res.Sound"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Add a sound to the queue. When the current sound is finished playing, the next one will seamlessly continue.
		This will also trigger an onEnd() event.</haxe_doc>
		</queueSound>
		<stop public="1" set="method" line="92"><f a=""><x path="Void"/></f></stop>
		<new set="method" line="27"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>hxd.snd.Manager</e></m>
		</meta>
	</class>
	<class path="hxd.snd.ChannelGroup" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/ChannelGroup.hx">
		<extends path="hxd.snd.ChannelBase"/>
		<name public="1" set="null"><c path="String"/></name>
		<new public="1" set="method" line="7"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.snd.SampleFormat" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Data.hx" module="hxd.snd.Data">
		<UI8/>
		<I16/>
		<F32/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="hxd.snd.Data" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Data.hx">
		<formatBytes public="1" get="inline" set="null" line="165" static="1"><f a="format">
	<e path="hxd.snd.SampleFormat"/>
	<x path="Int"/>
</f></formatBytes>
		<samples public="1" set="null"><x path="Int"/></samples>
		<samplingRate public="1" set="null"><x path="Int"/></samplingRate>
		<sampleFormat public="1" set="null"><e path="hxd.snd.SampleFormat"/></sampleFormat>
		<channels public="1" set="null"><x path="Int"/></channels>
		<duration public="1" get="accessor" set="null"><x path="Float"/></duration>
		<isLoading public="1" set="method" line="18"><f a=""><x path="Bool"/></f></isLoading>
		<decode public="1" set="method" line="22"><f a="out:outPos:sampleStart:sampleCount">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></decode>
		<resample public="1" set="method" line="45"><f a="rate:format:channels">
	<x path="Int"/>
	<e path="hxd.snd.SampleFormat"/>
	<x path="Int"/>
	<c path="hxd.snd.Data"/>
</f></resample>
		<resampleBuffer public="1" set="method" line="67">
			<f a="out:outPos:input:inPos:rate:format:channels:samples">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<e path="hxd.snd.SampleFormat"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</resampleBuffer>
		<decodeBuffer set="method" line="157"><f a="out:outPos:sampleStart:sampleCount">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></decodeBuffer>
		<getBytesPerSample public="1" set="method" line="161"><f a=""><x path="Int"/></f></getBytesPerSample>
		<load public="1" set="method" line="178">
			<f a="onEnd">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>Some platforms might require some data to be loaded before we can start decoding.
		Use load() and wait for onEnd to make sure that the sound data and the correct number of samples is available.
		onEnd() might be called back immediately if the data is already available.</haxe_doc>
		</load>
		<get_duration set="method" line="182"><f a=""><x path="Float"/></f></get_duration>
	</class>
	<typedef path="hxd.snd.SourceHandle" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Driver.hx" module="hxd.snd.Driver"><c path="hxd.snd.openal.SourceHandle"/></typedef>
	<typedef path="hxd.snd.BufferHandle" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Driver.hx" module="hxd.snd.Driver"><c path="hxd.snd.openal.BufferHandle"/></typedef>
	<class path="hxd.snd.EffectDriver" params="T" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Driver.hx" module="hxd.snd.Driver">
		<acquire public="1" set="method" line="14"><f a=""><x path="Void"/></f></acquire>
		<release public="1" set="method" line="15"><f a=""><x path="Void"/></f></release>
		<update public="1" set="method" line="16"><f a="e">
	<c path="hxd.snd.EffectDriver.T"/>
	<x path="Void"/>
</f></update>
		<bind public="1" set="method" line="17"><f a="e:source">
	<c path="hxd.snd.EffectDriver.T"/>
	<t path="hxd.snd.SourceHandle"/>
	<x path="Void"/>
</f></bind>
		<apply public="1" set="method" line="18"><f a="e:source">
	<c path="hxd.snd.EffectDriver.T"/>
	<t path="hxd.snd.SourceHandle"/>
	<x path="Void"/>
</f></apply>
		<unbind public="1" set="method" line="19"><f a="e:source">
	<c path="hxd.snd.EffectDriver.T"/>
	<t path="hxd.snd.SourceHandle"/>
	<x path="Void"/>
</f></unbind>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxd.snd.DriverFeature" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Driver.hx" module="hxd.snd.Driver">
		<MasterVolume/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="hxd.snd.Driver" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Driver.hx" interface="1">
		<hasFeature public="1" set="method"><f a="d">
	<e path="hxd.snd.DriverFeature"/>
	<x path="Bool"/>
</f></hasFeature>
		<setMasterVolume public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></setMasterVolume>
		<setListenerParams public="1" set="method"><f a="position:direction:up:?velocity">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></setListenerParams>
		<createSource public="1" set="method"><f a=""><t path="hxd.snd.SourceHandle"/></f></createSource>
		<playSource public="1" set="method"><f a="source">
	<t path="hxd.snd.SourceHandle"/>
	<x path="Void"/>
</f></playSource>
		<stopSource public="1" set="method"><f a="source">
	<t path="hxd.snd.SourceHandle"/>
	<x path="Void"/>
</f></stopSource>
		<setSourceVolume public="1" set="method"><f a="source:value">
	<t path="hxd.snd.SourceHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setSourceVolume>
		<destroySource public="1" set="method"><f a="source">
	<t path="hxd.snd.SourceHandle"/>
	<x path="Void"/>
</f></destroySource>
		<createBuffer public="1" set="method"><f a=""><t path="hxd.snd.BufferHandle"/></f></createBuffer>
		<setBufferData public="1" set="method"><f a="buffer:data:size:format:channelCount:samplingRate">
	<t path="hxd.snd.BufferHandle"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<e path="hxd.snd.SampleFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setBufferData>
		<destroyBuffer public="1" set="method"><f a="buffer">
	<t path="hxd.snd.BufferHandle"/>
	<x path="Void"/>
</f></destroyBuffer>
		<queueBuffer public="1" set="method"><f a="source:buffer:sampleStart:endOfStream">
	<t path="hxd.snd.SourceHandle"/>
	<t path="hxd.snd.BufferHandle"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></queueBuffer>
		<unqueueBuffer public="1" set="method"><f a="source:buffer">
	<t path="hxd.snd.SourceHandle"/>
	<t path="hxd.snd.BufferHandle"/>
	<x path="Void"/>
</f></unqueueBuffer>
		<getProcessedBuffers public="1" set="method"><f a="source">
	<t path="hxd.snd.SourceHandle"/>
	<x path="Int"/>
</f></getProcessedBuffers>
		<getPlayedSampleCount public="1" set="method"><f a="source">
	<t path="hxd.snd.SourceHandle"/>
	<x path="Int"/>
</f></getPlayedSampleCount>
		<update public="1" set="method"><f a=""><x path="Void"/></f></update>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<getEffectDriver public="1" set="method"><f a="type">
	<c path="String"/>
	<c path="hxd.snd.EffectDriver"><d/></c>
</f></getEffectDriver>
	</class>
	<class path="hxd.snd.Effect" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Effect.hx">
		<next public="1">
			<c path="hxd.snd.Effect"/>
			<meta><m n=":noCompletion"/></meta>
		</next>
		<refs><x path="Int"/></refs>
		<retainTime><x path="Float"/></retainTime>
		<lastStamp><x path="Float"/></lastStamp>
		<driver><c path="hxd.snd.EffectDriver"><d/></c></driver>
		<priority><x path="Int"/></priority>
		<applyAudibleGainModifier public="1" set="method" line="28"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></applyAudibleGainModifier>
		<getVolumeModifier public="1" set="method" line="33"><f a=""><x path="Float"/></f></getVolumeModifier>
		<new public="1" set="method" line="14"><f a="type">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":allow"><e>hxd.snd.Manager</e></m></meta>
	</class>
	<class path="hxd.snd.Listener" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Listener.hx">
		<position public="1"><c path="h3d.Vector"/></position>
		<direction public="1"><c path="h3d.Vector"/></direction>
		<velocity public="1"><c path="h3d.Vector"/></velocity>
		<up public="1"><c path="h3d.Vector"/></up>
		<syncCamera public="1" set="method" line="17"><f a="cam">
	<c path="h3d.Camera"/>
	<x path="Void"/>
</f></syncCamera>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.Source" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Manager.hx" module="hxd.snd.Manager">
		<ID expr="0" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ID>
		<id public="1" set="null"><x path="Int"/></id>
		<handle public="1"><t path="hxd.snd.SourceHandle"/></handle>
		<channel public="1"><c path="hxd.snd.Channel"/></channel>
		<buffers public="1"><c path="Array"><c path="hxd.snd.Buffer"/></c></buffers>
		<volume public="1" expr="-1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>-1.0</e></m></meta>
		</volume>
		<playing public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</playing>
		<start public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</start>
		<streamSound public="1"><c path="hxd.res.Sound"/></streamSound>
		<streamBuffer public="1"><c path="haxe.io.Bytes"/></streamBuffer>
		<streamStart public="1"><x path="Int"/></streamStart>
		<streamPos public="1"><x path="Int"/></streamPos>
		<dispose public="1" set="method" line="30"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="24"><f a="driver">
	<c path="hxd.snd.Driver"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>hxd.snd.Manager</e></m>
		</meta>
	</class>
	<class path="hxd.snd.Buffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Manager.hx" module="hxd.snd.Manager">
		<handle public="1"><t path="hxd.snd.BufferHandle"/></handle>
		<sound public="1"><c path="hxd.res.Sound"/></sound>
		<isEnd public="1"><x path="Bool"/></isEnd>
		<isStream public="1"><x path="Bool"/></isStream>
		<refs public="1"><x path="Int"/></refs>
		<lastStop public="1"><x path="Float"/></lastStop>
		<start public="1"><x path="Int"/></start>
		<samples public="1"><x path="Int"/></samples>
		<sampleRate public="1"><x path="Int"/></sampleRate>
		<dispose public="1" set="method" line="54"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="48"><f a="driver">
	<c path="hxd.snd.Driver"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>hxd.snd.Manager</e></m>
		</meta>
	</class>
	<class path="hxd.snd.Manager" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Manager.hx">
		<STREAM_DURATION public="1" expr="5." line="61" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>5.</e></m></meta>
		</STREAM_DURATION>
		<STREAM_BUFFER_SAMPLE_COUNT public="1" expr="44100" line="62" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>44100</e></m></meta>
		</STREAM_BUFFER_SAMPLE_COUNT>
		<BUFFER_QUEUE_LENGTH public="1" expr="2" line="63" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</BUFFER_QUEUE_LENGTH>
		<MAX_SOURCES public="1" expr="16" line="64" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</MAX_SOURCES>
		<SOUND_BUFFER_CACHE_SIZE public="1" expr="256" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>256</e></m></meta>
		</SOUND_BUFFER_CACHE_SIZE>
		<BUFFER_STREAM_SPLIT public="1" expr="16" line="70" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
			<haxe_doc>Allows to decode big streaming buffers over X split frames. 0 to disable</haxe_doc>
		</BUFFER_STREAM_SPLIT>
		<instance static="1"><c path="hxd.snd.Manager"/></instance>
		<get public="1" set="method" line="138" static="1"><f a=""><c path="hxd.snd.Manager"/></f></get>
		<regEffect set="method" line="561" static="1"><f a="list:e">
	<c path="hxd.snd.Effect"/>
	<c path="hxd.snd.Effect"/>
	<c path="hxd.snd.Effect"/>
</f></regEffect>
		<masterVolume public="1"><x path="Float"/></masterVolume>
		<masterSoundGroup public="1" set="null"><c path="hxd.snd.SoundGroup"/></masterSoundGroup>
		<masterChannelGroup public="1" set="null"><c path="hxd.snd.ChannelGroup"/></masterChannelGroup>
		<listener public="1"><c path="hxd.snd.Listener"/></listener>
		<updateEvent><c path="haxe.MainEvent"/></updateEvent>
		<cachedBytes><c path="haxe.io.Bytes"/></cachedBytes>
		<resampleBytes><c path="haxe.io.Bytes"/></resampleBytes>
		<driver><c path="hxd.snd.Driver"/></driver>
		<channels><c path="hxd.snd.Channel"/></channels>
		<sources><c path="Array"><c path="hxd.snd.Source"/></c></sources>
		<now><x path="Float"/></now>
		<soundBufferCount><x path="Int"/></soundBufferCount>
		<soundBufferMap><t path="Map">
	<c path="String"/>
	<c path="hxd.snd.Buffer"/>
</t></soundBufferMap>
		<freeStreamBuffers><c path="Array"><c path="hxd.snd.Buffer"/></c></freeStreamBuffers>
		<effectGC><c path="Array"><c path="hxd.snd.Effect"/></c></effectGC>
		<hasMasterVolume><x path="Bool"/></hasMasterVolume>
		<getTmpBytes set="method" line="126"><f a="size">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></getTmpBytes>
		<getResampleBytes set="method" line="132"><f a="size">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></getResampleBytes>
		<stopAll public="1" set="method" line="147"><f a=""><x path="Void"/></f></stopAll>
		<cleanCache public="1" set="method" line="152"><f a=""><x path="Void"/></f></cleanCache>
		<dispose public="1" set="method" line="162"><f a=""><x path="Void"/></f></dispose>
		<play public="1" set="method" line="182"><f a="sound:?channelGroup:?soundGroup">
	<c path="hxd.res.Sound"/>
	<c path="hxd.snd.ChannelGroup"/>
	<c path="hxd.snd.SoundGroup"/>
	<c path="hxd.snd.Channel"/>
</f></play>
		<updateVirtualChannels set="method" line="203"><f a="now">
	<x path="Float"/>
	<x path="Void"/>
</f></updateVirtualChannels>
		<update public="1" set="method" line="236"><f a=""><x path="Void"/></f></update>
		<progressiveDecodeBuffer set="method" line="506"><f a="s:snd:start">
	<c path="hxd.snd.Source"/>
	<c path="hxd.res.Sound"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></progressiveDecodeBuffer>
		<queueBuffer set="method" line="530"><f a="s:snd:start">
	<c path="hxd.snd.Source"/>
	<c path="hxd.res.Sound"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></queueBuffer>
		<unqueueBuffer set="method" line="553"><f a="s">
	<c path="hxd.snd.Source"/>
	<x path="Null"><c path="hxd.snd.Buffer"/></x>
</f></unqueueBuffer>
		<bindEffect set="method" line="571"><f a="c:s:e">
	<c path="hxd.snd.Channel"/>
	<c path="hxd.snd.Source"/>
	<c path="hxd.snd.Effect"/>
	<x path="Void"/>
</f></bindEffect>
		<unbindEffect set="method" line="578"><f a="c:s:e">
	<c path="hxd.snd.Channel"/>
	<c path="hxd.snd.Source"/>
	<c path="hxd.snd.Effect"/>
	<x path="Void"/>
</f></unbindEffect>
		<releaseSource set="method" line="587"><f a="s">
	<c path="hxd.snd.Source"/>
	<x path="Void"/>
</f></releaseSource>
		<targetRate><x path="Int"/></targetRate>
		<targetFormat><e path="hxd.snd.SampleFormat"/></targetFormat>
		<targetChannels><x path="Int"/></targetChannels>
		<checkTargetFormat set="method" line="608">
			<f a="dat:?forceMono" v=":false">
				<c path="hxd.snd.Data"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ forceMono : false }</e></m></meta>
		</checkTargetFormat>
		<getSoundBuffer set="method" line="627"><f a="snd:grp">
	<c path="hxd.res.Sound"/>
	<c path="hxd.snd.SoundGroup"/>
	<c path="hxd.snd.Buffer"/>
</f></getSoundBuffer>
		<fillSoundBuffer set="method" line="648">
			<f a="buf:dat:?forceMono" v="::false">
				<c path="hxd.snd.Buffer"/>
				<c path="hxd.snd.Data"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forceMono : false }</e></m></meta>
		</fillSoundBuffer>
		<getStreamBuffer set="method" line="660"><f a="src:snd:grp:start">
	<c path="hxd.snd.Source"/>
	<c path="hxd.res.Sound"/>
	<c path="hxd.snd.SoundGroup"/>
	<x path="Int"/>
	<c path="hxd.snd.Buffer"/>
</f></getStreamBuffer>
		<sortChannel set="method" line="704"><f a="a:b">
	<c path="hxd.snd.Channel"/>
	<c path="hxd.snd.Channel"/>
	<x path="Int"/>
</f></sortChannel>
		<sortEffect set="method" line="720"><f a="a:b">
	<c path="hxd.snd.Effect"/>
	<c path="hxd.snd.Effect"/>
	<x path="Int"/>
</f></sortEffect>
		<releaseChannel set="method" line="724"><f a="c">
	<c path="hxd.snd.Channel"/>
	<x path="Void"/>
</f></releaseChannel>
		<new set="method" line="95"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.Mp3Data" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/Mp3Data.hx">
		<extends path="hxd.snd.Data"/>
		<decodeBuffer set="method" line="98" override="1"><f a="out:outPos:sampleStart:sampleCount">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></decodeBuffer>
		<new public="1" set="method" line="12"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.NativeChannel" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/NativeChannel.hx">
		<bufferSamples public="1" set="null"><x path="Int"/></bufferSamples>
		<onSample set="method" line="238"><f a="out">
	<x path="haxe.io.Float32Array"/>
	<x path="Void"/>
</f></onSample>
		<stop public="1" set="method" line="241"><f a=""><x path="Void"/></f></stop>
		<new public="1" set="method" line="128"><f a="bufferSamples">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="hxd.snd.SoundGroup" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/SoundGroup.hx">
		<name public="1" set="null"><c path="String"/></name>
		<volume public="1"><x path="Float"/></volume>
		<maxAudible public="1"><x path="Int"/></maxAudible>
		<mono public="1"><x path="Bool"/></mono>
		<numAudible><x path="Int"/></numAudible>
		<new public="1" set="method" line="12"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>hxd.snd.Manager</e></m>
		</meta>
	</class>
	<class path="hxd.snd.WavData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/WavData.hx">
		<extends path="hxd.snd.Data"/>
		<rawData><c path="haxe.io.Bytes"/></rawData>
		<init set="method" line="13"><f a="d">
	<t path="format.wav.WAVE"/>
	<x path="Void"/>
</f></init>
		<decodeBuffer set="method" line="27" override="1"><f a="out:outPos:sampleStart:sampleCount">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></decodeBuffer>
		<new public="1" set="method" line="8"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxd.snd.openal.AL" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/AudioTypes.hx" module="hxd.snd.openal.AudioTypes"><c path="hxd.snd.openal.Emulator"/></typedef>
	<class path="hxd.snd.openal.BufferHandle" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/AudioTypes.hx" module="hxd.snd.openal.AudioTypes">
		<inst public="1"><c path="hxd.snd.openal.Buffer"/></inst>
		<isEnd public="1"><x path="Bool"/></isEnd>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.SourceHandle" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/AudioTypes.hx" module="hxd.snd.openal.AudioTypes">
		<inst public="1"><c path="hxd.snd.openal.Source"/></inst>
		<sampleOffset public="1"><x path="Int"/></sampleOffset>
		<playing public="1"><x path="Bool"/></playing>
		<nextAuxiliarySend><x path="Int"/></nextAuxiliarySend>
		<freeAuxiliarySends><c path="Array"><x path="Int"/></c></freeAuxiliarySends>
		<effectToAuxiliarySend><t path="Map">
	<c path="hxd.snd.Effect"/>
	<x path="Int"/>
</t></effectToAuxiliarySend>
		<acquireAuxiliarySend public="1" set="method" line="33"><f a="effect">
	<c path="hxd.snd.Effect"/>
	<x path="Int"/>
</f></acquireAuxiliarySend>
		<getAuxiliarySend public="1" set="method" line="41"><f a="effect">
	<c path="hxd.snd.Effect"/>
	<x path="Int"/>
</f></getAuxiliarySend>
		<releaseAuxiliarySend public="1" set="method" line="45"><f a="effect">
	<c path="hxd.snd.Effect"/>
	<x path="Int"/>
</f></releaseAuxiliarySend>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.Driver" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Driver.hx">
		<implements path="hxd.snd.Driver"/>
		<device public="1" set="null"><c path="hxd.snd.openal.Device"/></device>
		<context public="1" set="null"><c path="hxd.snd.openal.Context"/></context>
		<maxAuxiliarySends public="1" set="null"><x path="Int"/></maxAuxiliarySends>
		<tmpBytes><c path="haxe.io.Bytes"/></tmpBytes>
		<hasFeature public="1" set="method" line="39"><f a="f">
	<e path="hxd.snd.DriverFeature"/>
	<x path="Bool"/>
</f></hasFeature>
		<getTmpBytes public="1" set="method" line="45"><f a="size">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></getTmpBytes>
		<setMasterVolume public="1" set="method" line="50"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></setMasterVolume>
		<setListenerParams public="1" set="method" line="54"><f a="position:direction:up:?velocity">
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<c path="h3d.Vector"/>
	<x path="Void"/>
</f></setListenerParams>
		<createSource public="1" set="method" line="73"><f a=""><c path="hxd.snd.openal.SourceHandle"/></f></createSource>
		<destroySource public="1" set="method" line="85"><f a="source">
	<c path="hxd.snd.openal.SourceHandle"/>
	<x path="Void"/>
</f></destroySource>
		<playSource public="1" set="method" line="93"><f a="source">
	<c path="hxd.snd.openal.SourceHandle"/>
	<x path="Void"/>
</f></playSource>
		<stopSource public="1" set="method" line="98"><f a="source">
	<c path="hxd.snd.openal.SourceHandle"/>
	<x path="Void"/>
</f></stopSource>
		<setSourceVolume public="1" set="method" line="103"><f a="source:value">
	<c path="hxd.snd.openal.SourceHandle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setSourceVolume>
		<createBuffer public="1" set="method" line="107"><f a=""><c path="hxd.snd.openal.BufferHandle"/></f></createBuffer>
		<destroyBuffer public="1" set="method" line="115"><f a="buffer">
	<c path="hxd.snd.openal.BufferHandle"/>
	<x path="Void"/>
</f></destroyBuffer>
		<setBufferData public="1" set="method" line="121"><f a="buffer:data:size:format:channelCount:samplingRate">
	<c path="hxd.snd.openal.BufferHandle"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<e path="hxd.snd.SampleFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setBufferData>
		<getPlayedSampleCount public="1" set="method" line="134"><f a="source">
	<c path="hxd.snd.openal.SourceHandle"/>
	<x path="Int"/>
</f></getPlayedSampleCount>
		<getProcessedBuffers public="1" set="method" line="141"><f a="source">
	<c path="hxd.snd.openal.SourceHandle"/>
	<x path="Int"/>
</f></getProcessedBuffers>
		<queueBuffer public="1" set="method" line="145"><f a="source:buffer:sampleStart:endOfStream">
	<c path="hxd.snd.openal.SourceHandle"/>
	<c path="hxd.snd.openal.BufferHandle"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></queueBuffer>
		<unqueueBuffer public="1" set="method" line="166"><f a="source:buffer">
	<c path="hxd.snd.openal.SourceHandle"/>
	<c path="hxd.snd.openal.BufferHandle"/>
	<x path="Void"/>
</f></unqueueBuffer>
		<update public="1" set="method" line="179"><f a=""><x path="Void"/></f></update>
		<dispose public="1" set="method" line="182"><f a=""><x path="Void"/></f></dispose>
		<getEffectDriver public="1" set="method" line="188"><f a="type">
	<c path="String"/>
	<c path="hxd.snd.EffectDriver"><d/></c>
</f></getEffectDriver>
		<new public="1" set="method" line="21"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxd.snd.openal._Emulator.F32" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx" private="1" module="hxd.snd.openal.Emulator"><x path="Float"/></typedef>
	<typedef path="hxd.snd.openal._Emulator.Bytes" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx" private="1" module="hxd.snd.openal.Emulator"><c path="haxe.io.Bytes"/></typedef>
	<class path="hxd.snd.openal._Emulator.Channel" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx" private="1" module="hxd.snd.openal.Emulator">
		<extends path="hxd.snd.NativeChannel"/>
		<FADE_START get="inline" set="null" expr="10" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</FADE_START>
		<source><c path="hxd.snd.openal.Source"/></source>
		<startup expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</startup>
		<onSample set="method" line="18" override="1">
			<f a="out">
				<x path="haxe.io.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</onSample>
		<new public="1" set="method" line="12"><f a="source:samples">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.Source" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx" module="hxd.snd.openal.Emulator">
		<STOP_DELAY get="inline" set="null" expr="0" line="79" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</STOP_DELAY>
		<CHANNEL_BUFSIZE public="1" expr="4096" line="81" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4096</e></m></meta>
		</CHANNEL_BUFSIZE>
		<ID expr="0" line="83" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ID>
		<all expr="new Map&lt;Int,Source&gt;()" line="84" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="hxd.snd.openal.Source"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Source>()]]></e></m></meta>
		</all>
		<ofInt public="1" get="inline" set="null" line="136" static="1"><f a="i">
	<x path="Int"/>
	<x path="Null"><c path="hxd.snd.openal.Source"/></x>
</f></ofInt>
		<id public="1"><x path="Int"/></id>
		<chan public="1"><c path="hxd.snd.NativeChannel"/></chan>
		<playedTime public="1" expr="0.">
			<x path="Float"/>
			<meta><m n=":value"><e>0.</e></m></meta>
		</playedTime>
		<currentSample public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</currentSample>
		<buffers public="1" expr="[]">
			<c path="Array"><c path="hxd.snd.openal.Buffer"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</buffers>
		<loop public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</loop>
		<volume public="1" expr="1.">
			<t path="hxd.snd.openal._Emulator.F32"/>
			<meta><m n=":value"><e>1.</e></m></meta>
		</volume>
		<playing public="1" get="accessor" set="null"><x path="Bool"/></playing>
		<duration public="1"><x path="Float"/></duration>
		<frequency public="1"><x path="Int"/></frequency>
		<updateDuration public="1" set="method" line="103"><f a=""><x path="Void"/></f></updateDuration>
		<get_playing get="inline" set="null" line="110"><f a=""><x path="Bool"/></f></get_playing>
		<play public="1" set="method" line="112"><f a=""><x path="Void"/></f></play>
		<stop public="1" set="method" line="119">
			<f a="?immediate" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ immediate : false }</e></m></meta>
		</stop>
		<dispose public="1" set="method" line="129"><f a=""><x path="Void"/></f></dispose>
		<toInt public="1" get="inline" set="null" line="135"><f a=""><x path="Int"/></f></toInt>
		<new public="1" set="method" line="98"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.Buffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx" module="hxd.snd.openal.Emulator">
		<ID expr="0" line="141" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ID>
		<all expr="new Map&lt;Int,Buffer&gt;()" line="142" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="hxd.snd.openal.Buffer"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Buffer>()]]></e></m></meta>
		</all>
		<ofInt public="1" get="inline" set="null" line="167" static="1"><f a="i">
	<x path="Int"/>
	<x path="Null"><c path="hxd.snd.openal.Buffer"/></x>
</f></ofInt>
		<id public="1"><x path="Int"/></id>
		<data public="1"><x path="haxe.ds.Vector"><t path="hxd.snd.openal._Emulator.F32"/></x></data>
		<frequency public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</frequency>
		<samples public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</samples>
		<dispose public="1" set="method" line="154"><f a=""><x path="Void"/></f></dispose>
		<alloc public="1" set="method" line="160"><f a="size">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><t path="hxd.snd.openal._Emulator.F32"/></x>
</f></alloc>
		<toInt public="1" get="inline" set="null" line="166"><f a=""><x path="Int"/></f></toInt>
		<new public="1" set="method" line="149"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.Emulator" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx">
		<NATIVE_FREQ public="1" expr="44100" line="177" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>44100</e></m></meta>
		</NATIVE_FREQ>
		<dopplerFactor public="1" set="method" line="181" static="1"><f a="value">
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></dopplerFactor>
		<dopplerVelocity public="1" set="method" line="182" static="1"><f a="value">
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></dopplerVelocity>
		<speedOfSound public="1" set="method" line="183" static="1"><f a="value">
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></speedOfSound>
		<distanceModel public="1" set="method" line="184" static="1"><f a="distanceModel">
	<x path="Int"/>
	<x path="Void"/>
</f></distanceModel>
		<enable public="1" set="method" line="187" static="1"><f a="capability">
	<x path="Int"/>
	<x path="Void"/>
</f></enable>
		<disable public="1" set="method" line="188" static="1"><f a="capability">
	<x path="Int"/>
	<x path="Void"/>
</f></disable>
		<isEnabled public="1" set="method" line="189" static="1"><f a="capability">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEnabled>
		<getBooleanv public="1" set="method" line="192" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getBooleanv>
		<getIntegerv public="1" set="method" line="195" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getIntegerv>
		<getFloatv public="1" set="method" line="198" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getFloatv>
		<getDoublev public="1" set="method" line="201" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getDoublev>
		<getString public="1" set="method" line="205" static="1"><f a="param">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
</f></getString>
		<getBoolean public="1" set="method" line="209" static="1"><f a="param">
	<x path="Int"/>
	<x path="Bool"/>
</f></getBoolean>
		<getInteger public="1" set="method" line="213" static="1"><f a="param">
	<x path="Int"/>
	<x path="Int"/>
</f></getInteger>
		<getFloat public="1" set="method" line="217" static="1"><f a="param">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
</f></getFloat>
		<getDouble public="1" set="method" line="221" static="1"><f a="param">
	<x path="Int"/>
	<x path="Float"/>
</f></getDouble>
		<getError public="1" set="method" line="226" static="1"><f a=""><x path="Int"/></f></getError>
		<loadExtensions public="1" set="method" line="231" static="1"><f a=""><x path="Void"/></f></loadExtensions>
		<isExtensionPresent public="1" set="method" line="233" static="1"><f a="extname">
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Bool"/>
</f></isExtensionPresent>
		<getEnumValue public="1" set="method" line="237" static="1"><f a="ename">
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Int"/>
</f></getEnumValue>
		<listenerf public="1" set="method" line="243" static="1"><f a="param:value">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></listenerf>
		<listener3f public="1" set="method" line="244" static="1"><f a="param:value1:value2:value3">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></listener3f>
		<listenerfv public="1" set="method" line="245" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></listenerfv>
		<listeneri public="1" set="method" line="246" static="1"><f a="param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></listeneri>
		<listener3i public="1" set="method" line="247" static="1"><f a="param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></listener3i>
		<listeneriv public="1" set="method" line="248" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></listeneriv>
		<getListenerf public="1" set="method" line="251" static="1"><f a="param">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
</f></getListenerf>
		<getListener3f public="1" set="method" line="254" static="1"><f a="param:values">
	<x path="Int"/>
	<c path="Array"><t path="hxd.snd.openal._Emulator.F32"/></c>
	<x path="Void"/>
</f></getListener3f>
		<getListenerfv public="1" set="method" line="258" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getListenerfv>
		<getListeneri public="1" set="method" line="261" static="1"><f a="param">
	<x path="Int"/>
	<x path="Int"/>
</f></getListeneri>
		<getListener3i public="1" set="method" line="264" static="1"><f a="param:values">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></getListener3i>
		<getListeneriv public="1" set="method" line="267" static="1"><f a="param:values">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getListeneriv>
		<genSources public="1" set="method" line="272" static="1"><f a="n:sources">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></genSources>
		<deleteSources public="1" set="method" line="277" static="1"><f a="n:sources">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></deleteSources>
		<isSource public="1" set="method" line="282" static="1"><f a="source">
	<c path="hxd.snd.openal.Source"/>
	<x path="Bool"/>
</f></isSource>
		<sourcef public="1" set="method" line="287" static="1"><f a="source:param:value">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></sourcef>
		<source3f public="1" set="method" line="305" static="1"><f a="source:param:value1:value2:value3">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></source3f>
		<sourcefv public="1" set="method" line="313" static="1"><f a="source:param:values">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourcefv>
		<sourcei public="1" set="method" line="319" static="1"><f a="source:param:value">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sourcei>
		<source3i public="1" set="method" line="342" static="1"><f a="source:param:value1:value2:value3">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></source3i>
		<sourceiv public="1" set="method" line="348" static="1"><f a="source:param:values">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourceiv>
		<getSourcef public="1" set="method" line="356" static="1"><f a="source:param">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
</f></getSourcef>
		<getSourcei public="1" set="method" line="376" static="1"><f a="source:param">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getSourcei>
		<getSource3f public="1" set="method" line="398" static="1"><f a="source:param:values">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<c path="Array"><t path="hxd.snd.openal._Emulator.F32"/></c>
	<x path="Void"/>
</f></getSource3f>
		<getSourcefv public="1" set="method" line="401" static="1"><f a="source:param:values">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getSourcefv>
		<getSource3i public="1" set="method" line="404" static="1"><f a="source:param:values">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></getSource3i>
		<getSourceiv public="1" set="method" line="407" static="1"><f a="source:param:values">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getSourceiv>
		<sourcePlayv public="1" set="method" line="412" static="1"><f a="n:sources">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourcePlayv>
		<sourceStopv public="1" set="method" line="415" static="1"><f a="n:sources">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourceStopv>
		<sourceRewindv public="1" set="method" line="418" static="1"><f a="n:sources">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourceRewindv>
		<sourcePausev public="1" set="method" line="421" static="1"><f a="n:sources">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourcePausev>
		<sourcePlay public="1" set="method" line="425" static="1"><f a="source">
	<c path="hxd.snd.openal.Source"/>
	<x path="Void"/>
</f></sourcePlay>
		<sourceStop public="1" set="method" line="429" static="1"><f a="source">
	<c path="hxd.snd.openal.Source"/>
	<x path="Void"/>
</f></sourceStop>
		<sourceRewind public="1" set="method" line="434" static="1"><f a="source">
	<c path="hxd.snd.openal.Source"/>
	<x path="Void"/>
</f></sourceRewind>
		<sourcePause public="1" set="method" line="437" static="1"><f a="source">
	<c path="hxd.snd.openal.Source"/>
	<x path="Void"/>
</f></sourcePause>
		<sourceQueueBuffers public="1" set="method" line="442" static="1"><f a="source:nb:buffers">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourceQueueBuffers>
		<sourceUnqueueBuffers public="1" set="method" line="451" static="1"><f a="source:nb:buffers">
	<c path="hxd.snd.openal.Source"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></sourceUnqueueBuffers>
		<genBuffers public="1" set="method" line="467" static="1"><f a="n:buffers">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></genBuffers>
		<deleteBuffers public="1" set="method" line="471" static="1"><f a="n:buffers">
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></deleteBuffers>
		<isBuffer public="1" set="method" line="475" static="1"><f a="buffer">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Bool"/>
</f></isBuffer>
		<bufferData public="1" set="method" line="480" static="1">
			<f a="buffer:format:data:size:freq">
				<c path="hxd.snd.openal.Buffer"/>
				<x path="Int"/>
				<t path="hxd.snd.openal._Emulator.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</bufferData>
		<bufferf public="1" set="method" line="535" static="1"><f a="buffer:param:value">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></bufferf>
		<buffer3f public="1" set="method" line="541" static="1"><f a="buffer:param:value1:value2:value3">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
	<x path="Void"/>
</f></buffer3f>
		<bufferfv public="1" set="method" line="547" static="1"><f a="buffer:param:values">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></bufferfv>
		<bufferi public="1" set="method" line="553" static="1"><f a="buffer:param:value">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferi>
		<buffer3i public="1" set="method" line="559" static="1"><f a="buffer:param:value1:value2:value3">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></buffer3i>
		<bufferiv public="1" set="method" line="565" static="1"><f a="buffer:param:values">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></bufferiv>
		<getBufferf public="1" set="method" line="573" static="1"><f a="buffer:param">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.F32"/>
</f></getBufferf>
		<getBuffer3f public="1" set="method" line="576" static="1"><f a="buffer:param:values">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<c path="Array"><t path="hxd.snd.openal._Emulator.F32"/></c>
	<x path="Void"/>
</f></getBuffer3f>
		<getBufferfv public="1" set="method" line="579" static="1"><f a="buffer:param:values">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getBufferfv>
		<getBufferi public="1" set="method" line="582" static="1"><f a="buffer:param">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getBufferi>
		<getBuffer3i public="1" set="method" line="591" static="1"><f a="buffer:param:values">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></getBuffer3i>
		<getBufferiv public="1" set="method" line="594" static="1"><f a="buffer:param:values">
	<c path="hxd.snd.openal.Buffer"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getBufferiv>
		<FORMAT_MONOF32 public="1" get="inline" set="null" expr="0x1110" line="601" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1110</e></m></meta>
		</FORMAT_MONOF32>
		<FORMAT_STEREOF32 public="1" get="inline" set="null" expr="0x1111" line="602" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1111</e></m></meta>
		</FORMAT_STEREOF32>
		<NONE public="1" get="inline" set="null" expr="0" line="608" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NONE>
		<FALSE public="1" get="inline" set="null" expr="0" line="609" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</FALSE>
		<TRUE public="1" get="inline" set="null" expr="1" line="610" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</TRUE>
		<SOURCE_RELATIVE public="1" get="inline" set="null" expr="0x202" line="612" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x202</e></m></meta>
		</SOURCE_RELATIVE>
		<CONE_INNER_ANGLE public="1" get="inline" set="null" expr="0x1001" line="613" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1001</e></m></meta>
		</CONE_INNER_ANGLE>
		<CONE_OUTER_ANGLE public="1" get="inline" set="null" expr="0x1002" line="614" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1002</e></m></meta>
		</CONE_OUTER_ANGLE>
		<PITCH public="1" get="inline" set="null" expr="0x1003" line="615" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1003</e></m></meta>
		</PITCH>
		<POSITION public="1" get="inline" set="null" expr="0x1004" line="617" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1004</e></m></meta>
		</POSITION>
		<DIRECTION public="1" get="inline" set="null" expr="0x1005" line="618" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1005</e></m></meta>
		</DIRECTION>
		<VELOCITY public="1" get="inline" set="null" expr="0x1006" line="620" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1006</e></m></meta>
		</VELOCITY>
		<LOOPING public="1" get="inline" set="null" expr="0x1007" line="621" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1007</e></m></meta>
		</LOOPING>
		<BUFFER public="1" get="inline" set="null" expr="0x1009" line="622" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1009</e></m></meta>
		</BUFFER>
		<GAIN public="1" get="inline" set="null" expr="0x100A" line="624" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100A</e></m></meta>
		</GAIN>
		<MIN_GAIN public="1" get="inline" set="null" expr="0x100D" line="625" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100D</e></m></meta>
		</MIN_GAIN>
		<MAX_GAIN public="1" get="inline" set="null" expr="0x100E" line="626" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100E</e></m></meta>
		</MAX_GAIN>
		<ORIENTATION public="1" get="inline" set="null" expr="0x100F" line="627" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100F</e></m></meta>
		</ORIENTATION>
		<SOURCE_STATE public="1" get="inline" set="null" expr="0x1010" line="628" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1010</e></m></meta>
		</SOURCE_STATE>
		<INITIAL public="1" get="inline" set="null" expr="0x1011" line="631" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1011</e></m></meta>
		</INITIAL>
		<PLAYING public="1" get="inline" set="null" expr="0x1012" line="632" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1012</e></m></meta>
		</PLAYING>
		<PAUSED public="1" get="inline" set="null" expr="0x1013" line="633" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1013</e></m></meta>
		</PAUSED>
		<STOPPED public="1" get="inline" set="null" expr="0x1014" line="634" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1014</e></m></meta>
		</STOPPED>
		<BUFFERS_QUEUED public="1" get="inline" set="null" expr="0x1015" line="636" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1015</e></m></meta>
		</BUFFERS_QUEUED>
		<BUFFERS_PROCESSED public="1" get="inline" set="null" expr="0x1016" line="637" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1016</e></m></meta>
		</BUFFERS_PROCESSED>
		<REFERENCE_DISTANCE public="1" get="inline" set="null" expr="0x1020" line="639" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1020</e></m></meta>
		</REFERENCE_DISTANCE>
		<ROLLOFF_FACTOR public="1" get="inline" set="null" expr="0x1021" line="640" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1021</e></m></meta>
		</ROLLOFF_FACTOR>
		<CONE_OUTER_GAIN public="1" get="inline" set="null" expr="0x1022" line="641" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1022</e></m></meta>
		</CONE_OUTER_GAIN>
		<MAX_DISTANCE public="1" get="inline" set="null" expr="0x1023" line="642" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1023</e></m></meta>
		</MAX_DISTANCE>
		<SEC_OFFSET public="1" get="inline" set="null" expr="0x1024" line="644" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1024</e></m></meta>
		</SEC_OFFSET>
		<SAMPLE_OFFSET public="1" get="inline" set="null" expr="0x1025" line="645" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1025</e></m></meta>
		</SAMPLE_OFFSET>
		<BYTE_OFFSET public="1" get="inline" set="null" expr="0x1026" line="646" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1026</e></m></meta>
		</BYTE_OFFSET>
		<SOURCE_TYPE public="1" get="inline" set="null" expr="0x1027" line="647" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1027</e></m></meta>
		</SOURCE_TYPE>
		<STATIC public="1" get="inline" set="null" expr="0x1028" line="650" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1028</e></m></meta>
		</STATIC>
		<STREAMING public="1" get="inline" set="null" expr="0x1029" line="651" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1029</e></m></meta>
		</STREAMING>
		<UNDETERMINED public="1" get="inline" set="null" expr="0x1030" line="652" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1030</e></m></meta>
		</UNDETERMINED>
		<FORMAT_MONO8 public="1" get="inline" set="null" expr="0x1100" line="655" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1100</e></m></meta>
		</FORMAT_MONO8>
		<FORMAT_MONO16 public="1" get="inline" set="null" expr="0x1101" line="656" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1101</e></m></meta>
		</FORMAT_MONO16>
		<FORMAT_STEREO8 public="1" get="inline" set="null" expr="0x1102" line="657" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1102</e></m></meta>
		</FORMAT_STEREO8>
		<FORMAT_STEREO16 public="1" get="inline" set="null" expr="0x1103" line="658" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1103</e></m></meta>
		</FORMAT_STEREO16>
		<FREQUENCY public="1" get="inline" set="null" expr="0x2001" line="661" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2001</e></m></meta>
		</FREQUENCY>
		<BITS public="1" get="inline" set="null" expr="0x2002" line="662" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2002</e></m></meta>
		</BITS>
		<CHANNELS public="1" get="inline" set="null" expr="0x2003" line="663" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2003</e></m></meta>
		</CHANNELS>
		<SIZE public="1" get="inline" set="null" expr="0x2004" line="664" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2004</e></m></meta>
		</SIZE>
		<UNUSED public="1" get="inline" set="null" expr="0x2010" line="667" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2010</e></m></meta>
		</UNUSED>
		<PENDING public="1" get="inline" set="null" expr="0x2011" line="668" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2011</e></m></meta>
		</PENDING>
		<PROCESSED public="1" get="inline" set="null" expr="0x2012" line="669" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2012</e></m></meta>
		</PROCESSED>
		<NO_ERROR public="1" get="inline" set="null" expr="0" line="672" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NO_ERROR>
		<INVALID_NAME public="1" get="inline" set="null" expr="0xA001" line="673" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA001</e></m></meta>
		</INVALID_NAME>
		<INVALID_ENUM public="1" get="inline" set="null" expr="0xA002" line="674" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA002</e></m></meta>
		</INVALID_ENUM>
		<INVALID_VALUE public="1" get="inline" set="null" expr="0xA003" line="675" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA003</e></m></meta>
		</INVALID_VALUE>
		<INVALID_OPERATION public="1" get="inline" set="null" expr="0xA004" line="676" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA004</e></m></meta>
		</INVALID_OPERATION>
		<OUT_OF_MEMORY public="1" get="inline" set="null" expr="0xA005" line="677" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA005</e></m></meta>
		</OUT_OF_MEMORY>
		<VENDOR public="1" get="inline" set="null" expr="0xB001" line="680" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB001</e></m></meta>
		</VENDOR>
		<VERSION public="1" get="inline" set="null" expr="0xB002" line="681" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB002</e></m></meta>
		</VERSION>
		<RENDERER public="1" get="inline" set="null" expr="0xB003" line="682" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB003</e></m></meta>
		</RENDERER>
		<EXTENSIONS public="1" get="inline" set="null" expr="0xB004" line="683" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB004</e></m></meta>
		</EXTENSIONS>
		<DOPPLER_FACTOR public="1" get="inline" set="null" expr="0xC000" line="686" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xC000</e></m></meta>
		</DOPPLER_FACTOR>
		<DOPPLER_VELOCITY public="1" get="inline" set="null" expr="0xC001" line="687" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xC001</e></m></meta>
		</DOPPLER_VELOCITY>
		<SPEED_OF_SOUND public="1" get="inline" set="null" expr="0xC003" line="688" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xC003</e></m></meta>
		</SPEED_OF_SOUND>
		<DISTANCE_MODEL public="1" get="inline" set="null" expr="0xD000" line="689" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD000</e></m></meta>
		</DISTANCE_MODEL>
		<INVERSE_DISTANCE public="1" get="inline" set="null" expr="0xD001" line="692" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD001</e></m></meta>
		</INVERSE_DISTANCE>
		<INVERSE_DISTANCE_CLAMPED public="1" get="inline" set="null" expr="0xD002" line="693" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD002</e></m></meta>
		</INVERSE_DISTANCE_CLAMPED>
		<LINEAR_DISTANCE public="1" get="inline" set="null" expr="0xD003" line="694" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD003</e></m></meta>
		</LINEAR_DISTANCE>
		<LINEAR_DISTANCE_CLAMPED public="1" get="inline" set="null" expr="0xD004" line="695" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD004</e></m></meta>
		</LINEAR_DISTANCE_CLAMPED>
		<EXPONENT_DISTANCE public="1" get="inline" set="null" expr="0xD005" line="696" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD005</e></m></meta>
		</EXPONENT_DISTANCE>
		<EXPONENT_DISTANCE_CLAMPED public="1" get="inline" set="null" expr="0xD006" line="697" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD006</e></m></meta>
		</EXPONENT_DISTANCE_CLAMPED>
		<haxe_doc>On platforms that don't have native support for OpenAL, the Driver uses this
	emulator that only requires a NativeChannel implementation</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.Device" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx" module="hxd.snd.openal.Emulator">
		<new public="1" set="method" line="705"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.Context" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx" module="hxd.snd.openal.Emulator">
		<device public="1"><c path="hxd.snd.openal.Device"/></device>
		<new public="1" set="method" line="711"><f a="d">
	<c path="hxd.snd.openal.Device"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.ALC" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx" module="hxd.snd.openal.Emulator">
		<ctx expr="null" line="718" static="1">
			<c path="hxd.snd.openal.Context"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</ctx>
		<getError public="1" set="method" line="720" static="1"><f a="device">
	<c path="hxd.snd.openal.Device"/>
	<x path="Int"/>
</f></getError>
		<createContext public="1" set="method" line="725" static="1"><f a="device:attrlist">
	<c path="hxd.snd.openal.Device"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<c path="hxd.snd.openal.Context"/>
</f></createContext>
		<makeContextCurrent public="1" set="method" line="729" static="1"><f a="context">
	<c path="hxd.snd.openal.Context"/>
	<x path="Bool"/>
</f></makeContextCurrent>
		<processContext public="1" set="method" line="734" static="1"><f a="context">
	<c path="hxd.snd.openal.Context"/>
	<x path="Void"/>
</f></processContext>
		<suspendContext public="1" set="method" line="737" static="1"><f a="context">
	<c path="hxd.snd.openal.Context"/>
	<x path="Void"/>
</f></suspendContext>
		<destroyContext public="1" set="method" line="740" static="1"><f a="context">
	<c path="hxd.snd.openal.Context"/>
	<x path="Void"/>
</f></destroyContext>
		<getCurrentContext public="1" set="method" line="743" static="1"><f a=""><c path="hxd.snd.openal.Context"/></f></getCurrentContext>
		<getContextsDevice public="1" set="method" line="747" static="1"><f a="context">
	<c path="hxd.snd.openal.Context"/>
	<c path="hxd.snd.openal.Device"/>
</f></getContextsDevice>
		<openDevice public="1" set="method" line="752" static="1"><f a="devicename">
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<c path="hxd.snd.openal.Device"/>
</f></openDevice>
		<closeDevice public="1" set="method" line="756" static="1"><f a="device">
	<c path="hxd.snd.openal.Device"/>
	<x path="Bool"/>
</f></closeDevice>
		<loadExtensions public="1" set="method" line="761" static="1"><f a="alDevice">
	<c path="hxd.snd.openal.Device"/>
	<x path="Void"/>
</f></loadExtensions>
		<isExtensionPresent public="1" set="method" line="763" static="1"><f a="device:extname">
	<c path="hxd.snd.openal.Device"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Bool"/>
</f></isExtensionPresent>
		<getEnumValue public="1" set="method" line="766" static="1"><f a="device:enumname">
	<c path="hxd.snd.openal.Device"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Int"/>
</f></getEnumValue>
		<getString public="1" set="method" line="772" static="1"><f a="device:param">
	<c path="hxd.snd.openal.Device"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
</f></getString>
		<getIntegerv public="1" set="method" line="775" static="1"><f a="device:param:size:values">
	<c path="hxd.snd.openal.Device"/>
	<x path="Int"/>
	<x path="Int"/>
	<t path="hxd.snd.openal._Emulator.Bytes"/>
	<x path="Void"/>
</f></getIntegerv>
		<FALSE public="1" get="inline" set="null" expr="0" line="793" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</FALSE>
		<TRUE public="1" get="inline" set="null" expr="1" line="794" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</TRUE>
		<FREQUENCY public="1" get="inline" set="null" expr="0x1007" line="797" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1007</e></m></meta>
		</FREQUENCY>
		<REFRESH public="1" get="inline" set="null" expr="0x1008" line="798" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1008</e></m></meta>
		</REFRESH>
		<SYNC public="1" get="inline" set="null" expr="0x1009" line="799" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1009</e></m></meta>
		</SYNC>
		<MONO_SOURCES public="1" get="inline" set="null" expr="0x1010" line="800" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1010</e></m></meta>
		</MONO_SOURCES>
		<STEREO_SOURCES public="1" get="inline" set="null" expr="0x1011" line="801" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1011</e></m></meta>
		</STEREO_SOURCES>
		<NO_ERROR public="1" get="inline" set="null" expr="0" line="804" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NO_ERROR>
		<INVALID_DEVICE public="1" get="inline" set="null" expr="0xA001" line="805" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA001</e></m></meta>
		</INVALID_DEVICE>
		<INVALID_CONTEXT public="1" get="inline" set="null" expr="0xA002" line="806" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA002</e></m></meta>
		</INVALID_CONTEXT>
		<INVALID_ENUM public="1" get="inline" set="null" expr="0xA003" line="807" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA003</e></m></meta>
		</INVALID_ENUM>
		<INVALID_VALUE public="1" get="inline" set="null" expr="0xA004" line="808" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA004</e></m></meta>
		</INVALID_VALUE>
		<OUT_OF_MEMORY public="1" get="inline" set="null" expr="0xA005" line="809" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA005</e></m></meta>
		</OUT_OF_MEMORY>
		<MAJOR_VERSION public="1" get="inline" set="null" expr="0x1000" line="812" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1000</e></m></meta>
		</MAJOR_VERSION>
		<MINOR_VERSION public="1" get="inline" set="null" expr="0x1001" line="813" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1001</e></m></meta>
		</MINOR_VERSION>
		<ATTRIBUTES_SIZE public="1" get="inline" set="null" expr="0x1002" line="816" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1002</e></m></meta>
		</ATTRIBUTES_SIZE>
		<ALL_ATTRIBUTES public="1" get="inline" set="null" expr="0x1003" line="817" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1003</e></m></meta>
		</ALL_ATTRIBUTES>
		<DEFAULT_DEVICE_SPECIFIER public="1" get="inline" set="null" expr="0x1004" line="820" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1004</e></m></meta>
		</DEFAULT_DEVICE_SPECIFIER>
		<DEVICE_SPECIFIER public="1" get="inline" set="null" expr="0x1005" line="821" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1005</e></m></meta>
		</DEVICE_SPECIFIER>
		<EXTENSIONS public="1" get="inline" set="null" expr="0x1006" line="822" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1006</e></m></meta>
		</EXTENSIONS>
		<EXT_CAPTURE public="1" get="inline" set="null" expr="1" line="825" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</EXT_CAPTURE>
		<CAPTURE_DEVICE_SPECIFIER public="1" get="inline" set="null" expr="0x310" line="826" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x310</e></m></meta>
		</CAPTURE_DEVICE_SPECIFIER>
		<CAPTURE_DEFAULT_DEVICE_SPECIFIER public="1" get="inline" set="null" expr="0x311" line="827" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x311</e></m></meta>
		</CAPTURE_DEFAULT_DEVICE_SPECIFIER>
		<CAPTURE_SAMPLES public="1" get="inline" set="null" expr="0x312" line="828" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x312</e></m></meta>
		</CAPTURE_SAMPLES>
		<ENUMERATE_ALL_EXT public="1" get="inline" set="null" expr="1" line="831" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</ENUMERATE_ALL_EXT>
		<DEFAULT_ALL_DEVICES_SPECIFIER public="1" get="inline" set="null" expr="0x1012" line="832" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1012</e></m></meta>
		</DEFAULT_ALL_DEVICES_SPECIFIER>
		<ALL_DEVICES_SPECIFIER public="1" get="inline" set="null" expr="0x1013" line="833" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1013</e></m></meta>
		</ALL_DEVICES_SPECIFIER>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxd.snd.openal.EFX" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxd/snd/openal/Emulator.hx" module="hxd.snd.openal.Emulator">
		<EFX_MAJOR_VERSION public="1" get="inline" set="null" expr="0x20001" line="840" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x20001</e></m></meta>
		</EFX_MAJOR_VERSION>
		<EFX_MINOR_VERSION public="1" get="inline" set="null" expr="0x20002" line="841" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x20002</e></m></meta>
		</EFX_MINOR_VERSION>
		<MAX_AUXILIARY_SENDS public="1" get="inline" set="null" expr="0x20003" line="842" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x20003</e></m></meta>
		</MAX_AUXILIARY_SENDS>
		<METERS_PER_UNIT public="1" get="inline" set="null" expr="0x20004" line="845" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x20004</e></m></meta>
		</METERS_PER_UNIT>
		<DIRECT_FILTER public="1" get="inline" set="null" expr="0x20005" line="848" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x20005</e></m></meta>
		</DIRECT_FILTER>
		<FILTER_NULL public="1" get="inline" set="null" expr="0x0000" line="849" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0000</e></m></meta>
		</FILTER_NULL>
	</class>
	<enum path="hxsl.Type" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<TVoid/>
		<TInt/>
		<TBool/>
		<TFloat/>
		<TString/>
		<TVec a="size:t">
			<x path="Int"/>
			<e path="hxsl.VecType"/>
		</TVec>
		<TMat3/>
		<TMat4/>
		<TMat3x4/>
		<TBytes a="size"><x path="Int"/></TBytes>
		<TSampler2D/>
		<TSampler2DArray/>
		<TSamplerCube/>
		<TStruct a="vl"><c path="Array"><t path="hxsl.TVar"/></c></TStruct>
		<TFun a="variants"><c path="Array"><t path="hxsl.FunType"/></c></TFun>
		<TArray a="t:size">
			<e path="hxsl.Type"/>
			<e path="hxsl.SizeDecl"/>
		</TArray>
		<TBuffer a="t:size">
			<e path="hxsl.Type"/>
			<e path="hxsl.SizeDecl"/>
		</TBuffer>
		<TChannel a="size"><x path="Int"/></TChannel>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="hxsl.VecType" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<VInt/>
		<VFloat/>
		<VBool/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hxsl.SizeDecl" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<SConst a="v"><x path="Int"/></SConst>
		<SVar a="v"><t path="hxsl.TVar"/></SVar>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hxsl.FunType" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<ret><e path="hxsl.Type"/></ret>
	<args><c path="Array"><a>
	<type><e path="hxsl.Type"/></type>
	<name><c path="String"/></name>
</a></c></args>
</a></typedef>
	<class path="hxsl.Error" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<t public="1" set="method" line="51" static="1"><f a="msg:pos">
	<c path="String"/>
	<t path="hxsl.Position"/>
	<d/>
</f></t>
		<msg public="1"><c path="String"/></msg>
		<pos public="1"><t path="hxsl.Position"/></pos>
		<toString public="1" set="method" line="47"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="42"><f a="msg:pos">
	<c path="String"/>
	<t path="hxsl.Position"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxsl.Position" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><t path="haxe.macro.Position"/></typedef>
	<typedef path="hxsl.Expr" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<pos><t path="hxsl.Position"/></pos>
	<expr><e path="hxsl.ExprDef"/></expr>
</a></typedef>
	<typedef path="hxsl.Binop" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><e path="haxe.macro.Binop"/></typedef>
	<typedef path="hxsl.Unop" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><e path="haxe.macro.Unop"/></typedef>
	<enum path="hxsl.VarKind" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<Global/>
		<Input/>
		<Param/>
		<Var/>
		<Local/>
		<Output/>
		<Function/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hxsl.VarQualifier" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<Const a="?max"><x path="Int"/></Const>
		<Private/>
		<Nullable/>
		<PerObject/>
		<Name a="n"><c path="String"/></Name>
		<Shared/>
		<Precision a="p"><e path="hxsl.Prec"/></Precision>
		<Range a="min:max">
			<x path="Float"/>
			<x path="Float"/>
		</Range>
		<Ignore/>
		<PerInstance a="v"><x path="Int"/></PerInstance>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="hxsl.Prec" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<Low/>
		<Medium/>
		<High/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<typedef path="hxsl.VarDecl" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<type><x path="Null"><e path="hxsl.Type"/></x></type>
	<qualifiers><c path="Array"><e path="hxsl.VarQualifier"/></c></qualifiers>
	<name><c path="String"/></name>
	<kind><x path="Null"><e path="hxsl.VarKind"/></x></kind>
	<expr><x path="Null"><t path="hxsl.Expr"/></x></expr>
</a></typedef>
	<typedef path="hxsl.FunDecl" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<ret><x path="Null"><e path="hxsl.Type"/></x></ret>
	<name><c path="String"/></name>
	<expr><t path="hxsl.Expr"/></expr>
	<args><c path="Array"><t path="hxsl.VarDecl"/></c></args>
</a></typedef>
	<enum path="hxsl.Const" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<CNull/>
		<CBool a="b"><x path="Bool"/></CBool>
		<CInt a="v"><x path="Int"/></CInt>
		<CFloat a="v"><x path="Float"/></CFloat>
		<CString a="v"><c path="String"/></CString>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<enum path="hxsl.ExprDef" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<EConst a="c"><e path="hxsl.Const"/></EConst>
		<EIdent a="i"><c path="String"/></EIdent>
		<EParenthesis a="e"><t path="hxsl.Expr"/></EParenthesis>
		<EField a="e:f">
			<t path="hxsl.Expr"/>
			<c path="String"/>
		</EField>
		<EBinop a="op:e1:e2">
			<t path="hxsl.Binop"/>
			<t path="hxsl.Expr"/>
			<t path="hxsl.Expr"/>
		</EBinop>
		<EUnop a="op:e1">
			<t path="hxsl.Unop"/>
			<t path="hxsl.Expr"/>
		</EUnop>
		<ECall a="e:args">
			<t path="hxsl.Expr"/>
			<c path="Array"><t path="hxsl.Expr"/></c>
		</ECall>
		<EBlock a="el"><c path="Array"><t path="hxsl.Expr"/></c></EBlock>
		<EVars a="v"><c path="Array"><t path="hxsl.VarDecl"/></c></EVars>
		<EFunction a="f"><t path="hxsl.FunDecl"/></EFunction>
		<EIf a="econd:eif:eelse">
			<t path="hxsl.Expr"/>
			<t path="hxsl.Expr"/>
			<x path="Null"><t path="hxsl.Expr"/></x>
		</EIf>
		<EDiscard/>
		<EFor a="v:loop:block">
			<c path="String"/>
			<t path="hxsl.Expr"/>
			<t path="hxsl.Expr"/>
		</EFor>
		<EReturn a="?e"><t path="hxsl.Expr"/></EReturn>
		<EBreak/>
		<EContinue/>
		<EArray a="e:eindex">
			<t path="hxsl.Expr"/>
			<t path="hxsl.Expr"/>
		</EArray>
		<EArrayDecl a="el"><c path="Array"><t path="hxsl.Expr"/></c></EArrayDecl>
		<ESwitch a="e:cases:def">
			<t path="hxsl.Expr"/>
			<c path="Array"><a>
	<values><c path="Array"><t path="hxsl.Expr"/></c></values>
	<expr><t path="hxsl.Expr"/></expr>
</a></c>
			<x path="Null"><t path="hxsl.Expr"/></x>
		</ESwitch>
		<EWhile a="cond:loop:normalWhile">
			<t path="hxsl.Expr"/>
			<t path="hxsl.Expr"/>
			<x path="Bool"/>
		</EWhile>
		<EMeta a="name:args:e">
			<c path="String"/>
			<c path="Array"><t path="hxsl.Expr"/></c>
			<t path="hxsl.Expr"/>
		</EMeta>
	</enum>
	<typedef path="hxsl.TVar" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<type><e path="hxsl.Type"/></type>
	<qualifiers>
		<x path="Null"><c path="Array"><e path="hxsl.VarQualifier"/></c></x>
		<meta><m n=":optional"/></meta>
	</qualifiers>
	<parent>
		<x path="Null"><t path="hxsl.TVar"/></x>
		<meta><m n=":optional"/></meta>
	</parent>
	<name><c path="String"/></name>
	<kind><e path="hxsl.VarKind"/></kind>
	<id><x path="Int"/></id>
</a></typedef>
	<typedef path="hxsl.TFunction" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<ret><e path="hxsl.Type"/></ret>
	<ref><t path="hxsl.TVar"/></ref>
	<kind><e path="hxsl.FunctionKind"/></kind>
	<expr><t path="hxsl.TExpr"/></expr>
	<args><c path="Array"><t path="hxsl.TVar"/></c></args>
</a></typedef>
	<enum path="hxsl.FunctionKind" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<Vertex/>
		<Fragment/>
		<Init/>
		<Helper/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hxsl.TGlobal" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<Radians/>
		<Degrees/>
		<Sin/>
		<Cos/>
		<Tan/>
		<Asin/>
		<Acos/>
		<Atan/>
		<Pow/>
		<Exp/>
		<Log/>
		<Exp2/>
		<Log2/>
		<Sqrt/>
		<Inversesqrt/>
		<Abs/>
		<Sign/>
		<Floor/>
		<Ceil/>
		<Fract/>
		<Mod/>
		<Min/>
		<Max/>
		<Clamp/>
		<Mix/>
		<Step/>
		<Smoothstep/>
		<Length/>
		<Distance/>
		<Dot/>
		<Cross/>
		<Normalize/>
		<LReflect/>
		<Texture/>
		<TextureLod/>
		<ToInt/>
		<ToFloat/>
		<ToBool/>
		<Vec2/>
		<Vec3/>
		<Vec4/>
		<IVec2/>
		<IVec3/>
		<IVec4/>
		<BVec2/>
		<BVec3/>
		<BVec4/>
		<Mat2/>
		<Mat3/>
		<Mat4/>
		<Mat3x4/>
		<Saturate/>
		<Pack/>
		<Unpack/>
		<PackNormal/>
		<UnpackNormal/>
		<ScreenToUv/>
		<UvToScreen/>
		<DFdx/>
		<DFdy/>
		<Fwidth/>
		<ChannelRead/>
		<ChannelReadLod/>
		<Trace/>
		<VertexID/>
		<InstanceID/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hxsl.Component" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<X/>
		<Y/>
		<Z/>
		<W/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hxsl.TExprDef" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<TConst a="c"><e path="hxsl.Const"/></TConst>
		<TVar a="v"><t path="hxsl.TVar"/></TVar>
		<TGlobal a="g"><e path="hxsl.TGlobal"/></TGlobal>
		<TParenthesis a="e"><t path="hxsl.TExpr"/></TParenthesis>
		<TBlock a="el"><c path="Array"><t path="hxsl.TExpr"/></c></TBlock>
		<TBinop a="op:e1:e2">
			<t path="hxsl.Binop"/>
			<t path="hxsl.TExpr"/>
			<t path="hxsl.TExpr"/>
		</TBinop>
		<TUnop a="op:e1">
			<t path="hxsl.Unop"/>
			<t path="hxsl.TExpr"/>
		</TUnop>
		<TVarDecl a="v:?init">
			<t path="hxsl.TVar"/>
			<t path="hxsl.TExpr"/>
		</TVarDecl>
		<TCall a="e:args">
			<t path="hxsl.TExpr"/>
			<c path="Array"><t path="hxsl.TExpr"/></c>
		</TCall>
		<TSwiz a="e:regs">
			<t path="hxsl.TExpr"/>
			<c path="Array"><e path="hxsl.Component"/></c>
		</TSwiz>
		<TIf a="econd:eif:eelse">
			<t path="hxsl.TExpr"/>
			<t path="hxsl.TExpr"/>
			<x path="Null"><t path="hxsl.TExpr"/></x>
		</TIf>
		<TDiscard/>
		<TReturn a="?e"><t path="hxsl.TExpr"/></TReturn>
		<TFor a="v:it:loop">
			<t path="hxsl.TVar"/>
			<t path="hxsl.TExpr"/>
			<t path="hxsl.TExpr"/>
		</TFor>
		<TContinue/>
		<TBreak/>
		<TArray a="e:index">
			<t path="hxsl.TExpr"/>
			<t path="hxsl.TExpr"/>
		</TArray>
		<TArrayDecl a="el"><c path="Array"><t path="hxsl.TExpr"/></c></TArrayDecl>
		<TSwitch a="e:cases:def">
			<t path="hxsl.TExpr"/>
			<c path="Array"><a>
	<values><c path="Array"><t path="hxsl.TExpr"/></c></values>
	<expr><t path="hxsl.TExpr"/></expr>
</a></c>
			<x path="Null"><t path="hxsl.TExpr"/></x>
		</TSwitch>
		<TWhile a="e:loop:normalWhile">
			<t path="hxsl.TExpr"/>
			<t path="hxsl.TExpr"/>
			<x path="Bool"/>
		</TWhile>
		<TMeta a="m:args:e">
			<c path="String"/>
			<c path="Array"><e path="hxsl.Const"/></c>
			<t path="hxsl.TExpr"/>
		</TMeta>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="hxsl.TExpr" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<t><e path="hxsl.Type"/></t>
	<p><t path="hxsl.Position"/></p>
	<e><e path="hxsl.TExprDef"/></e>
</a></typedef>
	<typedef path="hxsl.ShaderData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><a>
	<vars><c path="Array"><t path="hxsl.TVar"/></c></vars>
	<name><c path="String"/></name>
	<funs><c path="Array"><t path="hxsl.TFunction"/></c></funs>
</a></typedef>
	<class path="hxsl.Tools" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<UID expr="0" line="285" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UID>
		<SWIZ public="1" expr="Component.createAll()" line="287" static="1">
			<c path="Array"><e path="hxsl.Component"/></c>
			<meta><m n=":value"><e>Component.createAll()</e></m></meta>
		</SWIZ>
		<MAX_CHANNELS_BITS public="1" expr="3" line="288" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</MAX_CHANNELS_BITS>
		<allocVarId public="1" set="method" line="290" static="1"><f a=""><x path="Int"/></f></allocVarId>
		<getName public="1" set="method" line="300" static="1"><f a="v">
	<t path="hxsl.TVar"/>
	<c path="String"/>
</f></getName>
		<getConstBits public="1" set="method" line="311" static="1"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Int"/>
</f></getConstBits>
		<isConst public="1" set="method" line="335" static="1"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Bool"/>
</f></isConst>
		<isStruct public="1" set="method" line="347" static="1"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Bool"/>
</f></isStruct>
		<isArray public="1" set="method" line="351" static="1"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Bool"/>
</f></isArray>
		<hasQualifier public="1" set="method" line="355" static="1"><f a="v:q">
	<t path="hxsl.TVar"/>
	<e path="hxsl.VarQualifier"/>
	<x path="Bool"/>
</f></hasQualifier>
		<isSampler public="1" set="method" line="363" static="1"><f a="t">
	<e path="hxsl.Type"/>
	<x path="Bool"/>
</f></isSampler>
		<toString public="1" set="method" line="372" static="1"><f a="t">
	<e path="hxsl.Type"/>
	<c path="String"/>
</f></toString>
		<toType public="1" set="method" line="389" static="1"><f a="t">
	<e path="hxsl.VecType"/>
	<e path="hxsl.Type"/>
</f></toType>
		<hasSideEffect public="1" set="method" line="397" static="1"><f a="e">
	<t path="hxsl.TExpr"/>
	<x path="Bool"/>
</f></hasSideEffect>
		<iter public="1" set="method" line="437" static="1"><f a="e:f">
	<t path="hxsl.TExpr"/>
	<f a="">
		<t path="hxsl.TExpr"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></iter>
		<map public="1" set="method" line="466" static="1"><f a="e:f">
	<t path="hxsl.TExpr"/>
	<f a="">
		<t path="hxsl.TExpr"/>
		<t path="hxsl.TExpr"/>
	</f>
	<t path="hxsl.TExpr"/>
</f></map>
		<size public="1" set="method" line="488" static="1"><f a="t">
	<e path="hxsl.Type"/>
	<x path="Int"/>
</f></size>
		<evalConst public="1" set="method" line="508" static="1"><f a="e">
	<t path="hxsl.TExpr"/>
	<d/>
</f></evalConst>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Tools2" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast">
		<toString public="1" set="method" line="533" static="1"><f a="g">
	<e path="hxsl.TGlobal"/>
	<c path="String"/>
</f></toString>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Tools3" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><toString public="1" set="method" line="542" static="1"><f a="s">
	<t path="hxsl.ShaderData"/>
	<c path="String"/>
</f></toString></class>
	<class path="hxsl.Tools4" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Ast.hx" module="hxsl.Ast"><toString public="1" set="method" line="550" static="1"><f a="e">
	<t path="hxsl.TExpr"/>
	<c path="String"/>
</f></toString></class>
	<class path="hxsl.SearchMap" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Cache.hx" module="hxsl.Cache">
		<linked public="1"><c path="hxsl.RuntimeShader"/></linked>
		<next public="1"><t path="Map">
	<x path="Int"/>
	<c path="hxsl.SearchMap"/>
</t></next>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Cache" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Cache.hx">
		<INST static="1"><c path="hxsl.Cache"/></INST>
		<get public="1" set="method" line="409" static="1"><f a=""><c path="hxsl.Cache"/></f></get>
		<set public="1" set="method" line="416" static="1"><f a="c">
	<c path="hxsl.Cache"/>
	<x path="Void"/>
</f></set>
		<clear public="1" set="method" line="420" static="1"><f a=""><x path="Void"/></f></clear>
		<linkCache><c path="hxsl.SearchMap"/></linkCache>
		<linkShaders><t path="Map">
	<c path="String"/>
	<c path="hxsl.Shader"/>
</t></linkShaders>
		<byID><t path="Map">
	<c path="String"/>
	<c path="hxsl.RuntimeShader"/>
</t></byID>
		<constsToGlobal public="1"><x path="Bool"/></constsToGlobal>
		<getLinkShader public="1" set="method" line="34">
			<f a="vars">
				<c path="Array"><e path="hxsl.Output"/></c>
				<x path="Null"><c path="hxsl.Shader"/></x>
			</f>
			<haxe_doc>Creates a shader that generate the output requested.</haxe_doc>
		</getLinkShader>
		<link public="1" set="method" line="152">
			<f a="shaders">
				<c path="hxsl.ShaderList"/>
				<c path="hxsl.RuntimeShader"/>
			</f>
			<meta><m n=":noDebug"/></meta>
		</link>
		<compileRuntimeShader set="method" line="169"><f a="shaders">
	<c path="hxsl.ShaderList"/>
	<c path="hxsl.RuntimeShader"/>
</f></compileRuntimeShader>
		<buildRuntimeShader set="method" line="301"><f a="vertex:fragment:paramVars">
	<t path="hxsl.ShaderData"/>
	<t path="hxsl.ShaderData"/>
	<t path="Map">
		<x path="Int"/>
		<a>
			<instance><x path="Int"/></instance>
			<index><x path="Int"/></index>
		</a>
	</t>
	<c path="hxsl.RuntimeShader"/>
</f></buildRuntimeShader>
		<initGlobals set="method" line="317"><f a="r:s">
	<c path="hxsl.RuntimeShader"/>
	<c path="hxsl.RuntimeShaderData"/>
	<x path="Void"/>
</f></initGlobals>
		<getPath set="method" line="331"><f a="v">
	<t path="hxsl.TVar"/>
	<c path="String"/>
</f></getPath>
		<flattenShader set="method" line="337"><f a="s:kind:params">
	<t path="hxsl.ShaderData"/>
	<e path="hxsl.FunctionKind"/>
	<t path="Map">
		<x path="Int"/>
		<a>
			<instance><x path="Int"/></instance>
			<index><x path="Int"/></index>
		</a>
	</t>
	<c path="hxsl.RuntimeShaderData"/>
</f></flattenShader>
		<new set="method" line="24"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxsl.Channel" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Channel.hx">
		<Unknown/>
		<R/>
		<G/>
		<B/>
		<A/>
		<PackedFloat/>
		<PackedNormal/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<typedef path="hxsl.ChannelTexture" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/ChannelTexture.hx"><a>
	<texture><t path="hxsl.ChannelTextureType"/></texture>
	<channel><e path="hxsl.Channel"/></channel>
</a></typedef>
	<class path="hxsl.Clone" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Clone.hx">
		<shaderData public="1" set="method" line="75" static="1"><f a="s">
	<t path="hxsl.ShaderData"/>
	<t path="hxsl.ShaderData"/>
</f></shaderData>
		<varMap public="1"><t path="Map">
	<x path="Int"/>
	<t path="hxsl.TVar"/>
</t></varMap>
		<tvar public="1" set="method" line="12"><f a="v">
	<t path="hxsl.TVar"/>
	<t path="hxsl.TVar"/>
</f></tvar>
		<tfun public="1" set="method" line="28"><f a="f">
	<t path="hxsl.TFunction"/>
	<t path="hxsl.TFunction"/>
</f></tfun>
		<ttype public="1" set="method" line="38"><f a="t">
	<e path="hxsl.Type"/>
	<e path="hxsl.Type"/>
</f></ttype>
		<texpr public="1" set="method" line="51"><f a="e">
	<t path="hxsl.TExpr"/>
	<t path="hxsl.TExpr"/>
</f></texpr>
		<shader public="1" set="method" line="67"><f a="s">
	<t path="hxsl.ShaderData"/>
	<t path="hxsl.ShaderData"/>
</f></shader>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl._Dce.Exit" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Dce.hx" private="1" module="hxsl.Dce"><new public="1" set="method" line="5"><f a=""><x path="Void"/></f></new></class>
	<class path="hxsl._Dce.VarDeps" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Dce.hx" private="1" module="hxsl.Dce">
		<v public="1"><t path="hxsl.TVar"/></v>
		<keep public="1"><x path="Bool"/></keep>
		<used public="1"><x path="Bool"/></used>
		<deps public="1"><t path="Map">
	<x path="Int"/>
	<c path="hxsl._Dce.VarDeps"/>
</t></deps>
		<new public="1" set="method" line="14"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Dce" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Dce.hx">
		<used><t path="Map">
	<x path="Int"/>
	<c path="hxsl._Dce.VarDeps"/>
</t></used>
		<channelVars><c path="Array"><t path="hxsl.TVar"/></c></channelVars>
		<markAsKeep><x path="Bool"/></markAsKeep>
		<debug get="inline" set="null" line="30"><f a="msg:?pos">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></debug>
		<dce public="1" set="method" line="37"><f a="vertex:fragment">
	<t path="hxsl.ShaderData"/>
	<t path="hxsl.ShaderData"/>
	<a>
		<vertex><t path="hxsl.ShaderData"/></vertex>
		<fragment><t path="hxsl.ShaderData"/></fragment>
	</a>
</f></dce>
		<get set="method" line="107"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Null"><c path="hxsl._Dce.VarDeps"/></x>
</f></get>
		<markRec set="method" line="116"><f a="v">
	<c path="hxsl._Dce.VarDeps"/>
	<x path="Void"/>
</f></markRec>
		<link set="method" line="124"><f a="v:writeTo">
	<t path="hxsl.TVar"/>
	<c path="Array"><c path="hxsl._Dce.VarDeps"/></c>
	<x path="Void"/>
</f></link>
		<check set="method" line="141"><f a="e:writeTo:isAffected">
	<t path="hxsl.TExpr"/>
	<c path="Array"><c path="hxsl._Dce.VarDeps"/></c>
	<c path="Array"><c path="hxsl._Dce.VarDeps"/></c>
	<x path="Void"/>
</f></check>
		<checkBranches set="method" line="203"><f a="e">
	<t path="hxsl.TExpr"/>
	<x path="Void"/>
</f></checkBranches>
		<mapExpr set="method" line="214"><f a="e:isVar">
	<t path="hxsl.TExpr"/>
	<x path="Bool"/>
	<t path="hxsl.TExpr"/>
</f></mapExpr>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Eval" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Eval.hx">
		<varMap public="1"><t path="Map">
	<t path="hxsl.TVar"/>
	<t path="hxsl.TVar"/>
</t></varMap>
		<inlineCalls public="1"><x path="Bool"/></inlineCalls>
		<unrollLoops public="1"><x path="Bool"/></unrollLoops>
		<eliminateConditionals public="1"><x path="Bool"/></eliminateConditionals>
		<constants><t path="Map">
	<x path="Int"/>
	<e path="hxsl.TExprDef"/>
</t></constants>
		<funMap><t path="Map">
	<t path="hxsl.TVar"/>
	<t path="hxsl.TFunction"/>
</t></funMap>
		<curFun><t path="hxsl.TFunction"/></curFun>
		<setConstant public="1" set="method" line="25"><f a="v:c">
	<t path="hxsl.TVar"/>
	<e path="hxsl.Const"/>
	<x path="Void"/>
</f></setConstant>
		<mapVar set="method" line="29"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Null"><t path="hxsl.TVar"/></x>
</f></mapVar>
		<eval public="1" set="method" line="73"><f a="s">
	<t path="hxsl.ShaderData"/>
	<t path="hxsl.ShaderData"/>
</f></eval>
		<markReturn><x path="Bool"/></markReturn>
		<hasReturn set="method" line="100"><f a="e">
	<t path="hxsl.TExpr"/>
	<x path="Bool"/>
</f></hasReturn>
		<hasReturnLoop set="method" line="106"><f a="e">
	<t path="hxsl.TExpr"/>
	<x path="Void"/>
</f></hasReturnLoop>
		<handleReturn set="method" line="115">
			<f a="e:?isFinal" v=":false">
				<t path="hxsl.TExpr"/>
				<x path="Bool"/>
				<t path="hxsl.TExpr"/>
			</f>
			<meta><m n=":value"><e>{ isFinal : false }</e></m></meta>
		</handleReturn>
		<handleReturnDef set="method" line="155"><f a="e">
	<t path="hxsl.TExpr"/>
	<t path="hxsl.TExpr"/>
</f></handleReturnDef>
		<evalCall set="method" line="159"><f a="g:args:oldArgs:pos">
	<e path="hxsl.TGlobal"/>
	<c path="Array"><t path="hxsl.TExpr"/></c>
	<c path="Array"><t path="hxsl.TExpr"/></c>
	<t path="hxsl.Position"/>
	<e path="hxsl.TExprDef"/>
</f></evalCall>
		<constantsToString set="method" line="212"><f a=""><c path="String"/></f></constantsToString>
		<evalExpr set="method" line="216">
			<f a="e:?isVal" v=":true">
				<t path="hxsl.TExpr"/>
				<x path="Bool"/>
				<t path="hxsl.TExpr"/>
			</f>
			<meta><m n=":value"><e>{ isVal : true }</e></m></meta>
		</evalExpr>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Evaluator : will substitute some variables (usually constants) by their runtime value and will
	evaluate and reduce the expression, unroll loops, etc.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl._Flatten.Alloc" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Flatten.hx" private="1" module="hxsl.Flatten">
		<t public="1"><e path="hxsl.VecType"/></t>
		<pos public="1"><x path="Int"/></pos>
		<size public="1"><x path="Int"/></size>
		<g public="1"><t path="hxsl.TVar"/></g>
		<v public="1"><x path="Null"><t path="hxsl.TVar"/></x></v>
		<new public="1" set="method" line="10"><f a="g:t:pos:size">
	<t path="hxsl.TVar"/>
	<e path="hxsl.VecType"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxsl.ARead" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Flatten.hx" module="hxsl.Flatten">
		<AIndex a="a"><c path="hxsl._Flatten.Alloc"/></AIndex>
		<AOffset a="a:stride:delta">
			<c path="hxsl._Flatten.Alloc"/>
			<x path="Int"/>
			<t path="hxsl.TExpr"/>
		</AOffset>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="hxsl.Flatten" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Flatten.hx">
		<globals><c path="Array"><t path="hxsl.TVar"/></c></globals>
		<params><c path="Array"><t path="hxsl.TVar"/></c></params>
		<outVars><c path="Array"><t path="hxsl.TVar"/></c></outVars>
		<varMap><t path="Map">
	<t path="hxsl.TVar"/>
	<c path="hxsl._Flatten.Alloc"/>
</t></varMap>
		<econsts><t path="hxsl.TExpr"/></econsts>
		<consts public="1"><c path="Array"><x path="Float"/></c></consts>
		<allocData public="1"><t path="Map">
	<t path="hxsl.TVar"/>
	<c path="Array"><c path="hxsl._Flatten.Alloc"/></c>
</t></allocData>
		<flatten public="1" set="method" line="36"><f a="s:kind:constsToGlobal">
	<t path="hxsl.ShaderData"/>
	<e path="hxsl.FunctionKind"/>
	<x path="Bool"/>
	<t path="hxsl.ShaderData"/>
</f></flatten>
		<mapFun set="method" line="96"><f a="f:mapExpr">
	<t path="hxsl.TFunction"/>
	<f a="">
		<t path="hxsl.TExpr"/>
		<t path="hxsl.TExpr"/>
	</f>
	<t path="hxsl.TFunction"/>
</f></mapFun>
		<mapExpr set="method" line="106"><f a="e">
	<t path="hxsl.TExpr"/>
	<t path="hxsl.TExpr"/>
</f></mapExpr>
		<mapConsts set="method" line="137"><f a="e">
	<t path="hxsl.TExpr"/>
	<t path="hxsl.TExpr"/>
</f></mapConsts>
		<allocConst set="method" line="200"><f a="v:p">
	<x path="Float"/>
	<t path="hxsl.Position"/>
	<t path="hxsl.TExpr"/>
</f></allocConst>
		<allocConsts set="method" line="209"><f a="va:p">
	<c path="Array"><x path="Float"/></c>
	<t path="hxsl.Position"/>
	<t path="hxsl.TExpr"/>
</f></allocConsts>
		<mkInt get="inline" set="null" line="250"><f a="v:pos">
	<x path="Int"/>
	<t path="hxsl.Position"/>
	<a>
		<t><e path="hxsl.Type"/></t>
		<p><t path="hxsl.Position"/></p>
		<e><e path="hxsl.TExprDef"/></e>
	</a>
</f></mkInt>
		<readIndex get="inline" set="null" line="254"><f a="a:index:pos">
	<c path="hxsl._Flatten.Alloc"/>
	<x path="Int"/>
	<t path="hxsl.Position"/>
	<t path="hxsl.TExpr"/>
</f></readIndex>
		<readOffset get="inline" set="null" line="258"><f a="a:stride:delta:index:pos">
	<c path="hxsl._Flatten.Alloc"/>
	<x path="Int"/>
	<t path="hxsl.TExpr"/>
	<x path="Int"/>
	<t path="hxsl.Position"/>
	<t path="hxsl.TExpr"/>
</f></readOffset>
		<access set="method" line="264"><f a="a:t:pos:acc">
	<c path="hxsl._Flatten.Alloc"/>
	<e path="hxsl.Type"/>
	<t path="hxsl.Position"/>
	<e path="hxsl.ARead"/>
	<t path="hxsl.TExpr"/>
</f></access>
		<optimize set="method" line="323"><f a="e">
	<t path="hxsl.TExpr"/>
	<a>
		<t><e path="hxsl.Type"/></t>
		<p><t path="hxsl.Position"/></p>
		<e><e path="hxsl.TExprDef"/></e>
	</a>
</f></optimize>
		<packTextures set="method" line="348"><f a="name:vars:t">
	<c path="String"/>
	<c path="Array"><t path="hxsl.TVar"/></c>
	<e path="hxsl.Type"/>
	<c path="Array"><c path="hxsl._Flatten.Alloc"/></c>
</f></packTextures>
		<packBuffers set="method" line="377"><f a="vars">
	<c path="Array"><t path="hxsl.TVar"/></c>
	<x path="Void"/>
</f></packBuffers>
		<pack set="method" line="396"><f a="name:kind:vars:t">
	<c path="String"/>
	<e path="hxsl.VarKind"/>
	<c path="Array"><t path="hxsl.TVar"/></c>
	<e path="hxsl.VecType"/>
	<t path="hxsl.TVar"/>
</f></pack>
		<varSize set="method" line="444"><f a="v:t">
	<e path="hxsl.Type"/>
	<e path="hxsl.VecType"/>
	<x path="Int"/>
</f></varSize>
		<gatherVar set="method" line="456"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></gatherVar>
		<new public="1" set="method" line="33"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="hxsl.GlobalSlot" params="T" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Globals.hx" module="hxsl.Globals">
		<this><x path="Int"/></this>
		<impl><class path="hxsl._Globals.GlobalSlot_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Globals.hx" private="1" module="hxsl.Globals">
	<_new public="1" get="inline" set="null" line="5" static="1">
		<f a="name">
			<c path="String"/>
			<x path="hxsl.GlobalSlot"><c path="hxsl.GlobalSlot.T"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<toInt public="1" get="inline" set="null" line="8" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toInt>
	<set public="1" get="inline" set="null" line="11" static="1">
		<f a="this:globals:v">
			<x path="Int"/>
			<c path="hxsl.Globals"/>
			<c path="hxsl.GlobalSlot.T"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set>
	<get public="1" get="inline" set="null" line="14" static="1">
		<f a="this:globals">
			<x path="Int"/>
			<c path="hxsl.Globals"/>
			<c path="hxsl.GlobalSlot.T"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get>
</class></impl>
	</abstract>
	<class path="hxsl._Globals.GlobalSlot_Impl_" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Globals.hx" private="1" module="hxsl.Globals">
		<_new public="1" get="inline" set="null" line="5" static="1">
			<f a="name">
				<c path="String"/>
				<x path="hxsl.GlobalSlot"><c path="hxsl.GlobalSlot.T"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<toInt public="1" get="inline" set="null" line="8" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toInt>
		<set public="1" get="inline" set="null" line="11" static="1">
			<f a="this:globals:v">
				<x path="Int"/>
				<c path="hxsl.Globals"/>
				<c path="hxsl.GlobalSlot.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set>
		<get public="1" get="inline" set="null" line="14" static="1">
			<f a="this:globals">
				<x path="Int"/>
				<c path="hxsl.Globals"/>
				<c path="hxsl.GlobalSlot.T"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get>
	</class>
	<class path="hxsl.Globals" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Globals.hx">
		<ALL static="1"><c path="Array"><c path="String"/></c></ALL>
		<MAP static="1"><t path="Map">
	<c path="String"/>
	<x path="Int"/>
</t></MAP>
		<allocID public="1" set="method" line="62" static="1"><f a="path">
	<c path="String"/>
	<x path="Null"><x path="Int"/></x>
</f></allocID>
		<getIDName public="1" set="method" line="79" static="1"><f a="id">
	<x path="Int"/>
	<c path="String"/>
</f></getIDName>
		<map><t path="Map">
	<x path="Int"/>
	<d/>
</t></map>
		<channels expr="[]">
			<c path="Array"><c path="h3d.mat.Texture"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</channels>
		<maxChannels><x path="Int"/></maxChannels>
		<set public="1" set="method" line="29"><f a="path:v">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></set>
		<get public="1" set="method" line="33"><f a="path">
	<c path="String"/>
	<d/>
</f></get>
		<fastSet public="1" get="inline" set="null" line="37"><f a="id:v">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></fastSet>
		<fastGet public="1" get="inline" set="null" line="41"><f a="id">
	<x path="Int"/>
	<d/>
</f></fastGet>
		<resetChannels public="1" get="inline" set="null" line="45"><f a=""><x path="Void"/></f></resetChannels>
		<allocChannelID public="1" set="method" line="49"><f a="t">
	<c path="h3d.mat.Texture"/>
	<x path="Int"/>
</f></allocChannelID>
		<new public="1" set="method" line="25"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl._Linker.AllocatedVar" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Linker.hx" private="1" module="hxsl.Linker">
		<id public="1"><x path="Int"/></id>
		<v public="1"><t path="hxsl.TVar"/></v>
		<path public="1"><c path="String"/></path>
		<merged public="1"><c path="Array"><t path="hxsl.TVar"/></c></merged>
		<kind public="1"><x path="Null"><e path="hxsl.FunctionKind"/></x></kind>
		<parent public="1"><c path="hxsl._Linker.AllocatedVar"/></parent>
		<instanceIndex public="1"><x path="Int"/></instanceIndex>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl._Linker.ShaderInfos" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Linker.hx" private="1" module="hxsl.Linker">
		<UID expr="0" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UID>
		<uid public="1"><x path="Int"/></uid>
		<name public="1"><c path="String"/></name>
		<priority public="1"><x path="Int"/></priority>
		<body public="1"><t path="hxsl.TExpr"/></body>
		<usedFunctions public="1"><c path="Array"><t path="hxsl.TFunction"/></c></usedFunctions>
		<deps public="1"><t path="Map">
	<c path="hxsl._Linker.ShaderInfos"/>
	<x path="Bool"/>
</t></deps>
		<read public="1"><t path="Map">
	<x path="Int"/>
	<c path="hxsl._Linker.AllocatedVar"/>
</t></read>
		<write public="1"><t path="Map">
	<x path="Int"/>
	<c path="hxsl._Linker.AllocatedVar"/>
</t></write>
		<processed public="1"><t path="Map">
	<x path="Int"/>
	<x path="Bool"/>
</t></processed>
		<vertex public="1"><x path="Null"><x path="Bool"/></x></vertex>
		<onStack public="1"><x path="Bool"/></onStack>
		<hasDiscard public="1"><x path="Bool"/></hasDiscard>
		<marked public="1"><x path="Null"><x path="Bool"/></x></marked>
		<new public="1" set="method" line="31"><f a="n:v">
	<c path="String"/>
	<x path="Null"><x path="Bool"/></x>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Linker" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Linker.hx">
		<allVars public="1"><c path="Array"><c path="hxsl._Linker.AllocatedVar"/></c></allVars>
		<varMap><t path="Map">
	<c path="String"/>
	<c path="hxsl._Linker.AllocatedVar"/>
</t></varMap>
		<curShader><c path="hxsl._Linker.ShaderInfos"/></curShader>
		<shaders><c path="Array"><c path="hxsl._Linker.ShaderInfos"/></c></shaders>
		<varIdMap><t path="Map">
	<x path="Int"/>
	<x path="Int"/>
</t></varIdMap>
		<locals><t path="Map">
	<x path="Int"/>
	<x path="Bool"/>
</t></locals>
		<curInstance><x path="Int"/></curInstance>
		<debugDepth expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</debugDepth>
		<debug get="inline" set="null" line="56"><f a="msg:?pos">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></debug>
		<error set="method" line="64"><f a="msg:p">
	<c path="String"/>
	<t path="hxsl.Position"/>
	<d/>
</f></error>
		<mergeVar set="method" line="68"><f a="path:v:v2:p">
	<c path="String"/>
	<t path="hxsl.TVar"/>
	<t path="hxsl.TVar"/>
	<t path="hxsl.Position"/>
	<x path="Void"/>
</f></mergeVar>
		<allocVar set="method" line="98"><f a="v:p:?path:?parent">
	<t path="hxsl.TVar"/>
	<t path="hxsl.Position"/>
	<c path="String"/>
	<c path="hxsl._Linker.AllocatedVar"/>
	<c path="hxsl._Linker.AllocatedVar"/>
</f></allocVar>
		<mapExprVar set="method" line="171"><f a="e">
	<t path="hxsl.TExpr"/>
	<a>
		<t><e path="hxsl.Type"/></t>
		<p><t path="hxsl.Position"/></p>
		<e><e path="hxsl.TExprDef"/></e>
	</a>
</f></mapExprVar>
		<addShader set="method" line="224"><f a="name:vertex:e:p">
	<c path="String"/>
	<x path="Null"><x path="Bool"/></x>
	<t path="hxsl.TExpr"/>
	<x path="Int"/>
	<c path="hxsl._Linker.ShaderInfos"/>
</f></addShader>
		<sortByPriorityDesc set="method" line="235"><f a="s1:s2">
	<c path="hxsl._Linker.ShaderInfos"/>
	<c path="hxsl._Linker.ShaderInfos"/>
	<x path="Int"/>
</f></sortByPriorityDesc>
		<buildDependency set="method" line="241"><f a="s:v:isWritten">
	<c path="hxsl._Linker.ShaderInfos"/>
	<c path="hxsl._Linker.AllocatedVar"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></buildDependency>
		<initDependencies set="method" line="269"><f a="s">
	<c path="hxsl._Linker.ShaderInfos"/>
	<x path="Void"/>
</f></initDependencies>
		<collect set="method" line="292"><f a="cur:out:vertex">
	<c path="hxsl._Linker.ShaderInfos"/>
	<c path="Array"><c path="hxsl._Linker.ShaderInfos"/></c>
	<x path="Bool"/>
	<x path="Void"/>
</f></collect>
		<uniqueLocals set="method" line="314"><f a="expr:locals">
	<t path="hxsl.TExpr"/>
	<t path="Map">
		<c path="String"/>
		<x path="Bool"/>
	</t>
	<x path="Void"/>
</f></uniqueLocals>
		<link public="1" set="method" line="333"><f a="shadersData">
	<c path="Array"><t path="hxsl.ShaderData"/></c>
	<t path="hxsl.ShaderData"/>
</f></link>
		<new public="1" set="method" line="53"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="hxsl.Output" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Output.hx">
		<Const a="v"><x path="Float"/></Const>
		<Value a="v:?size">
			<c path="String"/>
			<x path="Int"/>
		</Value>
		<PackNormal a="v"><e path="hxsl.Output"/></PackNormal>
		<PackFloat a="v"><e path="hxsl.Output"/></PackFloat>
		<Vec2 a="a"><c path="Array"><e path="hxsl.Output"/></c></Vec2>
		<Vec3 a="a"><c path="Array"><e path="hxsl.Output"/></c></Vec3>
		<Vec4 a="a"><c path="Array"><e path="hxsl.Output"/></c></Vec4>
		<Swiz a="a:swiz">
			<e path="hxsl.Output"/>
			<c path="Array"><e path="hxsl.Component"/></c>
		</Swiz>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="hxsl.Printer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Printer.hx">
		<SWIZ expr="[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;w&quot;]" line="129" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["x", "y", "z", "w"]</e></m></meta>
		</SWIZ>
		<opStr public="1" set="method" line="300" static="1"><f a="op">
	<t path="hxsl.Binop"/>
	<c path="String"/>
</f></opStr>
		<toString public="1" set="method" line="331" static="1">
			<f a="e:?varId" v=":false">
				<t path="hxsl.TExpr"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ varId : false }</e></m></meta>
		</toString>
		<shaderToString public="1" set="method" line="335" static="1">
			<f a="s:?varId" v=":false">
				<t path="hxsl.ShaderData"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ varId : false }</e></m></meta>
		</shaderToString>
		<check public="1" set="method" line="339" static="1"><f a="s:?from">
	<t path="hxsl.ShaderData"/>
	<c path="Array"><t path="hxsl.ShaderData"/></c>
	<x path="Void"/>
</f></check>
		<buffer><c path="StringBuf"/></buffer>
		<varId><x path="Bool"/></varId>
		<add get="inline" set="null" line="13"><f a="v">
	<d/>
	<x path="Void"/>
</f></add>
		<shaderString public="1" set="method" line="17"><f a="s">
	<t path="hxsl.ShaderData"/>
	<c path="String"/>
</f></shaderString>
		<varString public="1" set="method" line="32"><f a="v">
	<t path="hxsl.TVar"/>
	<c path="String"/>
</f></varString>
		<funString public="1" set="method" line="38"><f a="f">
	<t path="hxsl.TFunction"/>
	<c path="String"/>
</f></funString>
		<exprString public="1" set="method" line="44"><f a="e">
	<t path="hxsl.TExpr"/>
	<c path="String"/>
</f></exprString>
		<addVar set="method" line="50">
			<f a="v:defKind:?tabs:?parent" v="::&quot;&quot;:">
				<t path="hxsl.TVar"/>
				<e path="hxsl.VarKind"/>
				<c path="String"/>
				<t path="hxsl.TVar"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ tabs : "" }</e></m></meta>
		</addVar>
		<addFun set="method" line="103"><f a="f">
	<t path="hxsl.TFunction"/>
	<x path="Void"/>
</f></addFun>
		<addVarName set="method" line="119"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></addVarName>
		<addConst set="method" line="131"><f a="c">
	<e path="hxsl.Const"/>
	<x path="Void"/>
</f></addConst>
		<addExpr set="method" line="141"><f a="e:tabs">
	<t path="hxsl.TExpr"/>
	<c path="String"/>
	<x path="Void"/>
</f></addExpr>
		<new public="1" set="method" line="9">
			<f a="?varId" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ varId : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.AllocParam" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/RuntimeShader.hx" module="hxsl.RuntimeShader">
		<name public="1"><c path="String"/></name>
		<pos public="1"><x path="Int"/></pos>
		<instance public="1"><x path="Int"/></instance>
		<index public="1"><x path="Int"/></index>
		<type public="1"><e path="hxsl.Type"/></type>
		<perObjectGlobal public="1"><c path="hxsl.AllocGlobal"/></perObjectGlobal>
		<next public="1"><c path="hxsl.AllocParam"/></next>
		<clone public="1" set="method" line="18">
			<f a="?resetGID" v="false">
				<x path="Bool"/>
				<c path="hxsl.AllocParam"/>
			</f>
			<meta><m n=":value"><e>{ resetGID : false }</e></m></meta>
		</clone>
		<new public="1" set="method" line="11"><f a="name:pos:instance:index:type">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="hxsl.Type"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.AllocGlobal" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/RuntimeShader.hx" module="hxsl.RuntimeShader">
		<pos public="1"><x path="Int"/></pos>
		<gid public="1"><x path="Int"/></gid>
		<path public="1"><c path="String"/></path>
		<type public="1"><e path="hxsl.Type"/></type>
		<next public="1"><c path="hxsl.AllocGlobal"/></next>
		<clone public="1" set="method" line="38">
			<f a="?resetGID" v="false">
				<x path="Bool"/>
				<c path="hxsl.AllocGlobal"/>
			</f>
			<meta><m n=":value"><e>{ resetGID : false }</e></m></meta>
		</clone>
		<new public="1" set="method" line="32"><f a="pos:path:type">
	<x path="Int"/>
	<c path="String"/>
	<e path="hxsl.Type"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.RuntimeShaderData" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/RuntimeShader.hx" module="hxsl.RuntimeShader">
		<vertex public="1"><x path="Bool"/></vertex>
		<data public="1"><t path="hxsl.ShaderData"/></data>
		<code public="1"><c path="String"/></code>
		<params public="1"><c path="hxsl.AllocParam"/></params>
		<paramsSize public="1"><x path="Int"/></paramsSize>
		<globals public="1"><c path="hxsl.AllocGlobal"/></globals>
		<globalsSize public="1"><x path="Int"/></globalsSize>
		<textures public="1"><c path="hxsl.AllocParam"/></textures>
		<texturesCount public="1"><x path="Int"/></texturesCount>
		<buffers public="1"><c path="hxsl.AllocParam"/></buffers>
		<bufferCount public="1"><x path="Int"/></bufferCount>
		<consts public="1"><c path="Array"><x path="Float"/></c></consts>
		<new public="1" set="method" line="59"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.ShaderInstanceDesc" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/RuntimeShader.hx" module="hxsl.RuntimeShader">
		<shader public="1"><c path="hxsl.SharedShader"/></shader>
		<bits public="1"><x path="Int"/></bits>
		<index public="1"><x path="Int"/></index>
		<new public="1" set="method" line="67"><f a="shader:bits">
	<c path="hxsl.SharedShader"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.RuntimeShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/RuntimeShader.hx">
		<UID expr="0" line="75" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UID>
		<id public="1"><x path="Int"/></id>
		<vertex public="1"><c path="hxsl.RuntimeShaderData"/></vertex>
		<fragment public="1"><c path="hxsl.RuntimeShaderData"/></fragment>
		<globals public="1"><t path="Map">
	<x path="Int"/>
	<x path="Bool"/>
</t></globals>
		<signature public="1">
			<c path="String"/>
			<haxe_doc>Signature of the resulting HxSL code.
		Several shaders with the different specification might still get the same resulting signature.</haxe_doc>
		</signature>
		<spec public="1"><a>
	<signature><c path="String"/></signature>
	<instances><c path="Array"><c path="hxsl.ShaderInstanceDesc"/></c></instances>
</a></spec>
		<hasGlobal public="1" get="inline" set="null" line="92"><f a="gid">
	<x path="Int"/>
	<x path="Bool"/>
</f></hasGlobal>
		<new public="1" set="method" line="88"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.ShaderList" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/ShaderList.hx">
		<addSort public="1" set="method" line="20" static="1"><f a="s:shaders">
	<c path="hxsl.Shader"/>
	<c path="hxsl.ShaderList"/>
	<c path="hxsl.ShaderList"/>
</f></addSort>
		<s public="1"><c path="hxsl.Shader"/></s>
		<next public="1"><c path="hxsl.ShaderList"/></next>
		<clone public="1" set="method" line="10"><f a=""><x path="Null"><c path="hxsl.ShaderList"/></x></f></clone>
		<iterator public="1" get="inline" set="null" line="13"><f a=""><c path="hxsl._ShaderList.ShaderIterator"/></f></iterator>
		<iterateTo public="1" get="inline" set="null" line="16"><f a="s">
	<c path="hxsl.ShaderList"/>
	<c path="hxsl._ShaderList.ShaderIterator"/>
</f></iterateTo>
		<new public="1" set="method" line="6"><f a="s:?n">
	<c path="hxsl.Shader"/>
	<c path="hxsl.ShaderList"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl._ShaderList.ShaderIterator" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/ShaderList.hx" private="1" module="hxsl.ShaderList">
		<l><c path="hxsl.ShaderList"/></l>
		<last><c path="hxsl.ShaderList"/></last>
		<hasNext public="1" get="inline" set="null" line="43"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="46"><f a=""><c path="hxsl.Shader"/></f></next>
		<new public="1" get="inline" set="null" line="39"><f a="l:last">
	<c path="hxsl.ShaderList"/>
	<c path="hxsl.ShaderList"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.ShaderInstance" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/SharedShader.hx" module="hxsl.SharedShader">
		<id public="1"><x path="Int"/></id>
		<shader public="1"><t path="hxsl.ShaderData"/></shader>
		<params public="1"><t path="Map">
	<x path="Int"/>
	<x path="Int"/>
</t></params>
		<new public="1" set="method" line="8"><f a="shader">
	<t path="hxsl.ShaderData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.ShaderGlobal" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/SharedShader.hx" module="hxsl.SharedShader">
		<v public="1"><t path="hxsl.TVar"/></v>
		<globalId public="1"><x path="Int"/></globalId>
		<new public="1" set="method" line="18"><f a="v:gid">
	<t path="hxsl.TVar"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.ShaderConst" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/SharedShader.hx" module="hxsl.SharedShader">
		<v public="1"><t path="hxsl.TVar"/></v>
		<pos public="1"><x path="Int"/></pos>
		<bits public="1"><x path="Int"/></bits>
		<globalId public="1"><x path="Int"/></globalId>
		<next public="1"><c path="hxsl.ShaderConst"/></next>
		<new public="1" set="method" line="30"><f a="v:pos:bits">
	<t path="hxsl.TVar"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.SharedShader" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/SharedShader.hx">
		<UNROLL_LOOPS public="1" expr="false" line="39" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</UNROLL_LOOPS>
		<data public="1"><t path="hxsl.ShaderData"/></data>
		<globals public="1"><c path="Array"><c path="hxsl.ShaderGlobal"/></c></globals>
		<consts public="1"><c path="hxsl.ShaderConst"/></consts>
		<instanceCache><t path="Map">
	<x path="Int"/>
	<c path="hxsl.ShaderInstance"/>
</t></instanceCache>
		<paramsCount><x path="Int"/></paramsCount>
		<initialize set="method" line="57"><f a=""><x path="Void"/></f></initialize>
		<getInstance public="1" get="inline" set="null" line="63"><f a="constBits">
	<x path="Int"/>
	<c path="hxsl.ShaderInstance"/>
</f></getInstance>
		<makeInstance set="method" line="68"><f a="constBits">
	<x path="Int"/>
	<c path="hxsl.ShaderInstance"/>
</f></makeInstance>
		<addSelfParam set="method" line="95"><f a="i:v">
	<c path="hxsl.ShaderInstance"/>
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></addSelfParam>
		<addParam set="method" line="108"><f a="eval:i:v">
	<c path="hxsl.Eval"/>
	<c path="hxsl.ShaderInstance"/>
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></addParam>
		<browseVar set="method" line="121"><f a="v:?path">
	<t path="hxsl.TVar"/>
	<c path="String"/>
	<x path="Void"/>
</f></browseVar>
		<new public="1" set="method" line="47"><f a="src">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl._Splitter.VarProps" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Splitter.hx" private="1" module="hxsl.Splitter">
		<v public="1"><t path="hxsl.TVar"/></v>
		<read public="1"><x path="Int"/></read>
		<write public="1"><x path="Int"/></write>
		<local public="1"><x path="Bool"/></local>
		<requireInit public="1"><x path="Bool"/></requireInit>
		<new public="1" set="method" line="10"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxsl.Splitter" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Splitter.hx">
		<vars><t path="Map">
	<x path="Int"/>
	<c path="hxsl._Splitter.VarProps"/>
</t></vars>
		<varNames><t path="Map">
	<c path="String"/>
	<t path="hxsl.TVar"/>
</t></varNames>
		<varMap><t path="Map">
	<t path="hxsl.TVar"/>
	<t path="hxsl.TVar"/>
</t></varMap>
		<split public="1" set="method" line="26"><f a="s">
	<t path="hxsl.ShaderData"/>
	<a>
		<vertex><t path="hxsl.ShaderData"/></vertex>
		<fragment><t path="hxsl.ShaderData"/></fragment>
	</a>
</f></split>
		<addExpr set="method" line="174"><f a="f:e">
	<t path="hxsl.TFunction"/>
	<t path="hxsl.TExpr"/>
	<x path="Void"/>
</f></addExpr>
		<checkVar set="method" line="183"><f a="v:vertex:vvars:p">
	<c path="hxsl._Splitter.VarProps"/>
	<x path="Bool"/>
	<t path="Map">
		<x path="Int"/>
		<c path="hxsl._Splitter.VarProps"/>
	</t>
	<t path="hxsl.Position"/>
	<x path="Void"/>
</f></checkVar>
		<mapVars set="method" line="196"><f a="e">
	<t path="hxsl.TExpr"/>
	<t path="hxsl.TExpr"/>
</f></mapVars>
		<get set="method" line="206"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Null"><c path="hxsl._Splitter.VarProps"/></x>
</f></get>
		<uniqueName set="method" line="216"><f a="v">
	<t path="hxsl.TVar"/>
	<x path="Void"/>
</f></uniqueName>
		<checkExpr set="method" line="233"><f a="e">
	<t path="hxsl.TExpr"/>
	<x path="Void"/>
</f></checkExpr>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="hxsl.Vec" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.Vector"/></typedef>
	<typedef path="hxsl.IVec" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="Array"><x path="Int"/></c></typedef>
	<typedef path="hxsl.BVec" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="Array"><x path="Bool"/></c></typedef>
	<typedef path="hxsl.Matrix" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.Matrix"/></typedef>
	<typedef path="hxsl.Texture" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.mat.Texture"/></typedef>
	<typedef path="hxsl.Sampler2D" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.mat.Texture"/></typedef>
	<typedef path="hxsl.Sampler2DArray" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.mat.TextureArray"/></typedef>
	<typedef path="hxsl.SamplerCube" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.mat.Texture"/></typedef>
	<typedef path="hxsl.ChannelTextureType" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.mat.Texture"/></typedef>
	<typedef path="hxsl.Buffer" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><c path="h3d.Buffer"/></typedef>
	<class path="hxsl.ChannelTools" params="" file="E:\HaxeToolkit\lib_haxe4\heaps/git/hxsl/Types.hx" module="hxsl.Types"><isPackedFormat public="1" get="inline" set="null" line="15" static="1"><f a="c">
	<t path="hxsl.ChannelTextureType"/>
	<x path="Bool"/>
</f></isPackedFormat></class>
	<class path="samples.DocMacro" params="" file="./samples/DocMacro.hx">
		<getFiles set="method" static="1"><f a=""><d/></f></getFiles>
		<main set="method" line="47" static="1"><f a=""><x path="Void"/></f></main>
	</class>
	<typedef path="sys.FileStat" params="" file="E:\HaxeToolkit\haxe\std\sys/FileStat.hx">
		<a>
			<uid>
				<x path="Int"/>
				<haxe_doc>The user id for the file's owner.</haxe_doc>
			</uid>
			<size>
				<x path="Int"/>
				<haxe_doc>The size of the file, in bytes.</haxe_doc>
			</size>
			<rdev>
				<x path="Int"/>
				<haxe_doc>The device type on which stat resides (special files only).</haxe_doc>
			</rdev>
			<nlink>
				<x path="Int"/>
				<haxe_doc>The number of hard links to stat.</haxe_doc>
			</nlink>
			<mtime>
				<c path="Date"/>
				<haxe_doc>The last modification time for the file.</haxe_doc>
			</mtime>
			<mode>
				<x path="Int"/>
				<haxe_doc>The permission bits of stat. The meaning of the bits is platform dependent.</haxe_doc>
			</mode>
			<ino>
				<x path="Int"/>
				<haxe_doc>The inode number for stat.</haxe_doc>
			</ino>
			<gid>
				<x path="Int"/>
				<haxe_doc>The user group id for the file's owner.</haxe_doc>
			</gid>
			<dev>
				<x path="Int"/>
				<haxe_doc>The device on which stat resides.</haxe_doc>
			</dev>
			<ctime>
				<c path="Date"/>
				<haxe_doc>The creation time for the file (not all file systems support this).</haxe_doc>
			</ctime>
			<atime>
				<c path="Date"/>
				<haxe_doc>The last access time for the file (when enabled by the file system).</haxe_doc>
			</atime>
		</a>
		<haxe_doc>File information, as given by `sys.FileSystem.stat`.</haxe_doc>
	</typedef>
	<class path="sys.FileSystem" params="" file="E:\HaxeToolkit\haxe\std\sys/FileSystem.hx" extern="1">
		<exists public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the file or directory specified by `path` exists.

		If `path` is null, the result is unspecified.</haxe_doc>
		</exists>
		<rename public="1" set="method" static="1">
			<f a="path:newPath">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Renames/moves the file or directory specified by `path` to `newPath`.

		If `path` is not a valid file system entry, or if it is not accessible,
		or if `newPath` is not accessible, an exception is thrown.

		If `path` or `newPath` are null, the result is unspecified.</haxe_doc>
		</rename>
		<stat public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<t path="sys.FileStat"/>
			</f>
			<haxe_doc>Returns `FileStat` information on the file or directory specified by
		`path`.

		If `path` is null, the result is unspecified.</haxe_doc>
		</stat>
		<fullPath public="1" set="method" static="1">
			<f a="relPath">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the full path of the file or directory specified by `relPath`,
		which is relative to the current working directory. Symlinks will be
		followed and the path will be normalized.

		If `relPath` is null, the result is unspecified.</haxe_doc>
		</fullPath>
		<absolutePath public="1" set="method" static="1">
			<f a="relPath">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the full path of the file or directory specified by `relPath`,
		which is relative to the current working directory. The path doesn't
		have to exist.

		If `relPath` is null, the result is unspecified.</haxe_doc>
		</absolutePath>
		<isDirectory public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the file or directory specified by `path` is a directory.

		If `path` is not a valid file system entry or if its destination is not
		accessible, an exception is thrown.

		If `path` is null, the result is unspecified.</haxe_doc>
		</isDirectory>
		<createDirectory public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a directory specified by `path`.

		This method is recursive: The parent directories don't have to exist.

		If the directory cannot be created, an exception is thrown.

		If `path` is null, the result is unspecified.</haxe_doc>
		</createDirectory>
		<deleteFile public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the file specified by `path`.

		If `path` does not denote a valid file, or if that file cannot be
		deleted, an exception is thrown.

		If `path` is null, the result is unspecified.</haxe_doc>
		</deleteFile>
		<deleteDirectory public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the directory specified by `path`.

		If `path` does not denote a valid directory, or if that directory cannot
		be deleted, an exception is thrown.

		If `path` is null, the result is unspecified.</haxe_doc>
		</deleteDirectory>
		<readDirectory public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the names of all files and directories in the directory specified
		by `path`.

		If `path` does not denote a valid directory, an exception is thrown.

		If `path` is null, the result is unspecified.</haxe_doc>
		</readDirectory>
		<haxe_doc>This class allows you to get information about the files and directories.

	See `sys.io.File` for the complementary file API.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="sys.io.File" params="" file="E:\HaxeToolkit\haxe\std\sys/io/File.hx" extern="1">
		<getContent public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Retrieves the content of the file specified by `path` as a String.

		If the file does not exist or can not be read, an exception is thrown.

		`sys.FileSystem.exists` can be used to check for existence.

		If `path` is null, the result is unspecified.</haxe_doc>
		</getContent>
		<saveContent public="1" set="method" static="1">
			<f a="path:content">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores `content` in the file specified by `path`.

		If the file cannot be written to, an exception is thrown.

		If `path` or `content` are null, the result is unspecified.</haxe_doc>
		</saveContent>
		<getBytes public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Retrieves the binary content of the file specified by `path`.

		If the file does not exist or can not be read, an exception is thrown.

		`sys.FileSystem.exists` can be used to check for existence.

		If `path` is null, the result is unspecified.</haxe_doc>
		</getBytes>
		<saveBytes public="1" set="method" static="1">
			<f a="path:bytes">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores `bytes` in the file specified by `path` in binary mode.

		If the file cannot be written to, an exception is thrown.

		If `path` or `bytes` are null, the result is unspecified.</haxe_doc>
		</saveBytes>
		<read public="1" set="method" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileInput"/>
			</f>
			<meta><m n=":value"><e>{ binary : true }</e></m></meta>
			<haxe_doc>Returns an `FileInput` handle to the file specified by `path`.

		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.

		If the file does not exist or can not be read, an exception is thrown.

		Operations on the returned `FileInput` handle read on the opened file.

		File handles should be closed via `FileInput.close` once the operation
		is complete.

		If `path` is null, the result is unspecified.</haxe_doc>
		</read>
		<write public="1" set="method" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<meta><m n=":value"><e>{ binary : true }</e></m></meta>
			<haxe_doc>Returns an `FileOutput` handle to the file specified by `path`.

		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.

		If the file cannot be written to, an exception is thrown.

		Operations on the returned `FileOutput` handle write to the opened file.
		If the file existed, its previous content is overwritten.

		File handles should be closed via `FileOutput.close` once the operation
		is complete.

		If `path` is null, the result is unspecified.</haxe_doc>
		</write>
		<append public="1" set="method" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<meta><m n=":value"><e>{ binary : true }</e></m></meta>
			<haxe_doc>Similar to `sys.io.File.write`, but appends to the file if it exists
		instead of overwriting its contents.</haxe_doc>
		</append>
		<update public="1" set="method" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<meta><m n=":value"><e>{ binary : true }</e></m></meta>
			<haxe_doc>Similar to `sys.io.File.append`. While `append` can only seek or write
		starting from the end of the file's previous contents, `update` can
		seek to any position, so the file's previous contents can be
		selectively overwritten.</haxe_doc>
		</update>
		<copy public="1" set="method" static="1">
			<f a="srcPath:dstPath">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies the contents of the file specified by `srcPath` to the file
		specified by `dstPath`.

		If the `srcPath` does not exist or cannot be read, or if the `dstPath`
		file cannot be written to, an exception is thrown.

		If the file at `dstPath` exists, its contents are overwritten.

		If `srcPath` or `dstPath` are null, the result is unspecified.</haxe_doc>
		</copy>
		<haxe_doc>API for reading and writing to files.

	See `sys.FileSystem` for the complementary file system API.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="sys.io.FileInput" params="" file="E:\HaxeToolkit\haxe\std\sys/io/FileInput.hx" extern="1">
		<extends path="haxe.io.Input"/>
		<seek public="1" set="method"><f a="p:pos">
	<x path="Int"/>
	<e path="sys.io.FileSeek"/>
	<x path="Void"/>
</f></seek>
		<tell public="1" set="method"><f a=""><x path="Int"/></f></tell>
		<eof public="1" set="method"><f a=""><x path="Bool"/></f></eof>
		<haxe_doc>Use `sys.io.File.read` to create a `FileInput`.</haxe_doc>
	</class>
	<class path="sys.io.FileOutput" params="" file="E:\HaxeToolkit\haxe\std\sys/io/FileOutput.hx" extern="1">
		<extends path="haxe.io.Output"/>
		<seek public="1" set="method"><f a="p:pos">
	<x path="Int"/>
	<e path="sys.io.FileSeek"/>
	<x path="Void"/>
</f></seek>
		<tell public="1" set="method"><f a=""><x path="Int"/></f></tell>
		<haxe_doc>Use `sys.io.File.write` to create a `FileOutput`.</haxe_doc>
	</class>
	<enum path="sys.io.FileSeek" params="" file="E:\HaxeToolkit\haxe\std\sys/io/FileSeek.hx">
		<SeekBegin/>
		<SeekCur/>
		<SeekEnd/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
</haxe>